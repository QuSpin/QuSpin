
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" /><script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-110543543-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <title>quspin.basis.basis_general.base_general &#8212; QuSpin 0.3.6 documentation</title>
    <link rel="stylesheet" href="../../../../static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../../static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../../../" src="../../../../static/documentation_options.js"></script>
    <script src="../../../../static/jquery.js"></script>
    <script src="../../../../static/underscore.js"></script>
    <script src="../../../../static/doctools.js"></script>
    <script src="../../../../static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">QuSpin 0.3.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for quspin.basis.basis_general.base_general</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">_np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">_sp</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span><span class="nn">numexpr</span>
<span class="kn">from</span> <span class="nn">._basis_general_core.general_basis_utils</span> <span class="kn">import</span> <span class="n">basis_int_to_python_int</span><span class="p">,</span><span class="n">_get_basis_index</span>
<span class="kn">from</span> <span class="nn">._basis_general_core</span> <span class="kn">import</span> <span class="n">basis_zeros</span>
<span class="kn">from</span> <span class="nn">..lattice</span> <span class="kn">import</span> <span class="n">lattice_basis</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="k">class</span> <span class="nc">GeneralBasisWarning</span><span class="p">(</span><span class="ne">Warning</span><span class="p">):</span>
	<span class="k">pass</span>

<span class="k">def</span> <span class="nf">process_map</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span><span class="n">q</span><span class="p">):</span>
	<span class="nb">map</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
	<span class="n">i_map</span> <span class="o">=</span> <span class="nb">map</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
	<span class="n">i_map</span><span class="p">[</span><span class="nb">map</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">i_map</span><span class="p">[</span><span class="nb">map</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># site mapping</span>
	<span class="n">s_map</span> <span class="o">=</span> <span class="nb">map</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="c1"># sites with spin-inversion</span>

	<span class="n">sites</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">map</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
	<span class="n">order</span> <span class="o">=</span> <span class="n">sites</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

	<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">i_map</span><span class="p">)</span><span class="o">-</span><span class="n">order</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;map must be a one-to-one site mapping.&quot;</span><span class="p">)</span>

	<span class="n">per</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="n">group</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">order</span><span class="p">)]</span>
	<span class="k">while</span><span class="p">(</span><span class="kc">True</span><span class="p">):</span>
		<span class="n">sites</span><span class="p">[</span><span class="n">s_map</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">sites</span><span class="p">[</span><span class="n">s_map</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">sites</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="n">i_map</span><span class="p">]</span>
		<span class="n">per</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="n">group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sites</span><span class="p">))</span>
		<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">order</span><span class="p">,</span><span class="n">sites</span><span class="p">):</span>
			<span class="k">break</span>

	<span class="k">if</span> <span class="n">per</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;identity mapping found in set of transformations.&quot;</span><span class="p">,</span><span class="n">GeneralBasisWarning</span><span class="p">,</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

	<span class="k">return</span> <span class="nb">map</span><span class="p">,</span><span class="n">per</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="nb">set</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">check_symmetry_maps</span><span class="p">(</span><span class="n">item1</span><span class="p">,</span><span class="n">item2</span><span class="p">):</span>
	<span class="n">grp1</span> <span class="o">=</span> <span class="n">item1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="n">map1</span> <span class="o">=</span> <span class="n">item1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
	<span class="n">block1</span> <span class="o">=</span> <span class="n">item1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

	<span class="n">i_map1</span> <span class="o">=</span> <span class="n">map1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
	<span class="n">i_map1</span><span class="p">[</span><span class="n">map1</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">i_map1</span><span class="p">[</span><span class="n">map1</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># site mapping</span>
	<span class="n">s_map1</span> <span class="o">=</span> <span class="n">map1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="c1"># sites with spin-inversion		</span>

	<span class="n">grp2</span> <span class="o">=</span> <span class="n">item2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="n">map2</span> <span class="o">=</span> <span class="n">item2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
	<span class="n">block2</span> <span class="o">=</span> <span class="n">item2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

	<span class="n">i_map2</span> <span class="o">=</span> <span class="n">map2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
	<span class="n">i_map2</span><span class="p">[</span><span class="n">map2</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">i_map2</span><span class="p">[</span><span class="n">map2</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># site mapping</span>
	<span class="n">s_map2</span> <span class="o">=</span> <span class="n">map2</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="c1"># sites with spin-inversion</span>

	<span class="k">if</span> <span class="n">grp1</span> <span class="o">==</span> <span class="n">grp2</span><span class="p">:</span>
		<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;mappings for block </span><span class="si">{}</span><span class="s2"> and block </span><span class="si">{}</span><span class="s2"> produce the same symmetry.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">block1</span><span class="p">,</span><span class="n">block2</span><span class="p">),</span><span class="n">GeneralBasisWarning</span><span class="p">,</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

	<span class="n">sites1</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">map1</span><span class="p">))</span>
	<span class="n">sites2</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">map2</span><span class="p">))</span>

	<span class="n">sites1</span><span class="p">[</span><span class="n">s_map1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">sites1</span><span class="p">[</span><span class="n">s_map1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="n">sites1</span> <span class="o">=</span> <span class="n">sites1</span><span class="p">[</span><span class="n">i_map1</span><span class="p">]</span>
	<span class="n">sites1</span><span class="p">[</span><span class="n">s_map2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">sites1</span><span class="p">[</span><span class="n">s_map2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="n">sites1</span> <span class="o">=</span> <span class="n">sites1</span><span class="p">[</span><span class="n">i_map2</span><span class="p">]</span>

	<span class="n">sites2</span><span class="p">[</span><span class="n">s_map2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">sites2</span><span class="p">[</span><span class="n">s_map2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="n">sites2</span> <span class="o">=</span> <span class="n">sites2</span><span class="p">[</span><span class="n">i_map2</span><span class="p">]</span>
	<span class="n">sites2</span><span class="p">[</span><span class="n">s_map1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">sites2</span><span class="p">[</span><span class="n">s_map1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="n">sites2</span> <span class="o">=</span> <span class="n">sites2</span><span class="p">[</span><span class="n">i_map1</span><span class="p">]</span>

	<span class="k">if</span> <span class="ow">not</span> <span class="n">_np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">sites1</span><span class="p">,</span><span class="n">sites2</span><span class="p">):</span>
		<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;using non-commuting symmetries can lead to unwanted behaviour of general basis, make sure that quantum numbers are invariant under non-commuting symmetries!&quot;</span><span class="p">,</span><span class="n">GeneralBasisWarning</span><span class="p">,</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>




<span class="k">class</span> <span class="nc">basis_general</span><span class="p">(</span><span class="n">lattice_basis</span><span class="p">):</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">block_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="n">lattice_basis</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_unique_me</span> <span class="o">=</span> <span class="kc">True</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_herm</span> <span class="o">=</span> <span class="kc">True</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_check_pcon</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_basis_pcon</span> <span class="o">=</span> <span class="kc">None</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_get_proj_pcon</span> <span class="o">=</span> <span class="kc">False</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_made_basis</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># keeps track of whether the basis has been made</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_Ns_block_est</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># initialize number of states variable</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">basis_general</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;general_basis class is not to be instantiated.&quot;</span><span class="p">)</span>

		<span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
		
		<span class="c1"># if not kwargs:</span>
		<span class="c1"># 	raise ValueError(&quot;require at least one map.&quot;)</span>

		<span class="n">n_maps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">n_maps</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;general basis can only support up to 32 symmetries.&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">n_maps</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="o">=</span><span class="s1">&#39;custom symmetries&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="o">=</span><span class="s1">&#39;&#39;</span>

		<span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span><span class="o">!=</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="nb">map</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;blocks must contain tuple: (map,q).&quot;</span><span class="p">)</span>

		<span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">block</span><span class="p">:</span><span class="n">process_map</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">block</span><span class="p">,</span><span class="n">item</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
	
		<span class="k">if</span> <span class="n">block_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
			<span class="c1"># sort by periodicies smallest to largest for speed up</span>
			<span class="n">sorted_items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
			<span class="c1"># sorted_items.reverse()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">block_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">block_order</span><span class="p">)</span>
			<span class="n">missing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">block_order</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> names found in block names but missing from block_order.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">missing</span><span class="p">))</span>

			<span class="n">missing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">block_order</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> names found in block_order but missing from block names.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">missing</span><span class="p">))</span>

			<span class="n">block_order</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
			<span class="n">sorted_items</span> <span class="o">=</span> <span class="p">[(</span><span class="n">key</span><span class="p">,</span><span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">block_order</span><span class="p">]</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span> <span class="o">=</span> <span class="p">{</span><span class="n">block</span><span class="p">:((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">q</span> <span class="k">if</span> <span class="n">per</span><span class="o">==</span><span class="mi">2</span> <span class="k">else</span> <span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">block</span><span class="p">,(</span><span class="n">_</span><span class="p">,</span><span class="n">per</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">sorted_items</span><span class="p">}</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_maps_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">block</span><span class="p">:</span><span class="nb">map</span> <span class="k">for</span> <span class="n">block</span><span class="p">,(</span><span class="nb">map</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">sorted_items</span><span class="p">}</span>
		<span class="n">remove_index</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">item1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_items</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
			<span class="k">if</span> <span class="n">item1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">remove_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">item2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_items</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]):</span>
				<span class="n">check_symmetry_maps</span><span class="p">(</span><span class="n">item1</span><span class="p">,</span><span class="n">item2</span><span class="p">)</span>

		<span class="n">remove_index</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

		<span class="k">if</span> <span class="n">sorted_items</span><span class="p">:</span>
			<span class="n">blocks</span><span class="p">,</span><span class="n">items</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">sorted_items</span><span class="p">)</span>
			<span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">remove_index</span><span class="p">:</span>
				<span class="n">items</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

			<span class="n">n_maps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
			<span class="n">maps</span><span class="p">,</span><span class="n">pers</span><span class="p">,</span><span class="n">qs</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">items</span><span class="p">)</span>


			<span class="bp">self</span><span class="o">.</span><span class="n">_maps</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">maps</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_qs</span>   <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">qs</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_pers</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pers</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

			<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">for</span> <span class="nb">map</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maps</span><span class="p">[:]):</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;maps must be a 1-dim array/list of integers.&quot;</span><span class="p">)</span>

			<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">N</span> <span class="k">for</span> <span class="nb">map</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maps</span><span class="p">[:]):</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;size of map is not equal to N.&quot;</span><span class="p">)</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;number of maps must be the same as the number of quantum numbers provided.&quot;</span><span class="p">)</span>

			<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_maps</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
				<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n_maps</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
					<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">_maps</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
						<span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;repeated map in maps list.&quot;</span><span class="p">)</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_maps</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([[]],</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_qs</span>   <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_pers</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

		<span class="n">nmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pers</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_n_dtype</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="n">nmax</span><span class="p">)</span>


	<span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="n">obj_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
		<span class="n">obj_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_core&quot;</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">obj_dict</span>

	<span class="c1"># @property</span>
	<span class="c1"># def _fermion_basis(self):</span>
	<span class="c1"># 	return False</span>


	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;str: information about `basis` object.&quot;&quot;&quot;</span>
		<span class="n">blocks</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

		<span class="k">for</span> <span class="n">symm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">:</span>
			<span class="n">blocks</span> <span class="o">+=</span> <span class="n">symm</span><span class="o">+</span><span class="s2">&quot; = {&quot;</span><span class="o">+</span><span class="n">symm</span><span class="o">+</span><span class="s2">&quot;}, &quot;</span>

		<span class="n">blocks</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">)</span>

		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">symm</span> <span class="o">=</span> <span class="s2">&quot;no symmetry&quot;</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">symm</span> <span class="o">=</span> <span class="s2">&quot;symmetry&quot;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">symm</span> <span class="o">=</span> <span class="s2">&quot;symmetries&quot;</span>

		<span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;general basis for lattice of N = </span><span class="si">{0}</span><span class="s2"> sites containing </span><span class="si">{5}</span><span class="s2"> states </span><span class="se">\n\t</span><span class="si">{1}</span><span class="s2">: </span><span class="si">{2}</span><span class="s2"> </span><span class="se">\n\t</span><span class="s2">quantum numbers: </span><span class="si">{4}</span><span class="s2"> </span><span class="se">\n\n</span><span class="s2">&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">,</span><span class="n">symm</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">blocks</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">)</span>
		<span class="n">string</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span>
		<span class="k">return</span> <span class="n">string</span>


	<span class="k">def</span> <span class="nf">_int_to_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">state</span><span class="p">,</span><span class="n">bracket_notation</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">basis_int_to_python_int</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

		<span class="n">n_space</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sps</span><span class="p">))</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">64</span><span class="p">:</span>
			<span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">//</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">sps</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>
			<span class="n">s_str</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="s2">&quot;{:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n_space</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;d}&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bit</span><span class="p">)</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">bits</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">left_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">//</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">sps</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span>
			<span class="n">right_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">//</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">sps</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">-</span><span class="mi">32</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

			<span class="n">str_list</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;{:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n_space</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;d}&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bit</span><span class="p">)</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">left_bits</span><span class="p">]</span>
			<span class="n">str_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;...&quot;</span><span class="p">)</span>
			<span class="n">str_list</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="s2">&quot;{:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n_space</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;d}&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bit</span><span class="p">)</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">right_bits</span><span class="p">)</span>
			<span class="n">s_str</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">str_list</span><span class="p">))</span>

		<span class="k">if</span> <span class="n">bracket_notation</span><span class="p">:</span>
			<span class="k">return</span> <span class="s2">&quot;|&quot;</span><span class="o">+</span><span class="n">s_str</span><span class="o">+</span><span class="s2">&quot;&gt;&quot;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">s_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_state_to_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">state</span><span class="p">):</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">basis_int_to_python_int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">state</span><span class="p">)])</span>

	<span class="k">def</span> <span class="nf">_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
			<span class="n">s</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sps</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">_get_basis_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
	

	<span class="k">def</span> <span class="nf">_reduce_n_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_n_dtype</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dtype</span><span class="p">)</span>


	<span class="k">def</span> <span class="nf">_Op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="p">):</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_made_basis</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;this function requires the basis to be constructed first; use basis.make().&#39;</span><span class="p">)</span>

		<span class="n">indx</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">opstr</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indx</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;length of opstr does not match length of indx&#39;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;values in indx falls outside of system&#39;</span><span class="p">)</span>

		<span class="n">extra_ops</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">opstr</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allowed_ops</span>
		<span class="k">if</span> <span class="n">extra_ops</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unrecognized characters </span><span class="si">{}</span><span class="s2"> in operator string.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">extra_ops</span><span class="p">))</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span><span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index_type</span><span class="p">),</span><span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index_type</span><span class="p">)</span>
	
		<span class="n">col</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index_type</span><span class="p">)</span>
		<span class="n">row</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index_type</span><span class="p">)</span>
		<span class="n">ME</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
		<span class="c1"># print(self._Ns)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">,</span><span class="n">ME</span><span class="p">,</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_begin</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_end</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_N_p</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">ME</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">ME</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">_np</span><span class="o">.</span><span class="n">complex64</span><span class="p">:</span>
				<span class="n">mask</span> <span class="o">=</span> <span class="n">ME</span><span class="o">.</span><span class="n">real</span> <span class="o">!=</span> <span class="mi">0</span>
				<span class="n">mask1</span> <span class="o">=</span> <span class="n">ME</span><span class="o">.</span><span class="n">imag</span> <span class="o">!=</span> <span class="mi">0</span>
				<span class="n">_np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="n">mask1</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">mask</span> <span class="o">=</span> <span class="n">numexpr</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s2">&quot;(real(ME)!=0) | (imag(ME)!=0)&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="n">numexpr</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s2">&quot;ME!=0&quot;</span><span class="p">)</span>

		<span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
		<span class="n">row</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
		<span class="n">ME</span> <span class="o">=</span> <span class="n">ME</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

		<span class="k">return</span> <span class="n">ME</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span>

	
	<span class="k">def</span> <span class="nf">_inplace_Op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v_in</span><span class="p">,</span><span class="n">op_list</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">transposed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">conjugated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">v_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">a</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_made_basis</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;this function requires the basis to be constructed first; use basis.make().&#39;</span><span class="p">)</span>

		<span class="n">v_in</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">v_in</span><span class="p">)</span>
		
		<span class="n">result_dtype</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">v_in</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span><span class="n">dtype</span><span class="p">)</span>
		<span class="n">v_in</span> <span class="o">=</span> <span class="n">v_in</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_dtype</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">v_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dimension mismatch&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">v_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">v_out</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">v_in</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">result_dtype</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">v_out</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">result_dtype</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;v_out does not have the correct data type.&quot;</span><span class="p">)</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">v_out</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;CARRAY&quot;</span><span class="p">]:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;v_out is not a writable C-contiguous array&quot;</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">v_out</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">v_in</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid shape for v_out and v_in: v_in.shape != v_out.shape&quot;</span><span class="p">)</span>

		<span class="n">v_out</span> <span class="o">=</span> <span class="n">v_out</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="n">v_in</span> <span class="o">=</span> <span class="n">v_in</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>


		<span class="k">for</span> <span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span> <span class="ow">in</span> <span class="n">op_list</span><span class="p">:</span>
			<span class="n">indx</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">inplace_op</span><span class="p">(</span><span class="n">v_in</span><span class="p">,</span><span class="n">v_out</span><span class="p">,</span><span class="n">conjugated</span><span class="p">,</span><span class="n">transposed</span><span class="p">,</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">a</span><span class="o">*</span><span class="n">J</span><span class="p">,</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_begin</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_end</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_N_p</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">v_out</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>


	<span class="k">def</span> <span class="nf">Op_shift_sector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other_basis</span><span class="p">,</span><span class="n">op_list</span><span class="p">,</span><span class="n">v_in</span><span class="p">,</span><span class="n">v_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Applies symmetry non-conserving operator to state in symmetry-reduced basis.</span>

<span class="sd">		An operator, which does not conserve a symmetry, induces a change in the quantum number of a state defined in the corresponding symmetry sector. Hence, when the operator is applied on a quantum state, the state shifts the symmetry sector. `Op_shift_sector()` handles this automatically. </span>

<span class="sd">		:red:`NOTE: One has to make sure that (i) the operator moves the state between the two sectors, and (ii) the two bases objects have the same symmetries. This function will not give the correct results otherwise.`</span>

<span class="sd">		Formally  equivalent to:</span>

<span class="sd">		&gt;&gt;&gt; P1 = basis_sector_1.get_proj(np.complex128) # projector between full and initial basis</span>
<span class="sd">		&gt;&gt;&gt; P2 = basis_sector_2.get_proj(np.complex128) # projector between full and target basis</span>
<span class="sd">		&gt;&gt;&gt; v_in_full = P1.dot(v_in) # go from initial basis to to full basis</span>
<span class="sd">		&gt;&gt;&gt; v_out_full = basis_full.inplace_Op(v_in_full,op_list,np.complex128) # apply Op</span>
<span class="sd">		&gt;&gt;&gt; v_out = P2.H.dot(v_out_full) # project to target basis</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		* particularly useful when computing correlation functions.</span>
<span class="sd">		* supports parallelization to multiple states listed in the columns of `v_in`.</span>
<span class="sd">		* the user is strongly advised to use the code under &quot;Formally equivalent&quot; above to check the results of this function for small system sizes. </span>

<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		other_basis : `basis` object</span>
<span class="sd">			`basis_general` object for the initial symmetry sector. Must be the same `basis` class type as the basis whose instance is `Op_shift_sector()` (i.e. the basis in `basis.Op_shift_sector()`).  </span>
<span class="sd">		op_list : list</span>
<span class="sd">			Operator string list which defines the operator to apply. Follows the format `[[&quot;z&quot;,[i],Jz[i]] for i in range(L)], [&quot;x&quot;,[i],Jx[j]] for j in range(L)],...]`. </span>
<span class="sd">		v_in : array_like, (other_basis.Ns,...)</span>
<span class="sd">			Initial state to apply the symmetry non-conserving operator on. Must have the same length as `other_basis.Ns`. </span>
<span class="sd">		v_out : array_like, (basis.Ns,...), optional</span>
<span class="sd">			Optional array to write the result for the final/target state in. </span>
<span class="sd">		dtype : numpy dtype for matrix elements, optional</span>
<span class="sd">			Data type (e.g. `numpy.float64`) to construct the operator with.</span>

<span class="sd">		Returns</span>
<span class="sd">		--------</span>
<span class="sd">		(basis.Ns, ) numpy.ndarray</span>
<span class="sd">			Array containing the state `v_out` in the current basis, i.e. the basis in `basis.Op_shift_sector()`.</span>

<span class="sd">		Examples</span>
<span class="sd">		--------</span>

<span class="sd">		&gt;&gt;&gt; v_out = basis.Op_shift_sector(initial_basis, op_list, v_in)</span>
<span class="sd">		&gt;&gt;&gt; print(v_out.shape, basis.Ns, v_in.shape, initial_basis.Ns)</span>

<span class="sd">		&quot;&quot;&quot;</span>


		
		<span class="c1"># consider flag to do calc with projectors instead to use as a check. </span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_basis</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;other_basis must be the same type as the given basis.&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_made_basis</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;this function requires the basis to be constructed first; use basis.make().&#39;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="n">other_basis</span><span class="o">.</span><span class="n">_made_basis</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;this function requires the basis to be constructed first; use basis.make().&#39;</span><span class="p">)</span>


		<span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">J_list</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">op_list</span><span class="p">)</span>

		<span class="n">J_list</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">J_list</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">J_list</span> <span class="o">=</span> <span class="n">J_list</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

		<span class="n">v_in</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">v_in</span><span class="p">)</span>

		<span class="n">result_dtype</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span><span class="n">J_list</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span><span class="n">v_in</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

		<span class="n">v_in</span> <span class="o">=</span> <span class="n">v_in</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_dtype</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">v_in</span> <span class="o">=</span> <span class="n">v_in</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">other_basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="n">nvecs</span> <span class="o">=</span> <span class="n">v_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

		<span class="k">if</span> <span class="n">v_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">other_basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid shape for v_in&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">v_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">v_out</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="n">nvecs</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">result_dtype</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">v_out</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">result_dtype</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;v_out does not have the correct data type.&quot;</span><span class="p">)</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">v_out</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;CARRAY&quot;</span><span class="p">]:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;v_out is not a writable C-contiguous array&quot;</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">v_out</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="n">nvecs</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid shape for v_out&quot;</span><span class="p">)</span>


		<span class="k">for</span> <span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span> <span class="ow">in</span> <span class="n">op_list</span><span class="p">:</span>
			<span class="n">indx</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">op_shift_sector</span><span class="p">(</span><span class="n">v_in</span><span class="p">,</span><span class="n">v_out</span><span class="p">,</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">,</span><span class="n">other_basis</span><span class="o">.</span><span class="n">_basis</span><span class="p">,</span><span class="n">other_basis</span><span class="o">.</span><span class="n">_n</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">nvecs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">v_out</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">v_out</span>


	<span class="k">def</span> <span class="nf">get_proj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">pcon</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Calculates transformation/projector from symmetry-reduced basis to full (symmetry-free) basis.</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		* particularly useful when a given operation canot be carried out in the symmetry-reduced basis in a straightforward manner.</span>
<span class="sd">		</span>
<span class="sd">		* see also `Op_shift_sector()`.</span>

<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		dtype : &#39;type&#39;</span>
<span class="sd">			Data type (e.g. numpy.float64) to construct the projector with.</span>
<span class="sd">		pcon : bool, optional</span>
<span class="sd">			Whether or not to return the projector to the particle number (magnetisation) conserving basis </span>
<span class="sd">			(useful in bosonic/single particle systems). Default is `pcon=False`.</span>
<span class="sd">		</span>
<span class="sd">		Returns</span>
<span class="sd">		--------</span>
<span class="sd">		scipy.sparse.csc_matrix</span>
<span class="sd">			Transformation/projector between the symmetry-reduced and the full basis.</span>

<span class="sd">		Examples</span>
<span class="sd">		--------</span>

<span class="sd">		&gt;&gt;&gt; P = get_proj(np.float64,pcon=False)</span>
<span class="sd">		&gt;&gt;&gt; print(P.shape)</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_made_basis</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;this function requires the basis to be constructed first; use basis.make().&#39;</span><span class="p">)</span>

		<span class="n">basis_pcon</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="n">Ns_full</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sps</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">pcon</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_proj_pcon</span><span class="p">:</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_pcon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_basis_pcon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_pcon_args</span><span class="p">)</span>

			<span class="n">basis_pcon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_pcon</span><span class="o">.</span><span class="n">_basis</span>
			<span class="n">Ns_full</span> <span class="o">=</span> <span class="n">basis_pcon</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">elif</span> <span class="n">pcon</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_proj_pcon</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;pcon=True only works for basis of a single particle number sector.&quot;</span><span class="p">)</span>

		<span class="n">sign</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
		<span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
		<span class="n">c</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pers</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>
		<span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
		<span class="n">_np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
		<span class="n">index_type</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="o">-</span><span class="n">Ns_full</span><span class="p">),</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
		<span class="n">indptr</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">index_type</span><span class="p">)</span>
		<span class="n">indices</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">index_type</span><span class="p">)</span>

		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">get_proj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">sign</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">indices</span><span class="p">,</span><span class="n">indptr</span><span class="p">,</span><span class="n">basis_pcon</span><span class="o">=</span><span class="n">basis_pcon</span><span class="p">)</span>


	<span class="k">def</span> <span class="nf">project_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">pcon</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Transforms state from full (symmetry-free) basis to symmetry-reduced basis.</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		* particularly useful when a given operation cannot be carried out in the full basis.</span>
<span class="sd">		* supports parallelisation to multiple states listed in the columns. </span>
<span class="sd">		* inverse function to `project_from`. </span>


<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		v0 : numpy.ndarray</span>
<span class="sd">			Contains in its columns the states in the full (symmetry-free) basis.</span>
<span class="sd">		sparse : bool, optional</span>
<span class="sd">			Whether or not the output should be in sparse format. Default is `True`.</span>
<span class="sd">		pcon : bool, optional</span>
<span class="sd">			Whether or not to return the output in the particle number (magnetisation) conserving basis </span>
<span class="sd">			(useful in bosonic/single particle systems). Default is `pcon=False`.</span>
<span class="sd">		</span>
<span class="sd">		Returns</span>
<span class="sd">		--------</span>
<span class="sd">		numpy.ndarray</span>
<span class="sd">			Array containing the state `v0` in the symmetry-reduced basis.</span>

<span class="sd">		Examples</span>
<span class="sd">		--------</span>

<span class="sd">		&gt;&gt;&gt; v_symm = project_to(v0)</span>
<span class="sd">		&gt;&gt;&gt; print(v_symm.shape, v0.shape)</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">basis_pcon</span> <span class="o">=</span> <span class="kc">None</span>

		<span class="k">if</span> <span class="n">pcon</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_pcon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_basis_pcon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_pcon_args</span><span class="p">,</span><span class="n">make_basis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_basis_pcon</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="n">N_p</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

			<span class="n">basis_pcon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_pcon</span><span class="o">.</span><span class="n">_basis</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_made_basis</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;this function requires the basis to be cosntructed first, see basis.make().&#39;</span><span class="p">)</span>


		<span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="s2">&quot;shape&quot;</span><span class="p">):</span>
			<span class="n">v0</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>

		<span class="n">squeeze</span> <span class="o">=</span> <span class="kc">False</span>
		<span class="k">if</span> <span class="n">pcon</span><span class="p">:</span>
			<span class="n">Ns_full</span> <span class="o">=</span> <span class="n">basis_pcon</span><span class="o">.</span><span class="n">size</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">Ns_full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sps</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span>

		<span class="k">if</span> <span class="n">v0</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">v0</span> <span class="o">=</span> <span class="n">v0</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
			<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">squeeze</span> <span class="o">=</span> <span class="kc">True</span>
		<span class="k">elif</span> <span class="n">v0</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
			<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">,</span><span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;excpecting v0 to have ndim &gt; 0 and at most 2&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
			<span class="c1"># CHECK later</span>
			<span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(([],([],[])),</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">v0</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">v0</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Ns_full</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;v0 shape </span><span class="si">{0}</span><span class="s2"> not compatible with Ns_full=</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">Ns_full</span><span class="p">))</span>

		<span class="k">if</span> <span class="n">_sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">v0</span><span class="p">):</span> <span class="c1"># current work around for sparse states.</span>
			<span class="c1"># return self.get_proj(v0.dtype).dot(v0)</span>
			<span class="k">raise</span> <span class="ne">ValueError</span>

		<span class="n">v0</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
			<span class="c1"># current work-around for sparse</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_proj</span><span class="p">(</span><span class="n">v0</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span><span class="n">pcon</span><span class="o">=</span><span class="n">pcon</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">v0</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">v_out</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v0</span><span class="o">.</span><span class="n">dtype</span><span class="p">,)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">project_to_dense</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">v_out</span><span class="p">,</span><span class="n">basis_pcon</span><span class="o">=</span><span class="n">basis_pcon</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">squeeze</span><span class="p">:</span>
				<span class="k">return</span>  <span class="n">_np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">v_out</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">v_out</span>	


	<span class="k">def</span> <span class="nf">get_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">pcon</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; DEPRECATED (cf `project_from`). Transforms state from symmetry-reduced basis to full (symmetry-free) basis.</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		This function is :red:`deprecated`. Use `project_from()` instead; see also the inverse function `project_to()`.</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_from</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="n">sparse</span><span class="p">,</span><span class="n">pcon</span><span class="o">=</span><span class="n">pcon</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">project_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">pcon</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Transforms state from symmetry-reduced basis to full (symmetry-free) basis.</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		* particularly useful when a given operation cannot be carried out in the symmetry-reduced basis in a straightforward manner.</span>
<span class="sd">		* supports parallelisation to multiple states listed in the columns.</span>
<span class="sd">		* inverse function to `project_to`.</span>

<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		v0 : numpy.ndarray</span>
<span class="sd">			Contains in its columns the states in the symmetry-reduced basis.</span>
<span class="sd">		sparse : bool, optional</span>
<span class="sd">			Whether or not the output should be in sparse format. Default is `True`.</span>
<span class="sd">		pcon : bool, optional</span>
<span class="sd">			Whether or not to return the output in the particle number (magnetisation) conserving basis </span>
<span class="sd">			(useful in bosonic/single particle systems). Default is `pcon=False`.</span>
<span class="sd">		</span>
<span class="sd">		Returns</span>
<span class="sd">		--------</span>
<span class="sd">		numpy.ndarray</span>
<span class="sd">			Array containing the state `v0` in the full basis.</span>

<span class="sd">		Examples</span>
<span class="sd">		--------</span>

<span class="sd">		&gt;&gt;&gt; v_full = project_from(v0)</span>
<span class="sd">		&gt;&gt;&gt; print(v_full.shape, v0.shape)</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">basis_pcon</span> <span class="o">=</span> <span class="kc">None</span>

		<span class="k">if</span> <span class="n">pcon</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_pcon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_basis_pcon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_pcon_args</span><span class="p">,</span><span class="n">make_basis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_basis_pcon</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="n">N_p</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

			<span class="n">basis_pcon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_pcon</span><span class="o">.</span><span class="n">_basis</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_made_basis</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;this function requires the basis to be cosntructed first, see basis.make().&#39;</span><span class="p">)</span>


		<span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="s2">&quot;shape&quot;</span><span class="p">):</span>
			<span class="n">v0</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>

		<span class="n">squeeze</span> <span class="o">=</span> <span class="kc">False</span>
		<span class="k">if</span> <span class="n">pcon</span><span class="p">:</span>
			<span class="n">Ns_full</span> <span class="o">=</span> <span class="n">basis_pcon</span><span class="o">.</span><span class="n">size</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">Ns_full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sps</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span>

		<span class="k">if</span> <span class="n">v0</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">v0</span> <span class="o">=</span> <span class="n">v0</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
			<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ns_full</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">squeeze</span> <span class="o">=</span> <span class="kc">True</span>
		<span class="k">elif</span> <span class="n">v0</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
			<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ns_full</span><span class="p">,</span><span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;excpecting v0 to have ndim &gt; 0 and at most 2&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(([],([],[])),</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">Ns_full</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">v0</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ns_full</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">v0</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;v0 shape </span><span class="si">{0}</span><span class="s2"> not compatible with Ns=</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">))</span>

		<span class="k">if</span> <span class="n">_sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">v0</span><span class="p">):</span> <span class="c1"># current work around for sparse states.</span>
			<span class="c1"># return self.get_proj(v0.dtype).dot(v0)</span>
			<span class="k">raise</span> <span class="ne">ValueError</span>

		<span class="n">v0</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
			<span class="c1"># current work-around for sparse</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_proj</span><span class="p">(</span><span class="n">v0</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span><span class="n">pcon</span><span class="o">=</span><span class="n">pcon</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">_sp</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">v0</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">v_out</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v0</span><span class="o">.</span><span class="n">dtype</span><span class="p">,)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">project_from_dense</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">v_out</span><span class="p">,</span><span class="n">basis_pcon</span><span class="o">=</span><span class="n">basis_pcon</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">squeeze</span><span class="p">:</span>
				<span class="k">return</span>  <span class="n">_np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">v_out</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">v_out</span>	


	<span class="k">def</span> <span class="nf">_check_symm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">static</span><span class="p">,</span><span class="n">dynamic</span><span class="p">,</span><span class="n">photon_basis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">photon_basis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">basis_sort_opstr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_opstr</span>
			<span class="n">static_list</span><span class="p">,</span><span class="n">dynamic_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_local_lists</span><span class="p">(</span><span class="n">static</span><span class="p">,</span><span class="n">dynamic</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">basis_sort_opstr</span> <span class="o">=</span> <span class="n">photon_basis</span><span class="o">.</span><span class="n">_sort_opstr</span>
			<span class="n">static_list</span><span class="p">,</span><span class="n">dynamic_list</span> <span class="o">=</span> <span class="n">photon_basis</span><span class="o">.</span><span class="n">_get_local_lists</span><span class="p">(</span><span class="n">static</span><span class="p">,</span><span class="n">dynamic</span><span class="p">)</span>


		<span class="n">static_blocks</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="n">dynamic_blocks</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="k">for</span> <span class="n">block</span><span class="p">,</span><span class="nb">map</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maps_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="n">key</span> <span class="o">=</span> <span class="n">block</span><span class="o">+</span><span class="s2">&quot; symm&quot;</span>
			<span class="n">odd_ops</span><span class="p">,</span><span class="n">missing_ops</span> <span class="o">=</span> <span class="n">_check_symm_map</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span><span class="n">basis_sort_opstr</span><span class="p">,</span><span class="n">static_list</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">odd_ops</span> <span class="ow">or</span> <span class="n">missing_ops</span><span class="p">:</span>
				<span class="n">static_blocks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">odd_ops</span><span class="p">),</span><span class="nb">tuple</span><span class="p">(</span><span class="n">missing_ops</span><span class="p">))</span>

			<span class="n">odd_ops</span><span class="p">,</span><span class="n">missing_ops</span> <span class="o">=</span> <span class="n">_check_symm_map</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span><span class="n">basis_sort_opstr</span><span class="p">,</span><span class="n">dynamic_list</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">odd_ops</span> <span class="ow">or</span> <span class="n">missing_ops</span><span class="p">:</span>
				<span class="n">dynamic_blocks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">odd_ops</span><span class="p">),</span><span class="nb">tuple</span><span class="p">(</span><span class="n">missing_ops</span><span class="p">))</span>


		<span class="k">return</span> <span class="n">static_blocks</span><span class="p">,</span><span class="n">dynamic_blocks</span>


	<span class="k">def</span> <span class="nf">make</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Ns_block_est</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">N_p</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Creates the entire basis by calling the basis constructor.</span>

<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		Ns_block_est: int, optional</span>
<span class="sd">			Overwrites the internal estimate of the size of the reduced Hilbert space for the given symmetries. This can be used to help conserve memory if the exact size of the H-space is known ahead of time. </span>
<span class="sd">		N_p: int, optional</span>
<span class="sd">			number of bits to use in the prefix label used to generate blocks for searching positions of representatives.</span>

<span class="sd">		Returns</span>
<span class="sd">		--------</span>
<span class="sd">		int</span>
<span class="sd">			Total number of states in the (symmetry-reduced) Hilbert space.</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		The memory stored in the basis grows exponentially as exactly :math:`2^{N_p+1}`. The default behavior is to use `N_p` such that </span>
<span class="sd">		the size of the stored information for the representative bounds is approximately as large as the basis. This is not as effective</span>
<span class="sd">		for basis which small particle numbers as the blocks have very uneven sizes. To not use the blocks just set N_p=0. </span>

<span class="sd">		Examples</span>
<span class="sd">		--------</span>
<span class="sd">		</span>
<span class="sd">		&gt;&gt;&gt; N, Nup = 8, 4</span>
<span class="sd">		&gt;&gt;&gt; basis=spin_basis_general(N,Nup=Nup,make_basis=False)</span>
<span class="sd">		&gt;&gt;&gt; print(basis)</span>
<span class="sd">		&gt;&gt;&gt; basis.make()</span>
<span class="sd">		&gt;&gt;&gt; print(basis)</span>

<span class="sd">		&quot;&quot;&quot;</span>
		
		<span class="k">if</span> <span class="n">Ns_block_est</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">Ns_block_est</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ns_block_est</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">Ns_block_est</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ns_block_est</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">Ns</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns_block_est</span><span class="p">])</span>

		<span class="c1"># preallocate variables</span>
		<span class="n">basis</span> <span class="o">=</span> <span class="n">basis_zeros</span><span class="p">(</span><span class="n">Ns</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_dtype</span><span class="p">)</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Ns</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dtype</span><span class="p">)</span>

		<span class="c1"># make basis</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count_particles</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Np</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
			<span class="n">Np_list</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
			<span class="n">Ns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">make_basis</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">Np</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_Np</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="n">Np_list</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">Np_list</span> <span class="o">=</span> <span class="kc">None</span>
			<span class="n">Ns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">make_basis</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">Np</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_Np</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">Ns</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;estimate for size of reduced Hilbert-space is too low, please double check that transformation mappings are correct or use &#39;Ns_block_est&#39; argument to give an upper bound of the block size.&quot;</span><span class="p">)</span>

		<span class="c1"># sort basis</span>
		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Np</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Np</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">Ns</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_basis</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[:</span><span class="n">Ns</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">=</span> <span class="n">n</span><span class="p">[:</span><span class="n">Ns</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="k">if</span> <span class="n">Np_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Np_list</span> <span class="o">=</span> <span class="n">Np_list</span><span class="p">[:</span><span class="n">Ns</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_basis</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">basis</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">Np_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Np_list</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">Np_list</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

			<span class="n">sort_basis</span> <span class="o">=</span> <span class="kc">False</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">sort_basis</span> <span class="o">=</span> <span class="kc">True</span>

		<span class="k">if</span> <span class="n">Ns</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="c1"># self._basis = basis[Ns-1::-1].copy()</span>
			<span class="c1"># self._n = n[Ns-1::-1].copy()</span>
			<span class="c1"># if Np_list is not None: self._Np_list = Np_list[Ns-1::-1].copy()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_basis</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[:</span><span class="n">Ns</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">=</span> <span class="n">n</span><span class="p">[:</span><span class="n">Ns</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">Np_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Np_list</span> <span class="o">=</span> <span class="n">Np_list</span><span class="p">[:</span><span class="n">Ns</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_basis</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">basis</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">Np_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Np_list</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">Np_list</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="o">=</span><span class="n">Ns</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_Ns_block_est</span><span class="o">=</span><span class="n">Ns</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_index_type</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">),</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_reduce_n_dtype</span><span class="p">()</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_made_basis</span> <span class="o">=</span> <span class="kc">True</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">make_basis_blocks</span><span class="p">(</span><span class="n">N_p</span><span class="o">=</span><span class="n">N_p</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">make_basis_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">N_p</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Creates/modifies the bounds for representatives based on prefix tages.</span>

<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		N_p: int, optional</span>
<span class="sd">			number of bits to use in the prefix label used to generate blocks for searching positions of representatives.</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		The memory stored in the basis grows exponentially as exactly :math:`2^{N_p+1}`. The default behavior is to use `N_p` such that </span>
<span class="sd">		the size of the stored information for the representative bounds is approximately as large as the basis. This is not as effective</span>
<span class="sd">		for basis which small particle numbers as the blocks have very uneven sizes. To not use the blocks just set N_p=0. </span>

<span class="sd">		Examples</span>
<span class="sd">		--------</span>
<span class="sd">		</span>
<span class="sd">		&gt;&gt;&gt; N, Nup = 8, 4</span>
<span class="sd">		&gt;&gt;&gt; basis=spin_basis_general(N,Nup=Nup,make_basis=False)</span>
<span class="sd">		&gt;&gt;&gt; print(basis)</span>
<span class="sd">		&gt;&gt;&gt; basis.make()</span>
<span class="sd">		&gt;&gt;&gt; print(basis)</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_made_basis</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;reference states are not constructed yet. basis must be constructed before calculating blocks&quot;</span><span class="p">)</span>

		<span class="n">sps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sps</span>
		<span class="k">if</span> <span class="n">sps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">sps</span> <span class="o">=</span> <span class="mi">2</span>

		<span class="k">if</span> <span class="n">N_p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">N_p</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">sps</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">N_p</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">N_p</span><span class="p">)</span>


		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">N_p</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># do not use blocks for full basis</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_N_p</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">N_p</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_basis_begin</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">make_basis_blocks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N_p</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_basis_begin</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_basis_end</span>   <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">Op_bra_ket</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">ket_states</span><span class="p">,</span><span class="n">reduce_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Finds bra states which connect given ket states by operator from a site-coupling list and an operator string.</span>

<span class="sd">		Given a set of ket states :math:`|s\\rangle`, the function returns the bra states :math:`\\langle s&#39;|` which connect to them through an operator, together with the corresponding matrix elements.</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">			* Similar to `Op` but instead of returning the matrix indices (row,col), it returns the states (bra,ket) in integer representation. </span>
<span class="sd">			* Does NOT require the full basis (see `basis` optional argument `make_basis`). </span>
<span class="sd">			* If a state from `ket_states` does not have a non-zero matrix element, it is removed from the returned list. See otional argument `reduce_output`.</span>

<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		opstr : str</span>
<span class="sd">			Operator string in the lattice basis format. For instance:</span>

<span class="sd">			&gt;&gt;&gt; opstr = &quot;zz&quot;</span>
<span class="sd">		indx : list(int)</span>
<span class="sd">			List of integers to designate the sites the lattice basis operator is defined on. For instance:</span>
<span class="sd">			</span>
<span class="sd">			&gt;&gt;&gt; indx = [2,3]</span>
<span class="sd">		J : scalar</span>
<span class="sd">			Coupling strength.</span>
<span class="sd">		dtype : &#39;type&#39;</span>
<span class="sd">			Data type (e.g. numpy.float64) to construct the matrix elements with.</span>
<span class="sd">		ket_states : numpy.ndarray(int)</span>
<span class="sd">			Ket states in integer representation. Must be of same data type as `basis`.</span>
<span class="sd">		reduce_output: bool, optional</span>
<span class="sd">			If set to `False`, the returned arrays have the same size as `ket_states`; If set to `True` zeros are purged.</span>

<span class="sd">		Returns</span>
<span class="sd">		--------</span>
<span class="sd">		tuple </span>
<span class="sd">			`(ME,bra,ket)`, where</span>
<span class="sd">				* numpy.ndarray(scalar): `ME`: matrix elements of type `dtype`, which connects the ket and bra states.</span>
<span class="sd">				* numpy.ndarray(int): `bra`: bra states, obtained by applying the matrix representing the operator in the lattice basis,</span>
<span class="sd">					to the ket states, such that `bra[i]` corresponds to `ME[i]` and connects to `ket[i]`.</span>
<span class="sd">				* numpy.ndarray(int): `ket`: ket states, such that `ket[i]` corresponds to `ME[i]` and connects to `bra[i]`.</span>

<span class="sd">			</span>
<span class="sd">		Examples</span>
<span class="sd">		--------</span>

<span class="sd">		&gt;&gt;&gt; J = 1.41</span>
<span class="sd">		&gt;&gt;&gt; indx = [2,3]</span>
<span class="sd">		&gt;&gt;&gt; opstr = &quot;zz&quot;</span>
<span class="sd">		&gt;&gt;&gt; dtype = np.float64</span>
<span class="sd">		&gt;&gt;&gt; ME, bra, ket = Op_bra_ket(opstr,indx,J,dtype,ket_states)</span>

<span class="sd">		&quot;&quot;&quot;</span>

		
		<span class="n">indx</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
		<span class="n">ket_states</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ket_states</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">opstr</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indx</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;length of opstr does not match length of indx&#39;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;values in indx falls outside of system&#39;</span><span class="p">)</span>

		<span class="n">extra_ops</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">opstr</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allowed_ops</span>
		<span class="k">if</span> <span class="n">extra_ops</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unrecognized characters </span><span class="si">{}</span><span class="s2"> in operator string.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">extra_ops</span><span class="p">))</span>

	
		<span class="n">bra</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ket_states</span><span class="p">)</span> <span class="c1"># row</span>
		<span class="n">ME</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ket_states</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">op_bra_ket</span><span class="p">(</span><span class="n">ket_states</span><span class="p">,</span><span class="n">bra</span><span class="p">,</span><span class="n">ME</span><span class="p">,</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_Np</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">reduce_output</span><span class="p">:</span> 
			<span class="c1"># remove nan&#39;s matrix elements</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ME</span><span class="p">),</span><span class="n">_np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ME</span><span class="p">)</span><span class="o">==</span><span class="mf">0.0</span><span class="p">))</span>
			<span class="n">bra</span> <span class="o">=</span> <span class="n">bra</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
			<span class="n">ket_states</span> <span class="o">=</span> <span class="n">ket_states</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
			<span class="n">ME</span> <span class="o">=</span> <span class="n">ME</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ME</span><span class="p">)</span>
			<span class="n">ME</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

		<span class="k">return</span> <span class="n">ME</span><span class="p">,</span><span class="n">bra</span><span class="p">,</span><span class="n">ket_states</span>

	<span class="k">def</span> <span class="nf">representative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">states</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">return_g</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">return_sign</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Maps states to their representatives under the `basis` symmetries.</span>

<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		states : array_like(int)</span>
<span class="sd">			Fock-basis (z-basis) states to find the representatives of. States are stored in integer representations.</span>
<span class="sd">		out : numpy.ndarray(int), optional</span>
<span class="sd">			variable to store the representative states in. Must be a `numpy.ndarray` of same datatype as `basis`, and same shape as `states`. </span>
<span class="sd">		return_g : bool, optional</span>
<span class="sd">			if set to `True`, the function also returns the integer `g` corresponding to the number of times each basis symmetry needs to be applied to a given state to obtain its representative.</span>
<span class="sd">		return_sign : bool, optional</span>
<span class="sd">			if set to `True`, the function returns the `sign` of the representative relative to the original state (nontrivial only for fermionic bases).</span>

<span class="sd">		Returns</span>
<span class="sd">		--------</span>
<span class="sd">		tuple</span>
<span class="sd">			( representatives, g_array, sign_array )</span>
<span class="sd">			* array_like(int): `representatives`: Representatives under `basis` symmetries, corresponding to `states`.</span>
<span class="sd">			* array_like(int): `g_array` of size (number of states, number of symmetries). Requires `return_g=True`. Contains integers corresponding to the number of times each basis symmetry needs to be applied to a given state to obtain its representative.</span>
<span class="sd">			* array_like(int): `sign_array` of size (number of states,). Requires `return_sign=True`. Contains `sign` of the representative relative to the original state (nontrivial only for fermionic bases).</span>

<span class="sd">		Examples</span>
<span class="sd">		--------</span>
<span class="sd">		</span>
<span class="sd">		&gt;&gt;&gt; basis=spin_basis_general(N,Nup=Nup,make_basis=False)</span>
<span class="sd">		&gt;&gt;&gt; s = 17</span>
<span class="sd">		&gt;&gt;&gt; r = basis.representative(s)</span>
<span class="sd">		&gt;&gt;&gt; print(s,r)</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">states</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
		<span class="n">states</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>


		<span class="k">if</span> <span class="n">states</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;dimension of array_like states must not exceed 1.&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">return_g</span><span class="p">:</span>
			<span class="n">g_out</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">states</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_qs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">return_sign</span><span class="p">:</span>
			<span class="n">sign_out</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">states</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">out</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">states</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>

			<span class="k">if</span> <span class="n">return_g</span> <span class="ow">and</span> <span class="n">return_sign</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">representative</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">out</span><span class="p">,</span><span class="n">g_out</span><span class="o">=</span><span class="n">g_out</span><span class="p">,</span><span class="n">sign_out</span><span class="o">=</span><span class="n">sign_out</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">g_out</span><span class="p">,</span> <span class="n">sign_out</span>
			<span class="k">elif</span> <span class="n">return_g</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">representative</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">out</span><span class="p">,</span><span class="n">g_out</span><span class="o">=</span><span class="n">g_out</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">g_out</span>
			<span class="k">elif</span> <span class="n">return_sign</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">representative</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">out</span><span class="p">,</span><span class="n">sign_out</span><span class="o">=</span><span class="n">sign_out</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">sign_out</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">representative</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">out</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">out</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;out must be a numpy.ndarray&#39;</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">states</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;states and out must have same shape.&#39;</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;out must have same type as basis&#39;</span><span class="p">)</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">out</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;CARRAY&quot;</span><span class="p">]:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;out must be C-contiguous array.&quot;</span><span class="p">)</span>
			
			<span class="k">if</span> <span class="n">return_g</span> <span class="ow">and</span> <span class="n">return_sign</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">representative</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">out</span><span class="p">,</span><span class="n">g_out</span><span class="o">=</span><span class="n">g_out</span><span class="p">,</span><span class="n">sign_out</span><span class="o">=</span><span class="n">sign_out</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">g_out</span><span class="p">,</span><span class="n">sign_out</span>
			<span class="k">elif</span> <span class="n">return_g</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">representative</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">out</span><span class="p">,</span><span class="n">g_out</span><span class="o">=</span><span class="n">g_out</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">g_out</span>
			<span class="k">elif</span> <span class="n">return_sign</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">representative</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">out</span><span class="p">,</span><span class="n">sign_out</span><span class="o">=</span><span class="n">sign_out</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">sign_out</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">representative</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">out</span><span class="p">)</span>
				
	<span class="k">def</span> <span class="nf">normalization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">states</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Computes normalization of `basis` states. </span>

<span class="sd">		Notes</span>
<span class="sd">		------</span>
<span class="sd">			* Returns zero, if the state is not part of the symmetry-reduced basis.</span>
<span class="sd">			* The normalizations can be used to compute matrix elements in the symmetry-reduced basis. </span>

<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		states : array_like(int)</span>
<span class="sd">			Fock-basis (z-basis) states to find the normalizations of. States are stored in integer representations.</span>
<span class="sd">		out : numpy.ndarray(unsigned int), optional</span>
<span class="sd">			variable to store the normalizations of the states in. Must be a `numpy.ndarray` of datatype `unsigned int` (e.g. `numpy.uint16`), and same shape as `states`. </span>
<span class="sd">	</span>
<span class="sd">		Returns</span>
<span class="sd">		--------</span>
<span class="sd">		array_like(int)</span>
<span class="sd">			normalizations of `states` for the given (symmetry-reduced) `basis`.</span>
<span class="sd">		</span>
<span class="sd">		Examples</span>
<span class="sd">		--------</span>
<span class="sd">		</span>
<span class="sd">		&gt;&gt;&gt; basis=spin_basis_general(N,Nup=Nup,make_basis=False)</span>
<span class="sd">		&gt;&gt;&gt; s = 17</span>
<span class="sd">		&gt;&gt;&gt; norm_s = basis.normalization(s)</span>
<span class="sd">		&gt;&gt;&gt; print(s,norm_s)</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">states</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
		<span class="n">states</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>


		<span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="c1"># determine appropriate dtype</span>
			<span class="n">out_dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_pers</span><span class="o">.</span><span class="n">prod</span><span class="p">())</span>
			<span class="n">out</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">states</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">out_dtype</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">normalization</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">out</span><span class="p">)</span>
			
			<span class="c1"># reduce dtype</span>
			<span class="n">out_dtype</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
			<span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">)</span>

			<span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">states</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;states and out must have same shape.&#39;</span><span class="p">)</span>

			<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">signedinteger</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;out must have datatype numpy.uint8, numpy.uint16, numpy.uint32, or numpy.uint64.&#39;</span><span class="p">)</span>
		
			<span class="k">if</span> <span class="ow">not</span> <span class="n">out</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;CARRAY&quot;</span><span class="p">]:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;out must be C-contiguous array.&quot;</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">normalization</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">out</span><span class="p">)</span>

			<span class="n">out_dtype</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
			<span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">)</span>
		
	<span class="k">def</span> <span class="nf">get_amp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">states</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">amps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;representative&#39;</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Computes the rescale factor of state amplitudes between the symmetry-reduced and full basis.</span>

<span class="sd">		Given a quantum state :math:`s` and a state amplitude in the full basis :math:`\\psi_s`, its representative (under the symemtries) </span>
<span class="sd">		:math:`r(s)` with a corresponding amplitude :math:`\\psi^\\text{sym}_r`, the function computes the ratio :math:`C`, defined as</span>
<span class="sd">		</span>
<span class="sd">		.. math::</span>
<span class="sd">			\\psi_s = C\\psi_r^\\text{sym} </span>


<span class="sd">		Notes</span>
<span class="sd">		------</span>
<span class="sd">			* Particularly useful when a given operation cannot be carried away in the symmetry-reduced basis in a straightforward manner.</span>
<span class="sd">			* To transform an entire state from a symmetry-reduced basis to the full (symmetry-free) basis, use the `basis.get_vec()` function.</span>
<span class="sd">			* Returns zero, if the state passed to the function is not part of the symmetry-reduced basis.</span>
<span class="sd">			* If `amps` is passed, the user has to make sure that the input data in `amps` correspond to the `states`.</span>
<span class="sd">			* The function assumes that `states` comply with the particle conservation symmetry the `basis` was constructed with.</span>

<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		states : array_like(int)</span>
<span class="sd">			Fock-basis (z-basis) states to find the amplitude rescale factor :math:`C` of. States are stored in integer representations. </span>
<span class="sd">		out : numpy.ndarray(float), optional</span>
<span class="sd">			variable to store the rescale factors :math:`C` of the states in. Must be a real or complex-valued `numpy.ndarray` of the same shape as `states`. </span>
<span class="sd">		amps : numpy.ndarray(float), optional</span>
<span class="sd">			array of amplitudes to rescale by the amplitude factor :math:`C` (see `mode`). Updated in-place. Must be a real or complex-valued `numpy.ndarray` of the same shape as `states`. </span>
<span class="sd">		mode : string, optional</span>
<span class="sd">			* if `mode=&#39;representative&#39;` (default), then the function assumes that</span>
<span class="sd">				(i) `states` already contains representatives (i.e. states in the symmetry-reduced basis);</span>
<span class="sd">				(ii) `amps` (if passed) are amplitudes in the symmetry-reduced basis (:math:`\\psi_r^\\text{symm}`). The function will update `amps` in-place to :math:`\\psi_s`.</span>
<span class="sd">			* if `mode=&#39;full_basis&#39;`, then the function assumes that</span>
<span class="sd">				(i) `states` contains full-basis states (the funciton will compute the corresponding representatives);</span>
<span class="sd">				(ii) `amps` (if passed) are amplitudes in the full basis (:math:`\\psi_s`). The function will update `amps` in-place to :math:`\\psi_r^\\text{symm}`;</span>
<span class="sd">					**Note**: the function will also update the variable `states` in place with the corresponding representatives.</span>

<span class="sd">		Returns</span>
<span class="sd">		--------</span>
<span class="sd">		array_like(float)</span>
<span class="sd">			amplitude rescale factor :math:`C` (see expression above).</span>
<span class="sd">		</span>
<span class="sd">		Examples</span>
<span class="sd">		--------</span>
<span class="sd">		</span>
<span class="sd">		&gt;&gt;&gt; C = get_amp(states,out=None,amps=None,mode=&#39;representative&#39;)</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">states</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
		<span class="n">states</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>

		<span class="n">states_shape</span><span class="o">=</span><span class="n">states</span><span class="o">.</span><span class="n">shape</span>

			
		<span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">states_shape</span><span class="o">!=</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;states and out must have same shape.&#39;</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">complex128</span><span class="p">]:</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;out must have datatype numpy.float32, numpy.float64, numpy.complex64, or numpy.complex128.&#39;</span><span class="p">)</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">out</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;CARRAY&quot;</span><span class="p">]:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;out must be C-contiguous array.&quot;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">amps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">out</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">states_shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">amps</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">out</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">states_shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>


		<span class="bp">self</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">get_amp</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">out</span><span class="p">,</span><span class="n">states_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">mode</span><span class="p">)</span>
				

		<span class="k">if</span> <span class="n">amps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">states</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="n">amps</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;states and amps must have same shape.&#39;</span><span class="p">)</span>
			
			<span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;representative&#39;</span><span class="p">:</span>
				<span class="n">amps</span><span class="o">*=</span><span class="n">out</span> <span class="c1"># compute amplitudes in full basis</span>
			<span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;full_basis&#39;</span><span class="p">:</span>
				<span class="n">amps</span><span class="o">/=</span><span class="n">out</span> <span class="c1"># compute amplitudes in symmetery-rduced basis</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mode accepts only the values &#39;representative&#39; and &#39;full_basis&#39;.&quot;</span><span class="p">)</span>


		<span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>




<span class="k">def</span> <span class="nf">_check_symm_map</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span><span class="n">sort_opstr</span><span class="p">,</span><span class="n">operator_list</span><span class="p">):</span>
	<span class="n">missing_ops</span><span class="o">=</span><span class="p">[]</span>
	<span class="n">odd_ops</span><span class="o">=</span><span class="p">[]</span>
	<span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operator_list</span><span class="p">:</span>
		<span class="n">opstr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">indx</span>  <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">J</span>     <span class="o">=</span> <span class="n">op</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
		<span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
			<span class="n">i</span> <span class="o">=</span> <span class="nb">map</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">opstr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span>
					<span class="n">odd_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

				<span class="n">J</span> <span class="o">*=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">opstr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">,</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">opstr</span> <span class="o">=</span> <span class="n">opstr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span><span class="s2">&quot;#&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span><span class="s2">&quot;+&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">,</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
				<span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

			<span class="n">indx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

		<span class="n">new_op</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
		<span class="n">new_op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">opstr</span>
		<span class="n">new_op</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">indx</span>
		<span class="n">new_op</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">J</span>

		<span class="n">new_op</span> <span class="o">=</span> <span class="n">sort_opstr</span><span class="p">(</span><span class="n">new_op</span><span class="p">)</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">new_op</span> <span class="ow">in</span> <span class="n">operator_list</span><span class="p">):</span>
			<span class="n">missing_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_op</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">odd_ops</span><span class="p">,</span><span class="n">missing_ops</span>







</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">QuSpin 0.3.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Phillip Weinberg, Markus Schmitt and Marin Bukov.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.4.
    </div>
  </body>
</html>