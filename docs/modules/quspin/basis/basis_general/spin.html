
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" /><script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-110543543-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <title>quspin.basis.basis_general.spin &#8212; QuSpin 0.3.7 documentation</title>
    <link rel="stylesheet" href="../../../../static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../../static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../../../" src="../../../../static/documentation_options.js"></script>
    <script src="../../../../static/jquery.js"></script>
    <script src="../../../../static/underscore.js"></script>
    <script src="../../../../static/doctools.js"></script>
    <script src="../../../../static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">QuSpin 0.3.7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for quspin.basis.basis_general.spin</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">.base_hcb</span> <span class="kn">import</span> <span class="n">hcb_basis_general</span>
<span class="kn">from</span> <span class="nn">.base_higher_spin</span> <span class="kn">import</span> <span class="n">higher_spin_basis_general</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">_np</span>

<span class="k">try</span><span class="p">:</span>
	<span class="n">S_dict</span> <span class="o">=</span> <span class="p">{(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;/2&quot;</span> <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">1</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">//</span><span class="mi">2</span><span class="p">)):(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10001</span><span class="p">)}</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
	<span class="n">S_dict</span> <span class="o">=</span> <span class="p">{(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;/2&quot;</span> <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">1</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">//</span><span class="mi">2</span><span class="p">)):(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10001</span><span class="p">)}</span>


<div class="viewcode-block" id="spin_basis_general"><a class="viewcode-back" href="../../../../generated/quspin.basis.spin_basis_general.html#quspin.basis.spin_basis_general">[docs]</a><span class="k">class</span> <span class="nc">spin_basis_general</span><span class="p">(</span><span class="n">hcb_basis_general</span><span class="p">,</span><span class="n">higher_spin_basis_general</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Constructs basis for spin operators for USER-DEFINED symmetries.</span>

<span class="sd">	Any unitary symmetry transformation :math:`Q` of periodicity :math:`m_Q` (:math:`Q^{m_Q}=1`) has eigenvalues :math:`\\exp(-2\\pi i q/m_Q)`, labelled by an ingeter :math:`q\\in\\{0,1,\\dots,m_Q-1\\}`. These integers :math:`q` are used to define the symmetry blocks.</span>

<span class="sd">	For instance, if :math:`Q=P` is parity (reflection), then :math:`q=0,1`. If :math:`Q=T` is translation by one lattice site, then :math:`q` labels the mometum blocks in the same fashion as for the `..._basis_1d` classes. </span>

<span class="sd">	User-defined symmetries with the `spin_basis_general` class can be programmed as follows. Suppose we have a system of L sites, enumerated :math:`s=(s_0,s_1,\\dots,s_{L-1})`. There are two types of operations one can perform on the sites:</span>
<span class="sd">		* exchange the labels of two sites: :math:`s_i \\leftrightarrow s_j` (e.g., translation, parity)</span>
<span class="sd">		* invert the population on a given site: :math:`s_i\\leftrightarrow -(s_j+1)` (e.g., spin inversion)</span>

<span class="sd">	These two operations already comprise a variety of symmetries, including translation, parity (reflection) and spin inversion. For a specific example, see below.</span>

<span class="sd">	The supported operator strings for `spin_basis_general` are:</span>

<span class="sd">	.. math::</span>
<span class="sd">		\\begin{array}{cccc}</span>
<span class="sd">			\\texttt{basis}/\\texttt{opstr}   &amp;   \\texttt{&quot;I&quot;}   &amp;   \\texttt{&quot;+&quot;}   &amp;   \\texttt{&quot;-&quot;}  &amp;     \\texttt{&quot;z&quot;}   &amp;   \\texttt{&quot;x&quot;}   &amp;   \\texttt{&quot;y&quot;}  \\newline	</span>
<span class="sd">			\\texttt{spin_basis_general} &amp;   \\hat{1}        &amp;   \\hat\\sigma^+       &amp;   \\hat\\sigma^-      &amp;     \\hat\\sigma^z       &amp;   (\\hat\\sigma^x)     &amp;   (\\hat\\sigma^y)  \\  \\newline</span>
<span class="sd">		\\end{array}</span>

<span class="sd">	**Notes:** </span>
<span class="sd">		* The relation between spin and Pauli matrices is :math:`\\vec S = \\vec \\sigma/2`.</span>
<span class="sd">		* The default operators for spin-1/2 are the Pauli matrices, NOT the spin operators. To change this, see the argument `pauli` of the `spin_basis` class. Higher spins can only be defined using the spin operators, and do NOT support the operator strings &quot;x&quot; and &quot;y&quot;. </span>
<span class="sd">		* QuSpin raises a warning to alert the reader when non-commuting symmetries are passed. In such cases, we recommend the user to manually check the combined usage of symmetries by, e.g., comparing the eigenvalues.</span>

<span class="sd"> 		</span>
<span class="sd">	Examples</span>
<span class="sd">	--------</span>

<span class="sd">	The code snippet below shows how to construct the two-dimensional transverse-field Ising model.</span>
<span class="sd">	</span>
<span class="sd">	.. math::</span>
<span class="sd">		H = J \\sum_{\\langle ij\\rangle} \\sigma^z_{i}\\sigma^z_j+ g\\sum_j\\sigma^x_j </span>

<span class="sd">	Moreover, it demonstrates how to pass user-defined symmetries to the `spin_basis_general` constructor. In particular,</span>
<span class="sd">	we do translation invariance and parity (reflection) (along each lattice direction), and spin inversion. Note that parity </span>
<span class="sd">	(reflection) and translation invariance are non-commuting symmetries, and QuSpin raises a warning when constructing the basis. </span>
<span class="sd">	However, they do commute in the zero-momentum (also in the pi-momentum) symmetry sector; hence, one can ignore the warning and</span>
<span class="sd">	use the two symemtries together to reduce the Hilbert space dimension.</span>


<span class="sd">	.. literalinclude:: ../../doc_examples/spin_basis_general-example.py</span>
<span class="sd">		:linenos:</span>
<span class="sd">		:language: python</span>
<span class="sd">		:lines: 7-</span>

<span class="sd">	&quot;&quot;&quot;</span>
<div class="viewcode-block" id="spin_basis_general.__init__"><a class="viewcode-back" href="../../../../generated/quspin.basis.spin_basis_general.html#quspin.basis.spin_basis_general.__init__">[docs]</a>	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">Nup</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">S</span><span class="o">=</span><span class="s2">&quot;1/2&quot;</span><span class="p">,</span><span class="n">pauli</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">Ns_block_est</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">make_basis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">block_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">blocks</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Intializes the `spin_basis_general` object (basis for spin operators).</span>

<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		N: int</span>
<span class="sd">			number of sites.</span>
<span class="sd">		Nup: {int,list}, optional</span>
<span class="sd">			Total magnetisation, :math:`Nup = NS + \\sum_j S^z_j, Nup\\ge 0`, and :math:`Nup = -NS + \\sum_j S^z_j, Nup&lt;0` projection. Can be integer or list to specify one or </span>
<span class="sd">			more particle sectors. Negative values are taken to be subtracted from the fully polarized up state as: Nup_max + Nup + 1.</span>
<span class="sd">			e.g. to get the Nup_max state use Nup = -1, for Nup_max-1 state use Nup = -2, etc.</span>
<span class="sd">		m: float, optional</span>
<span class="sd">			Density of spin up in chain (spin up per site).</span>
<span class="sd">		S: str, optional</span>
<span class="sd">			Size of local spin degrees of freedom. Can be any (half-)integer from:</span>
<span class="sd">			&quot;1/2&quot;,&quot;1&quot;,&quot;3/2&quot;,...,&quot;9999/2&quot;,&quot;5000&quot;.</span>
<span class="sd">		pauli: int, optional (requires `S=&quot;1/2&quot;`)</span>
<span class="sd">			* for `pauli=0` the code uses spin-1/2 operators: </span>
<span class="sd">	</span>
<span class="sd">			.. math::</span>

<span class="sd">				S^x = \\frac{1}{2}\\begin{pmatrix}0 &amp; 1\\\\ 1 &amp; 0\\end{pmatrix},\\quad S^y = \\frac{1}{2}\\begin{pmatrix}0 &amp; -i\\\\ i &amp; 0\\end{pmatrix},\\quad S^z = \\frac{1}{2}\\begin{pmatrix}1 &amp; 0\\\\ 0 &amp; -1\\end{pmatrix},\\quad S^+ = \\begin{pmatrix}0 &amp; 1\\\\ 0 &amp; 0\\end{pmatrix},\\quad S^- = \\begin{pmatrix}0 &amp; 0\\\\ 1 &amp; 0\\end{pmatrix}</span>

<span class="sd">			* for `pauli=1` the code uses Pauli matrices with:</span>

<span class="sd">			.. math::</span>

<span class="sd">				\\sigma^x = \\begin{pmatrix}0 &amp; 1\\\\ 1 &amp; 0\\end{pmatrix},\\quad \\sigma^y = \\begin{pmatrix}0 &amp; -i\\\\ i &amp; 0\\end{pmatrix},\\quad \\sigma^z = \\begin{pmatrix}1 &amp; 0\\\\ 0 &amp; -1\\end{pmatrix},\\quad \\sigma^+ = \\begin{pmatrix}0 &amp; 2\\\\ 0 &amp; 0\\end{pmatrix},\\quad \\sigma^- = \\begin{pmatrix}0 &amp; 0\\\\ 2 &amp; 0\\end{pmatrix}</span>


<span class="sd">			* for `pauli=-1` the code uses Pauli matrices with:</span>

<span class="sd">			.. math::</span>

<span class="sd">				\\sigma^x = \\begin{pmatrix}0 &amp; 1\\\\ 1 &amp; 0\\end{pmatrix},\\quad \\sigma^y = \\begin{pmatrix}0 &amp; -i\\\\ i &amp; 0\\end{pmatrix},\\quad \\sigma^z = \\begin{pmatrix}1 &amp; 0\\\\ 0 &amp; -1\\end{pmatrix},\\quad \\sigma^+ = \\begin{pmatrix}0 &amp; 1\\\\ 0 &amp; 0\\end{pmatrix},\\quad \\sigma^- = \\begin{pmatrix}0 &amp; 0\\\\ 1 &amp; 0\\end{pmatrix}</span>
<span class="sd">	</span>
<span class="sd">		Ns_block_est: int, optional</span>
<span class="sd">			Overwrites the internal estimate of the size of the reduced Hilbert space for the given symmetries. This can be used to help conserve memory if the exact size of the H-space is known ahead of time. </span>
<span class="sd">		make_basis: bool, optional</span>
<span class="sd">			Boolean to control whether to make the basis. Allows the use to use some functionality of the basis constructor without constructing the entire basis.</span>
<span class="sd">		block_order: list of strings, optional</span>
<span class="sd">			A list of strings containing the names of the symmetry blocks which specifies the order in which the symmetries will be applied to the state when calculating the basis. The first element in the list is applied to the state first followed by the second element, etc. If the list is not specificed the ordering is such that the symmetry with the largest cycle is the first, followed by the second largest, etc. </span>
<span class="sd">		**blocks: optional</span>
<span class="sd">			keyword arguments which pass the symmetry generator arrays. For instance:</span>

<span class="sd">			&gt;&gt;&gt; basis(...,kxblock=(Q,q),...)</span>

<span class="sd">			The keys of the symmetry sector, e.g. `kxblock`, can be chosen arbitrarily by the user. The</span>
<span class="sd">			values are tuples where the first entry contains the symmetry transformation :math:`Q` acting on the</span>
<span class="sd">			lattice sites (see class example), and the second entry is an integer :math:`q` to label the symmetry</span>
<span class="sd">			sector.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_S</span> <span class="o">=</span> <span class="n">S</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_pauli</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pauli</span><span class="p">)</span>
		<span class="n">sps</span><span class="p">,</span><span class="n">S</span> <span class="o">=</span> <span class="n">S_dict</span><span class="p">[</span><span class="n">S</span><span class="p">]</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pauli</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid value for optional argument pauli. Allowed values are the integers [-1,0,1].&quot;</span><span class="p">)</span>

		<span class="n">_Np</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_Np&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">_Np</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">blocks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_Np&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">Nup</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use Nup and m at the same time&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Nup</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">S</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">S</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m must be between -S and S&quot;</span><span class="p">)</span>

			<span class="n">Nup</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">m</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>

		<span class="k">try</span><span class="p">:</span>
			<span class="n">Nup_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">Nup</span><span class="p">)</span>
			<span class="n">M</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>
			<span class="n">Nup</span> <span class="o">=</span> <span class="p">[(</span><span class="n">M</span><span class="o">+</span><span class="p">(</span><span class="n">Nup</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">Nup</span><span class="o">&lt;</span><span class="mi">0</span> <span class="k">else</span> <span class="n">Nup</span><span class="p">)</span> <span class="k">for</span> <span class="n">Nup</span> <span class="ow">in</span> <span class="n">Nup_iter</span><span class="p">]</span>
		<span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">Nup</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Nup</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">Nup</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="n">Nup</span> <span class="o">+</span> <span class="mi">1</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_pcon_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span><span class="n">Nup</span><span class="o">=</span><span class="n">Nup</span><span class="p">,</span><span class="n">S</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">_Np</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_pcon_args</span><span class="p">[</span><span class="s2">&quot;_Np&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_Np</span>

		<span class="k">if</span> <span class="n">sps</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
			<span class="n">hcb_basis_general</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">Nb</span><span class="o">=</span><span class="n">Nup</span><span class="p">,</span><span class="n">Ns_block_est</span><span class="o">=</span><span class="n">Ns_block_est</span><span class="p">,</span>
				<span class="n">_Np</span><span class="o">=</span><span class="n">_Np</span><span class="p">,</span><span class="n">_make_basis</span><span class="o">=</span><span class="n">make_basis</span><span class="p">,</span><span class="n">block_order</span><span class="o">=</span><span class="n">block_order</span><span class="p">,</span><span class="o">**</span><span class="n">blocks</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">higher_spin_basis_general</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">Nup</span><span class="o">=</span><span class="n">Nup</span><span class="p">,</span><span class="n">sps</span><span class="o">=</span><span class="n">sps</span><span class="p">,</span><span class="n">Ns_block_est</span><span class="o">=</span><span class="n">Ns_block_est</span><span class="p">,</span>
				<span class="n">_Np</span><span class="o">=</span><span class="n">_Np</span><span class="p">,</span><span class="n">_make_basis</span><span class="o">=</span><span class="n">make_basis</span><span class="p">,</span><span class="n">block_order</span><span class="o">=</span><span class="n">block_order</span><span class="p">,</span><span class="o">**</span><span class="n">blocks</span><span class="p">)</span>


		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sps</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_operators</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;availible operators for spin_basis_1d:&quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">I: identity &quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">+: raising operator&quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">-: lowering operator&quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">x: x pauli/spin operator&quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">y: y pauli/spin operator&quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">z: z pauli/spin operator&quot;</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_allowed_ops</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;I&quot;</span><span class="p">,</span><span class="s2">&quot;+&quot;</span><span class="p">,</span><span class="s2">&quot;-&quot;</span><span class="p">,</span><span class="s2">&quot;x&quot;</span><span class="p">,</span><span class="s2">&quot;y&quot;</span><span class="p">,</span><span class="s2">&quot;z&quot;</span><span class="p">])</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_operators</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;availible operators for spin_basis_1d:&quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">I: identity &quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">+: raising operator&quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">-: lowering operator&quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">z: z pauli/spin operator&quot;</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_allowed_ops</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;I&quot;</span><span class="p">,</span><span class="s2">&quot;+&quot;</span><span class="p">,</span><span class="s2">&quot;-&quot;</span><span class="p">,</span><span class="s2">&quot;z&quot;</span><span class="p">])</span></div>


	<span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">state</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;_sps&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
			<span class="n">hcb_basis_general</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">state</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">higher_spin_basis_general</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">state</span><span class="p">)</span>


	<span class="k">def</span> <span class="nf">_Op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="p">):</span>
		
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_S</span> <span class="o">==</span> <span class="s2">&quot;1/2&quot;</span><span class="p">:</span>
			<span class="n">ME</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">hcb_basis_general</span><span class="o">.</span><span class="n">_Op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="p">)</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pauli</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
				<span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">opstr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;I&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">))</span>
				<span class="n">ME</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n</span><span class="p">)</span>
			<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pauli</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
				<span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">opstr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;I&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">))</span>
				<span class="n">ME</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n</span><span class="p">)</span>

			<span class="k">return</span> <span class="n">ME</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">higher_spin_basis_general</span><span class="o">.</span><span class="n">_Op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="p">)</span>

		
	
	<span class="k">def</span> <span class="nf">_inplace_Op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v_in</span><span class="p">,</span><span class="n">op_list</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">transposed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">conjugated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">v_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">a</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_S</span> <span class="o">==</span> <span class="s2">&quot;1/2&quot;</span><span class="p">:</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pauli</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
				<span class="n">scale</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;I&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)))</span>
			<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pauli</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
				<span class="n">scale</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;I&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)))</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">scale</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span><span class="mi">1</span>

			<span class="n">op_list</span> <span class="o">=</span> <span class="p">[[</span><span class="n">op</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="o">*</span><span class="n">scale</span><span class="p">(</span><span class="n">op</span><span class="p">)]</span> <span class="k">for</span> <span class="n">op</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span> <span class="ow">in</span> <span class="n">op_list</span><span class="p">]</span>

			<span class="k">return</span> <span class="n">hcb_basis_general</span><span class="o">.</span><span class="n">_inplace_Op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v_in</span><span class="p">,</span><span class="n">op_list</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span>
				<span class="n">transposed</span><span class="o">=</span><span class="n">transposed</span><span class="p">,</span><span class="n">conjugated</span><span class="o">=</span><span class="n">conjugated</span><span class="p">,</span><span class="n">v_out</span><span class="o">=</span><span class="n">v_out</span><span class="p">,</span><span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">higher_spin_basis_general</span><span class="o">.</span><span class="n">_inplace_Op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v_in</span><span class="p">,</span><span class="n">op_list</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span>
				<span class="n">transposed</span><span class="o">=</span><span class="n">transposed</span><span class="p">,</span><span class="n">conjugated</span><span class="o">=</span><span class="n">conjugated</span><span class="p">,</span><span class="n">v_out</span><span class="o">=</span><span class="n">v_out</span><span class="p">,</span><span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>


<div class="viewcode-block" id="spin_basis_general.Op_shift_sector"><a class="viewcode-back" href="../../../../generated/quspin.basis.spin_basis_general.html#quspin.basis.spin_basis_general.Op_shift_sector">[docs]</a>	<span class="k">def</span> <span class="nf">Op_shift_sector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other_basis</span><span class="p">,</span><span class="n">op_list</span><span class="p">,</span><span class="n">v_in</span><span class="p">,</span><span class="n">v_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_S</span> <span class="o">==</span> <span class="s2">&quot;1/2&quot;</span><span class="p">:</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pauli</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
				<span class="n">scale</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;I&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)))</span>
			<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pauli</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
				<span class="n">scale</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;I&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)))</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">scale</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span><span class="mi">1</span>

			<span class="n">op_list</span> <span class="o">=</span> <span class="p">[[</span><span class="n">op</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="o">*</span><span class="n">scale</span><span class="p">(</span><span class="n">op</span><span class="p">)]</span> <span class="k">for</span> <span class="n">op</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span> <span class="ow">in</span> <span class="n">op_list</span><span class="p">]</span>

			<span class="k">return</span> <span class="n">hcb_basis_general</span><span class="o">.</span><span class="n">Op_shift_sector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other_basis</span><span class="p">,</span><span class="n">op_list</span><span class="p">,</span><span class="n">v_in</span><span class="p">,</span><span class="n">v_out</span><span class="o">=</span><span class="n">v_out</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">higher_spin_basis_general</span><span class="o">.</span><span class="n">Op_shift_sector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other_basis</span><span class="p">,</span><span class="n">op_list</span><span class="p">,</span><span class="n">v_in</span><span class="p">,</span><span class="n">v_out</span><span class="o">=</span><span class="n">v_out</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>	</div>

	<span class="n">Op_shift_sector</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">hcb_basis_general</span><span class="o">.</span><span class="n">Op_shift_sector</span><span class="o">.</span><span class="vm">__doc__</span>


	<span class="k">def</span> <span class="nf">__type__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="s2">&quot;&lt;type &#39;qspin.basis.general_hcb&#39;&gt;&quot;</span>

	<span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="s2">&quot;&lt; instance of &#39;qspin.basis.general_hcb&#39; with </span><span class="si">{0}</span><span class="s2"> states &gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__name__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="s2">&quot;&lt;type &#39;qspin.basis.general_hcb&#39;&gt;&quot;</span>

	<span class="c1"># functions called in base class:</span>

	<span class="k">def</span> <span class="nf">_sort_opstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">op</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;|&#39; character found in op: </span><span class="si">{0}</span><span class="s2">,</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;number of operators in opstr: </span><span class="si">{0}</span><span class="s2"> not equal to length of indx </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

		<span class="n">op</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
		<span class="n">zipstr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="k">if</span> <span class="n">zipstr</span><span class="p">:</span>
			<span class="n">zipstr</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
			<span class="n">op1</span><span class="p">,</span><span class="n">op2</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">zipstr</span><span class="p">)</span>
			<span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span>
			<span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">op2</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_non_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">op</span><span class="p">):</span>
		<span class="n">opstr</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="n">indx</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indx</span><span class="p">):</span>
			<span class="n">indx_p</span> <span class="o">=</span> <span class="n">indx</span><span class="p">[</span><span class="n">opstr</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
			<span class="n">p</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">indx_p</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sps</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indx_p</span><span class="p">)</span>
			<span class="n">indx_p</span> <span class="o">=</span> <span class="n">indx</span><span class="p">[</span><span class="n">opstr</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
			<span class="n">m</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">indx_p</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sps</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indx_p</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">p</span> <span class="ow">and</span> <span class="n">m</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="kc">True</span>
		
	<span class="k">def</span> <span class="nf">_hc_opstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">op</span><span class="p">):</span>
		<span class="n">op</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
		<span class="c1"># take h.c. + &lt;--&gt; - , reverse operator order , and conjugate coupling</span>
		<span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span><span class="s2">&quot;%&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span><span class="s2">&quot;+&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;%&quot;</span><span class="p">,</span><span class="s2">&quot;-&quot;</span><span class="p">))</span>
		<span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
		<span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
		<span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">op</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_opstr</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="c1"># return the sorted op.</span>

	<span class="k">def</span> <span class="nf">_expand_opstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">op</span><span class="p">,</span><span class="n">num</span><span class="p">):</span>
		<span class="n">opstr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">indx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">J</span> <span class="o">=</span> <span class="n">op</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
 
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">opstr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">opstr</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
				<span class="n">op1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
				<span class="n">op1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">op1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pauli</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
					<span class="n">op1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">0.5</span>
				<span class="n">op1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

				<span class="n">op2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
				<span class="n">op2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">op2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pauli</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
					<span class="n">op2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">0.5</span>
				<span class="n">op2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

				<span class="k">return</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">op1</span><span class="p">),</span><span class="nb">tuple</span><span class="p">(</span><span class="n">op2</span><span class="p">))</span>
			<span class="k">elif</span> <span class="n">opstr</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
				<span class="n">op1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
				<span class="n">op1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">op1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pauli</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
					<span class="n">op1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">j</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">op1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span>
				<span class="n">op1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

				<span class="n">op2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
				<span class="n">op2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">op2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pauli</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
					<span class="n">op2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">0.5</span><span class="n">j</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">op2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1</span><span class="n">j</span>
				<span class="n">op2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

				<span class="k">return</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">op1</span><span class="p">),</span><span class="nb">tuple</span><span class="p">(</span><span class="n">op2</span><span class="p">))</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">op</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
				<span class="n">op</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
				<span class="k">return</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">op</span><span class="p">)]</span>	
		<span class="k">else</span><span class="p">:</span>
	 
			<span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">opstr</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
			<span class="n">op1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
			<span class="n">op1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">opstr</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
			<span class="n">op1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indx</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
			<span class="n">op1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
			<span class="n">op1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span>

			<span class="n">op2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
			<span class="n">op2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">opstr</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
			<span class="n">op2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
			<span class="n">op2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">op2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">op2</span><span class="p">)</span>

			<span class="n">l1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_opstr</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span><span class="n">num</span><span class="p">)</span>
			<span class="n">l2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_opstr</span><span class="p">(</span><span class="n">op2</span><span class="p">,</span><span class="n">num</span><span class="p">)</span>

			<span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">op1</span> <span class="ow">in</span> <span class="n">l1</span><span class="p">:</span>
				<span class="k">for</span> <span class="n">op2</span> <span class="ow">in</span> <span class="n">l2</span><span class="p">:</span>
					<span class="n">op</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span>
					<span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">op2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
					<span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">op2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
					<span class="n">op</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">op2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
					<span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>

			<span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

<div class="viewcode-block" id="spin_basis_general.Op_bra_ket"><a class="viewcode-back" href="../../../../generated/quspin.basis.spin_basis_general.html#quspin.basis.spin_basis_general.Op_bra_ket">[docs]</a>	<span class="k">def</span> <span class="nf">Op_bra_ket</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">ket_states</span><span class="p">,</span><span class="n">reduce_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_S</span> <span class="o">==</span> <span class="s2">&quot;1/2&quot;</span><span class="p">:</span>
			<span class="n">ME</span><span class="p">,</span><span class="n">bra</span><span class="p">,</span><span class="n">ket</span> <span class="o">=</span> <span class="n">hcb_basis_general</span><span class="o">.</span><span class="n">Op_bra_ket</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">ket_states</span><span class="p">,</span><span class="n">reduce_output</span><span class="o">=</span><span class="n">reduce_output</span><span class="p">)</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pauli</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
				<span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">opstr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;I&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">))</span>
				<span class="n">ME</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n</span><span class="p">)</span>
			<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pauli</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
				<span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">opstr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;I&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">))</span>
				<span class="n">ME</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">higher_spin_basis_general</span><span class="o">.</span><span class="n">Op_bra_ket</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">ket_states</span><span class="p">,</span><span class="n">reduce_output</span><span class="o">=</span><span class="n">reduce_output</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">ME</span><span class="p">,</span><span class="n">bra</span><span class="p">,</span><span class="n">ket</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">QuSpin 0.3.7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Phillip Weinberg, Markus Schmitt and Marin Bukov.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.4.
    </div>
  </body>
</html>