
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-110543543-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <title>quspin.basis.basis_general.boson &#8212; QuSpin 0.3.3 documentation</title>
    <link rel="stylesheet" href="../../../../static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../../static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../static/jquery.js"></script>
    <script type="text/javascript" src="../../../../static/underscore.js"></script>
    <script type="text/javascript" src="../../../../static/doctools.js"></script>
    <script type="text/javascript" src="../../../../static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">QuSpin 0.3.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for quspin.basis.basis_general.boson</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">._basis_general_core</span> <span class="k">import</span> <span class="n">boson_basis_core_wrap</span><span class="p">,</span><span class="n">get_basis_type</span><span class="p">,</span><span class="n">basis_zeros</span>
<span class="kn">from</span> <span class="nn">.base_hcb</span> <span class="k">import</span> <span class="n">hcb_basis_general</span>
<span class="kn">from</span> <span class="nn">.base_general</span> <span class="k">import</span> <span class="n">basis_general</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">_np</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">comb</span>

<span class="k">def</span> <span class="nf">H_dim</span><span class="p">(</span><span class="n">Np</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">m_max</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the total number of states in the bosonic Hilbert space</span>

<span class="sd">    --- arguments:</span>

<span class="sd">    Np: total number of bosons in lattice</span>
<span class="sd">    N: total number of sites</span>
<span class="sd">    m_max+1: max number of states per site </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Ns</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Np</span><span class="o">//</span><span class="p">(</span><span class="n">m_max</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">r_2</span> <span class="o">=</span> <span class="n">Np</span> <span class="o">-</span> <span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">m_max</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Ns</span> <span class="o">+=</span>  <span class="n">comb</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">r_2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="n">r_2</span><span class="p">,</span><span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ns</span> <span class="o">+=</span> <span class="o">-</span><span class="n">comb</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">r_2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="n">r_2</span><span class="p">,</span><span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Ns</span>

<span class="c1"># general basis for hardcore bosons/spin-1/2</span>
<div class="viewcode-block" id="boson_basis_general"><a class="viewcode-back" href="../../../../generated/quspin.basis.boson_basis_general.html#quspin.basis.boson_basis_general">[docs]</a><span class="k">class</span> <span class="nc">boson_basis_general</span><span class="p">(</span><span class="n">hcb_basis_general</span><span class="p">,</span><span class="n">basis_general</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Constructs basis for boson operators for USER-DEFINED symmetries.</span>

<span class="sd">	Any unitary symmetry transformation :math:`Q` of periodicity :math:`m_Q` (:math:`Q^{m_Q}=1`) has</span>
<span class="sd">	eigenvalues :math:`\\exp(-2\\pi i q/m_Q)`, labelled by an ingeter :math:`q\\in\\{0,1,\\dots,m_Q-1\\}`.</span>
<span class="sd">	These integers :math:`q` are used to define the symmetry blocks.</span>

<span class="sd">	For instance, if :math:`Q=P` is parity (reflection), then :math:`q=0,1`. If :math:`Q=T` is translation by one lattice site,</span>
<span class="sd">	then :math:`q` labels the mometum blocks in the same fashion as for the `..._basis_1d` classes. </span>

<span class="sd">	User-defined symmetries with the `boson_basis_general` class can be programmed as follows. Suppose we have a system of</span>
<span class="sd">	L sites, enumerated :math:`s=(s_0,s_1,\\dots,s_{L-1})`. There are two types of operations one can perform on the sites:</span>
<span class="sd">		* exchange the labels of two sites: :math:`s_i \\leftrightarrow s_j` (e.g., translation, parity)</span>
<span class="sd">		* invert the population on a given site: :math:`s_i\\leftrightarrow -(s_j+1)` (e.g., particle-hole symmetry, hardcore bosons only)</span>

<span class="sd">	These two operations already comprise a variety of symmetries, including translation, parity (reflection) and </span>
<span class="sd">	spin inversion. For a specific example, see below.</span>

<span class="sd">	The supported operator strings for `boson_basis_general` are:</span>

<span class="sd">	.. math::</span>
<span class="sd">		\\begin{array}{cccc}</span>
<span class="sd">			\\texttt{basis}/\\texttt{opstr}   &amp;   \\texttt{&quot;I&quot;}   &amp;   \\texttt{&quot;+&quot;}   &amp;   \\texttt{&quot;-&quot;}  &amp;   \\texttt{&quot;n&quot;}   &amp;   \\texttt{&quot;z&quot;}     \\newline	</span>
<span class="sd">			\\texttt{boson_basis_general}&amp;   \\hat{1}        &amp;   \\hat b^\\dagger      &amp;       \\hat b          &amp; \\hat b^\\dagger b     &amp;  \\hat b^\\dagger\\hat b - \\frac{\\mathrm{sps}-1}{2}  \\newline</span>
<span class="sd">		\\end{array}</span>

<span class="sd">	Notes</span>
<span class="sd">	-----</span>
<span class="sd">	* if `Nb` or `nb` are specified, by default `sps` is set to the number of bosons on the lattice.</span>
<span class="sd">	* if `sps` is specified, while `Nb` or `nb` are not, all particle sectors are filled up to the maximumal </span>
<span class="sd">		occupation. </span>
<span class="sd">	* if `Nb` or `nb` and `sps` are specified, the finite boson basis is constructed with the local Hilbert space </span>
<span class="sd">		restrited by `sps`.</span>
<span class="sd">	* QuSpin raises a warning to alert the reader when non-commuting symmetries are passed. In such cases, we recommend the user to manually check the combined usage of symmetries by, e.g., comparing the eigenvalues.</span>


<span class="sd">	Examples</span>
<span class="sd">	--------</span>

<span class="sd">	The code snippet below shows how to construct the two-dimensional Bose-Hubbard model.</span>
<span class="sd">	</span>
<span class="sd">	.. math::</span>
<span class="sd">		H = -J \\sum_{\\langle ij\\rangle} b^\dagger_i b_j + \\mathrm{h.c.} - \\mu\\sum_j n_j + \\frac{U}{2}\\sum_j n_j(n_j-1)</span>

<span class="sd">	Moreover, it demonstrates how to pass user-defined symmetries to the `boson_basis_general` constructor. In particular,</span>
<span class="sd">	we do translation invariance and parity (reflection) (along each lattice direction).</span>

<span class="sd">	.. literalinclude:: ../../doc_examples/boson_basis_general-example.py</span>
<span class="sd">		:linenos:</span>
<span class="sd">		:language: python</span>
<span class="sd">		:lines: 7-</span>


<span class="sd">	&quot;&quot;&quot;</span>
<div class="viewcode-block" id="boson_basis_general.__init__"><a class="viewcode-back" href="../../../../generated/quspin.basis.boson_basis_general.html#quspin.basis.boson_basis_general.__init__">[docs]</a>	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">Nb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">nb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">sps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">Ns_block_est</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">make_basis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">block_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">blocks</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Intializes the `boson_basis_general` object (basis for bosonic operators).</span>

<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		N: int</span>
<span class="sd">			Number of sites.</span>
<span class="sd">		Nb: {int,list}, optional</span>
<span class="sd">			Number of bosons in chain. Can be integer or list to specify one or more particle sectors.</span>
<span class="sd">		nb: float, optional</span>
<span class="sd">			Density of bosons in chain (bosons per site).</span>
<span class="sd">		sps: int, optional</span>
<span class="sd">			Number of states per site (including zero bosons), or on-site Hilbert space dimension.</span>
<span class="sd">		Ns_block_est: int, optional</span>
<span class="sd">			Overwrites the internal estimate of the size of the reduced Hilbert space for the given symmetries. This can be used to help conserve memory if the exact size of the H-space is known ahead of time. </span>
<span class="sd">		make_basis: bool, optional</span>
<span class="sd">			Boolean to control whether to make the basis. Allows the use to use some functionality of the basis constructor without constructing the entire basis.</span>
<span class="sd">		block_order: list of strings, optional</span>
<span class="sd">			A list of strings containing the names of the symmetry blocks which specifies the order in which the symmetries will be applied to the state when calculating the basis. The first element in the list is applied to the state first followed by the second element, etc. If the list is not specificed the ordering is such that the symmetry with the largest cycle is the first, followed by the second largest, etc. </span>
<span class="sd">		**blocks: optional</span>
<span class="sd">			keyword arguments which pass the symmetry generator arrays. For instance:</span>

<span class="sd">			&gt;&gt;&gt; basis(...,kxblock=(Q,q),...)</span>

<span class="sd">			The keys of the symmetry sector, e.g. `kxblock`, can be chosen arbitrarily by the user. The</span>
<span class="sd">			values are tuples where the first entry contains the symmetry transformation :math:`Q` acting on the</span>
<span class="sd">			lattice sites (see class example), and the second entry is an integer :math:`q` to label the symmetry</span>
<span class="sd">			sector.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">_Np</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_Np&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">_Np</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">blocks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_Np&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">sps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

			<span class="k">if</span> <span class="n">Nb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">nb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot use &#39;nb&#39; and &#39;Nb&#39; simultaineously.&quot;</span><span class="p">)</span>

			<span class="k">elif</span> <span class="n">nb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">Nb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot use &#39;nb&#39; and &#39;Nb&#39; simultaineously.&quot;</span><span class="p">)</span>

				<span class="n">Nb</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nb</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting value for &#39;Nb&#39;,&#39;nb&#39; or &#39;sps&#39;&quot;</span><span class="p">)</span>

			<span class="k">try</span><span class="p">:</span>
				<span class="n">sps</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">Nb</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span>
			<span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
				<span class="n">sps</span> <span class="o">=</span> <span class="n">Nb</span><span class="o">+</span><span class="mi">1</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">Nb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">nb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot use &#39;nb&#39; and &#39;Nb&#39; simultaineously.&quot;</span><span class="p">)</span>

			<span class="k">elif</span> <span class="n">nb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">Nb</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nb</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_sps</span> <span class="o">=</span> <span class="n">sps</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_allowed_ops</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="s2">&quot;I&quot;</span><span class="p">,</span><span class="s2">&quot;z&quot;</span><span class="p">,</span><span class="s2">&quot;n&quot;</span><span class="p">,</span><span class="s2">&quot;+&quot;</span><span class="p">,</span><span class="s2">&quot;-&quot;</span><span class="p">])</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_pcon_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span><span class="n">Nb</span><span class="o">=</span><span class="n">Nb</span><span class="p">,</span><span class="n">sps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_sps</span><span class="p">)</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sps</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_operators</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;availible operators for boson_basis_1d:&quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">I: identity &quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">+: raising operator&quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">-: lowering operator&quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">n: number operator&quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">z: c-symm number operator&quot;</span><span class="p">)</span>

			<span class="n">hcb_basis_general</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">Nb</span><span class="o">=</span><span class="n">Nb</span><span class="p">,</span><span class="n">_Np</span><span class="o">=</span><span class="n">_Np</span><span class="p">,</span><span class="n">_make_basis</span><span class="o">=</span><span class="n">make_basis</span><span class="p">,</span><span class="n">block_order</span><span class="o">=</span><span class="n">block_order</span><span class="p">,</span><span class="o">**</span><span class="n">blocks</span><span class="p">)</span>
		
		<span class="k">else</span><span class="p">:</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_operators</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;availible operators for ferion_basis_1d:&quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">I: identity &quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">+: raising operator&quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">-: lowering operator&quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">n: number operator&quot;</span><span class="o">+</span>
								<span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">z: ph-symm number operator&quot;</span><span class="p">)</span>


			<span class="n">basis_general</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="o">**</span><span class="n">blocks</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_check_pcon</span> <span class="o">=</span> <span class="kc">False</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_count_particles</span> <span class="o">=</span> <span class="kc">False</span>
			<span class="k">if</span> <span class="n">_Np</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Nb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_count_particles</span> <span class="o">=</span> <span class="kc">True</span>
				<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">_Np</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;_Np must be integer&quot;</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">_Np</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">_Np</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">:</span> 
						<span class="n">Nb</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
					<span class="k">elif</span> <span class="n">_Np</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
						<span class="n">Nb</span> <span class="o">=</span> <span class="kc">None</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">Nb</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">_Np</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;_Np == -1 for no particle conservation, _Np &gt;= 0 for particle conservation&quot;</span><span class="p">)</span>

			<span class="k">if</span> <span class="n">Nb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">sps</span><span class="o">**</span><span class="n">N</span>
			<span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">Nb</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_check_pcon</span> <span class="o">=</span> <span class="kc">True</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_get_proj_pcon</span> <span class="o">=</span> <span class="kc">True</span>

				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_sps</span> <span class="o">=</span> <span class="n">Nb</span><span class="o">+</span><span class="mi">1</span>

				<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">H_dim</span><span class="p">(</span><span class="n">Nb</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_sps</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">try</span><span class="p">:</span>
					<span class="n">Np_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">Nb</span><span class="p">)</span>
				<span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Nb must be integer or iteratable object.&quot;</span><span class="p">)</span>

				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_sps</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">Nb</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span>				

				<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="mi">0</span>
				<span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">Nb</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">+=</span> <span class="n">H_dim</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_sps</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

			<span class="c1">#self._pcon_args = dict(N=N,Nb=Nb,sps=self._sps)</span>

			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pers</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">Ns_block_est</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">)</span><span class="o">/</span><span class="n">_np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pers</span><span class="p">))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_sps</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">Ns_block_est</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span>
						<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Ns_block_est must be integer value.&quot;</span><span class="p">)</span>
					<span class="k">if</span> <span class="n">Ns_block_est</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
						<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Ns_block_est must be an integer &gt; 0&quot;</span><span class="p">)</span>						
					<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">Ns_block_est</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_basis_dtype</span> <span class="o">=</span> <span class="n">get_basis_type</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">Nb</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_sps</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_core</span> <span class="o">=</span> <span class="n">boson_basis_core_wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_dtype</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_sps</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_maps</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pers</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_qs</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">=</span> <span class="n">N</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_Ns_block_est</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_Np</span> <span class="o">=</span> <span class="n">Nb</span>

			<span class="c1"># make the basis; make() is function method of base_general</span>
			<span class="k">if</span> <span class="n">make_basis</span><span class="p">:</span>		
				<span class="bp">self</span><span class="o">.</span><span class="n">make</span><span class="p">()</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="o">=</span><span class="mi">1</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">=</span><span class="n">basis_zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_dtype</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dtype</span><span class="p">)</span></div>


	<span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">state</span><span class="p">):</span>
		<span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;_sps&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
			<span class="n">hcb_basis_general</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">state</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_core</span> <span class="o">=</span> <span class="n">boson_basis_core_wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_dtype</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_sps</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_maps</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pers</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_qs</span><span class="p">)</span>


			
	<span class="k">def</span> <span class="nf">_sort_opstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">op</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;|&#39; character found in op: </span><span class="si">{0}</span><span class="s2">,</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;number of operators in opstr: </span><span class="si">{0}</span><span class="s2"> not equal to length of indx </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

		<span class="n">op</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
		<span class="n">zipstr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="k">if</span> <span class="n">zipstr</span><span class="p">:</span>
			<span class="n">zipstr</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
			<span class="n">op1</span><span class="p">,</span><span class="n">op2</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">zipstr</span><span class="p">)</span>
			<span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span>
			<span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">op2</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>



	<span class="k">def</span> <span class="nf">_non_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">op</span><span class="p">):</span>
		<span class="n">opstr</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="n">indx</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indx</span><span class="p">):</span>
			<span class="n">indx_p</span> <span class="o">=</span> <span class="n">indx</span><span class="p">[</span><span class="n">opstr</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
			<span class="n">p</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">indx_p</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indx_p</span><span class="p">)</span>
			<span class="n">indx_p</span> <span class="o">=</span> <span class="n">indx</span><span class="p">[</span><span class="n">opstr</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
			<span class="n">m</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">indx_p</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indx_p</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">p</span> <span class="ow">and</span> <span class="n">m</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="kc">True</span>
		


	<span class="k">def</span> <span class="nf">_hc_opstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">op</span><span class="p">):</span>
		<span class="n">op</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
		<span class="c1"># take h.c. + &lt;--&gt; - , reverse operator order , and conjugate coupling</span>
		<span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span><span class="s2">&quot;%&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span><span class="s2">&quot;+&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;%&quot;</span><span class="p">,</span><span class="s2">&quot;-&quot;</span><span class="p">))</span>
		<span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
		<span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
		<span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">op</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_opstr</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="c1"># return the sorted op.</span>


	<span class="k">def</span> <span class="nf">_expand_opstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">op</span><span class="p">,</span><span class="n">num</span><span class="p">):</span>
		<span class="n">op</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
		<span class="n">op</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">op</span><span class="p">)]</span>	</div>




</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">QuSpin 0.3.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Phillip Weinberg and Marin Bukov.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>