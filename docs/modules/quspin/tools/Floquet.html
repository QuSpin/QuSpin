<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>quspin.tools.Floquet &mdash; QuSpin 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../../static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../static/css/sphinx_rtd_size.css?v=f26ae176" />
      <link rel="stylesheet" type="text/css" href="../../../static/css/py_class_property_fix.css?v=faf79ccd" />

  
  <!--[if lt IE 9]>
    <script src="../../../static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../static/jquery.js?v=5d32c60e"></script>
        <script src="../../../static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../static/documentation_options.js?v=8d563738"></script>
        <script src="../../../static/doctools.js?v=9a2dae69"></script>
        <script src="../../../static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            QuSpin
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">QuSpin (public API)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../basis.html">Basis module (<code class="xref py py-mod docutils literal notranslate"><span class="pre">quspin.basis</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../operators.html">Operators module (<code class="xref py py-mod docutils literal notranslate"><span class="pre">quspin.operators</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tools.html">Tools module (<code class="xref py py-mod docutils literal notranslate"><span class="pre">quspin.tools</span></code>)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation &amp; Use</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation/installation.html#basics-of-command-line-use">Basics of command line use</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../example_scripts.html">Example scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../jupyter_notebooks.html">Jupyter notebooks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/parallelization.html">Parallel computing support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/user_basis.html"><cite>user_basis</cite> tutorial</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Bugs &amp; Questions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute/report_a_bug.html">Report a bug</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute/ask_a_question.html">Ask a question</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">QuSpin</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">quspin.tools.Floquet</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for quspin.tools.Floquet</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>


<span class="c1"># need linear algebra packages</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span> <span class="k">as</span> <span class="nn">_sla</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">_la</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">_sp</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">_np</span>

<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">complex_ode</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">delayed</span><span class="p">,</span> <span class="n">Parallel</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">vstack</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Floquet_t_vec&quot;</span><span class="p">,</span> <span class="s2">&quot;Floquet_t_vec&quot;</span><span class="p">]</span>

<span class="c1"># warnings.warn(&quot;Floquet Package has not been fully tested yet, please report bugs to: https://github.com/weinbe58/qspin/issues.&quot;,UserWarning,stacklevel=3)</span>


<span class="k">def</span> <span class="nf">_range_iter</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;&#39;xrange&#39; is replaced with &#39;range&#39; in python 3. If python 2 is being used, range will cause memory overflow.</span>
<span class="sd">    This function is a work around to get the functionality of &#39;xrange&#39; for both python 2 and 3 simultaineously.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">count</span>

    <span class="n">counter</span> <span class="o">=</span> <span class="n">count</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>


<span class="k">def</span> <span class="nf">_evolve_cont</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This function evolves the i-th local basis state under the Hamiltonian H up to period T.</span>
<span class="sd">    It is used to construct the stroboscpoic evolution operator.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">psi0</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="n">psi0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="n">t_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">]</span>
    <span class="n">nsteps</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">nsteps</span> <span class="o">&lt;</span> <span class="mf">1e7</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">psi_t</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span>
                <span class="n">psi0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t_list</span><span class="p">,</span> <span class="n">eom</span><span class="o">=</span><span class="s2">&quot;SE&quot;</span><span class="p">,</span> <span class="n">iterate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">psi_t</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="ne">RuntimeError</span>
        <span class="n">nsteps</span> <span class="o">*=</span> <span class="mi">10</span>
        <span class="n">t_list</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">nsteps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
        <span class="s2">&quot;Ode solver takes more than </span><span class="si">{0:d}</span><span class="s2"> nsteps to complete time evolution. Cannot integrate ODE successfully.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">nsteps</span>
        <span class="p">)</span>
    <span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	solver=complex_ode(H._hamiltonian__SO)</span>
<span class="sd">	solver.set_integrator(&#39;dop853&#39;, atol=atol,rtol=rtol,nsteps=nsteps) </span>
<span class="sd">	solver.set_initial_value(psi0,t=0.0)</span>
<span class="sd">	t_list = [0,T]</span>
<span class="sd">	nsteps = 1</span>
<span class="sd">	while True:</span>
<span class="sd">		for t in t_list[1:]:</span>
<span class="sd">			solver.integrate(t)</span>
<span class="sd">			if solver.successful():</span>
<span class="sd">				if t == T:</span>
<span class="sd">					return solver.y</span>
<span class="sd">				continue</span>
<span class="sd">			else:</span>
<span class="sd">				break</span>

<span class="sd">		nsteps *= 10</span>
<span class="sd">		t_list = _np.linspace(0,T,num=nsteps+1,endpoint=True)</span>

<span class="sd">	&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">_evolve_step_3</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">H_list</span><span class="p">,</span> <span class="n">dt_list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This function calculates the evolved state for Periodic Step (point 3. in def of &#39;evo_dict&#39;).&quot;&quot;&quot;</span>

    <span class="n">psi0</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">H_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Ns</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="n">psi0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">for</span> <span class="n">dt</span><span class="p">,</span> <span class="n">H</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dt_list</span><span class="p">,</span> <span class="n">H_list</span><span class="p">):</span>
        <span class="c1"># can replace _sla.expm_multiply by tools.expm_multiply_parallel</span>
        <span class="n">psi0</span> <span class="o">=</span> <span class="n">_sla</span><span class="o">.</span><span class="n">expm_multiply</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">H</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(),</span> <span class="n">psi0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">psi0</span>


<span class="k">def</span> <span class="nf">_evolve_step_2</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">t_list</span><span class="p">,</span> <span class="n">dt_list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This function calculates the evolved state for Periodic Step (point 2. in def of &#39;evo_dict&#39;.&quot;&quot;&quot;</span>

    <span class="n">psi0</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="n">psi0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">t_list</span><span class="p">,</span> <span class="n">dt_list</span><span class="p">):</span>
        <span class="c1"># can replace _sla.expm_multiply by tools.expm_multiply_parallel</span>
        <span class="n">psi0</span> <span class="o">=</span> <span class="n">_sla</span><span class="o">.</span><span class="n">expm_multiply</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">H</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">psi0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">psi0</span>


<span class="c1">### USING JOBLIB ###</span>
<span class="k">def</span> <span class="nf">_get_U_cont</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">):</span>

    <span class="n">sols</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
        <span class="n">delayed</span><span class="p">(</span><span class="n">_evolve_cont</span><span class="p">)(</span><span class="n">i</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_range_iter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">vstack</span><span class="p">(</span><span class="n">sols</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>


<span class="k">def</span> <span class="nf">_get_U_step_3</span><span class="p">(</span><span class="n">H_list</span><span class="p">,</span> <span class="n">dt_list</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">):</span>

    <span class="n">sols</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
        <span class="n">delayed</span><span class="p">(</span><span class="n">_evolve_step_3</span><span class="p">)(</span><span class="n">i</span><span class="p">,</span> <span class="n">H_list</span><span class="p">,</span> <span class="n">dt_list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_range_iter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">H_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">vstack</span><span class="p">(</span><span class="n">sols</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>


<span class="k">def</span> <span class="nf">_get_U_step_2</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">t_list</span><span class="p">,</span> <span class="n">dt_list</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">):</span>

    <span class="n">sols</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
        <span class="n">delayed</span><span class="p">(</span><span class="n">_evolve_step_2</span><span class="p">)(</span><span class="n">i</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">t_list</span><span class="p">,</span> <span class="n">dt_list</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_range_iter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">vstack</span><span class="p">(</span><span class="n">sols</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>


<div class="viewcode-block" id="Floquet">
<a class="viewcode-back" href="../../../generated/quspin.tools.Floquet.Floquet.html#quspin.tools.Floquet.Floquet">[docs]</a>
<span class="k">class</span> <span class="nc">Floquet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculates the Floquet spectrum, Floquet Hamiltonian and Floquet states.</span>

<span class="sd">    Loops over the basis states to compute the Floquet unitary :math:`U_F` (evolution operator over one period) for a</span>
<span class="sd">    periodically-driven system governed by the Hamiltonian :math:`H(t)=H(t+T)`:</span>

<span class="sd">    .. math::</span>
<span class="sd">            U_F=U(T,0)=\\mathcal{T}_t\\exp\\left(-i\\int_0^T\\mathrm{d}t H(t) \\right)</span>

<span class="sd">    with :math:`\\mathcal{T}_t\\exp` denoting the time-ordered exponential.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Consider the following periodically driven spin-1/2 Hamiltonian</span>

<span class="sd">    .. math::</span>
<span class="sd">            H(t) = \\left\\{</span>
<span class="sd">            \\begin{array}{cl} \\sum_j J\\sigma^z_{j+1}\\sigma^z_j + h\\sigma^z_j , &amp;  t\\in[-T/4,T/4] \\newline</span>
<span class="sd">            \\sum_j g\\sigma^x_j, &amp;  t \\in[T/4,3T/4]</span>
<span class="sd">            \\end{array}</span>
<span class="sd">            \\right\\}  \\mathrm{mod}\\ T</span>

<span class="sd">    where :math:`T=2\\pi/\\Omega` is the drive period. We choose the starting point of the evolution</span>
<span class="sd">    (or equivalently -- the driving phase) to be :math:`t=0`.</span>

<span class="sd">    The following snippet of code shows how to calculate the Floquet eigenstates and the corresponding quasienergies,</span>
<span class="sd">    using `evo_dict` variable, case ii (see below).</span>

<span class="sd">    .. literalinclude:: ../../doc_examples/Floquet_class-example.py</span>
<span class="sd">            :linenos:</span>
<span class="sd">            :language: python</span>
<span class="sd">            :lines: 7-</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Floquet.__init__">
<a class="viewcode-back" href="../../../generated/quspin.tools.Floquet.Floquet.html#quspin.tools.Floquet.Floquet.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evo_dict</span><span class="p">,</span> <span class="n">HF</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">UF</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">thetaF</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">VF</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiates the `Floquet` class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        evo_dict : dict</span>
<span class="sd">                Dictionary which passes the different types of protocols to calculate the Floquet unitary.</span>
<span class="sd">                Depending on the protocol type, it contains the following keys:</span>

<span class="sd">                i) Periodic continuous protocol from a `hamiltonian` object.</span>
<span class="sd">                        * `H` : hamiltonian object to generate the time evolution.</span>
<span class="sd">                        * `T` : period of the protocol.</span>
<span class="sd">                        * `rtol` : (optional) relative tolerance for the ODE solver. (default = 1E-9)</span>
<span class="sd">                        * `atol` : (optional) absolute tolerance for the ODE solver. (default = 1E-9)</span>

<span class="sd">                ii) Periodic step protocol from a `hamiltonian` object.</span>
<span class="sd">                        * `H` : single hamiltonian object to generate the hamiltonians at each step. Periodic step drives can be encoded using a single function, e.g. :math:`\\mathrm{sign}(\\cos(\\Omega t))`.</span>
<span class="sd">                        * `t_list` : list of times to evaluate the hamiltonian at for each step.</span>
<span class="sd">                        * `dt_list` : list of time step durations for each step of the evolution.</span>
<span class="sd">                        * `T`: (optional) drive period used to compute the Floquet Hamiltonian `H_F`. If not specified, then `T=sum(dt_list)`. Use this option for periodic delta kicks.</span>

<span class="sd">                iii) Periodic step protocol from a list of hamiltonians.</span>
<span class="sd">                        * `H_list` : list of matrices to evolve with.</span>
<span class="sd">                        * `dt_list` : list of time step durations. Must be the same size as `H_list`.</span>
<span class="sd">                        * `T`: (optional) drive period used to compute the Floquet Hamiltonian `H_F`. If not specified, then `T=sum(dt_list)`. Use this option for periodic delta kicks.</span>

<span class="sd">        HF : bool</span>
<span class="sd">                Set to `True` to calculate and return Floquet Hamiltonian under attribute `_.HF`. Default is `False`.</span>
<span class="sd">        UF : bool</span>
<span class="sd">                Set to `True` to save evolution operator under attribute `_.UF`. Default is `False`.</span>
<span class="sd">        thetaF : bool</span>
<span class="sd">                Set to `True` to save eigenvalues of the evolution operator (Floquet phases) under attribute `_.thetaF`. Default is `False`.</span>
<span class="sd">        VF : bool</span>
<span class="sd">                Set to `True` to save Floquet states under attribute _.VF. Default is `False`.</span>
<span class="sd">        n_jobs : int, optional</span>
<span class="sd">                Sets the number of processors which are used when looping over the basis states to compute the Floquet unitary. Default is `False`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">quspin.operators</span> <span class="kn">import</span> <span class="n">ishamiltonian</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">HF</span><span class="p">:</span>
            <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;HF&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">UF</span><span class="p">:</span>
            <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;UF&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">VF</span><span class="p">:</span>
            <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;VF&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">thetaF</span><span class="p">:</span>
            <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;thetaF&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">evo_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>

            <span class="n">keys</span> <span class="o">=</span> <span class="n">evo_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">])</span>
                <span class="ow">or</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;atol&quot;</span><span class="p">])</span>
                <span class="ow">or</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;rtol&quot;</span><span class="p">])</span>
                <span class="ow">or</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;atol&quot;</span><span class="p">,</span> <span class="s2">&quot;rtol&quot;</span><span class="p">])</span>
            <span class="p">):</span>

                <span class="n">H</span> <span class="o">=</span> <span class="n">evo_dict</span><span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">]</span>
                <span class="n">T</span> <span class="o">=</span> <span class="n">evo_dict</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_atol</span> <span class="o">=</span> <span class="n">evo_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;atol&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rtol</span> <span class="o">=</span> <span class="n">evo_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rtol&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_atol</span> <span class="o">=</span> <span class="mf">1e-12</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atol</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">float</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting float for &#39;atol&#39;.&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rtol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_rtol</span> <span class="o">=</span> <span class="mf">1e-12</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rtol</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">float</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting float for &#39;rtol&#39;.&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">ishamiltonian</span><span class="p">(</span><span class="n">H</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting hamiltonian object for &#39;H&#39;.&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">_np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting scalar object for &#39;T&#39;.&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting real value for &#39;T&#39;.&quot;</span><span class="p">)</span>

                <span class="c1">### check if H is periodic with period T</span>
                <span class="c1"># define arbitrarily complicated weird-ass number</span>

                <span class="n">t</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">_np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">_np</span><span class="o">.</span><span class="n">euler_gamma</span><span class="p">))</span>

                <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">H</span><span class="o">.</span><span class="n">dynamic</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">func</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">T</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1e5</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="nb">abs</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">func</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">T</span><span class="p">)),</span>
                            <span class="mf">1e3</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="s2">&quot;Hamiltonian &#39;H&#39; must be periodic with period &#39;T&#39;!&quot;</span>
                        <span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;expecting integer value for optional variable &#39;n_jobs&#39;!&quot;</span>
                    <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_T</span> <span class="o">=</span> <span class="n">T</span>

                <span class="c1"># calculate evolution operator</span>
                <span class="n">UF</span> <span class="o">=</span> <span class="n">_get_U_cont</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_atol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rtol</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;t_list&quot;</span><span class="p">,</span> <span class="s2">&quot;dt_list&quot;</span><span class="p">])</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span>
                <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;t_list&quot;</span><span class="p">,</span> <span class="s2">&quot;dt_list&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">H</span> <span class="o">=</span> <span class="n">evo_dict</span><span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">]</span>
                <span class="n">t_list</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">evo_dict</span><span class="p">[</span><span class="s2">&quot;t_list&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">dt_list</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">evo_dict</span><span class="p">[</span><span class="s2">&quot;dt_list&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">t_list</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;t_list must be 1d array.&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">dt_list</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dt_list must be 1d array.&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="s2">&quot;T&quot;</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_T</span> <span class="o">=</span> <span class="n">evo_dict</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_T</span> <span class="o">=</span> <span class="n">dt_list</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">ishamiltonian</span><span class="p">(</span><span class="n">H</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting hamiltonian object for &#39;H&#39;.&quot;</span><span class="p">)</span>

                <span class="c1"># calculate evolution operator</span>
                <span class="n">UF</span> <span class="o">=</span> <span class="n">_get_U_step_2</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">t_list</span><span class="p">,</span> <span class="n">dt_list</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;H_list&quot;</span><span class="p">,</span> <span class="s2">&quot;dt_list&quot;</span><span class="p">])</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span>
                <span class="p">[</span><span class="s2">&quot;H_list&quot;</span><span class="p">,</span> <span class="s2">&quot;dt_list&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">H_list</span> <span class="o">=</span> <span class="n">evo_dict</span><span class="p">[</span><span class="s2">&quot;H_list&quot;</span><span class="p">]</span>
                <span class="n">dt_list</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">evo_dict</span><span class="p">[</span><span class="s2">&quot;dt_list&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">dt_list</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dt_list must be 1d array.&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="s2">&quot;T&quot;</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_T</span> <span class="o">=</span> <span class="n">evo_dict</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_T</span> <span class="o">=</span> <span class="n">dt_list</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">H_list</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting list/tuple for H_list.&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">H_list</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Expecting arguments &#39;H_list&#39; and &#39;dt_list&#39; to have the same length!&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># calculate evolution operator</span>
                <span class="n">UF</span> <span class="o">=</span> <span class="n">_get_U_step_3</span><span class="p">(</span><span class="n">H_list</span><span class="p">,</span> <span class="n">dt_list</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;evo_dict=</span><span class="si">{0}</span><span class="s2"> is not correct format.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">evo_dict</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;evo_dict=</span><span class="si">{0}</span><span class="s2"> is not correct format.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">evo_dict</span><span class="p">))</span>

        <span class="k">if</span> <span class="s2">&quot;UF&quot;</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_UF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">UF</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;HF&quot;</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_HF</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_T</span> <span class="o">*</span> <span class="n">_la</span><span class="o">.</span><span class="n">logm</span><span class="p">(</span><span class="n">UF</span><span class="p">)</span>

        <span class="c1"># find Floquet states and phases</span>
        <span class="k">if</span> <span class="s2">&quot;VF&quot;</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="n">thetaF</span><span class="p">,</span> <span class="n">VF</span> <span class="o">=</span> <span class="n">_la</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">UF</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># check and orthogonalise VF in degenerate subspaces</span>
            <span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">thetaF</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1e3</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">thetaF</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">):</span>
                <span class="n">VF</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_la</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">VF</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># https://math.stackexchange.com/questions/269164/diagonalizable-unitarily-schur-factorization</span>
            <span class="c1"># thetaF, VF = _la.schur(UF,overwrite_a=True,output=&#39;real&#39;)</span>
            <span class="c1"># thetaF=thetaF.diagonal()</span>

            <span class="c1"># calculate and order q&#39;energies</span>
            <span class="n">EF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">thetaF</span><span class="p">))</span>
            <span class="c1"># sort and order</span>
            <span class="n">ind_EF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">EF</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_EF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">EF</span><span class="p">[</span><span class="n">ind_EF</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_VF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">VF</span><span class="p">[:,</span> <span class="n">ind_EF</span><span class="p">])</span>
            <span class="c1"># clear up junk</span>
            <span class="k">del</span> <span class="n">VF</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thetaF</span> <span class="o">=</span> <span class="n">_la</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">UF</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># calculate and order q&#39;energies</span>
            <span class="n">EF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">thetaF</span><span class="p">))</span>
            <span class="n">ind_EF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">EF</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_EF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">EF</span><span class="p">[</span><span class="n">ind_EF</span><span class="p">])</span>

        <span class="k">if</span> <span class="s2">&quot;thetaF&quot;</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="c1"># sort phases</span>
            <span class="n">thetaF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">thetaF</span><span class="p">[</span><span class="n">ind_EF</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_thetaF</span> <span class="o">=</span> <span class="n">thetaF</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;float: drive period.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_T</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">EF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;numpy.ndarray(float): ordered Floquet quasi-energies in interval :math:`[-\\Omega,\\Omega]`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EF</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">HF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;numpy.ndarray(float): Floquet Hamiltonian.</span>

<span class="sd">        Requires __init__ argument HF=True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_HF&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HF</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;missing atrribute &#39;HF&#39;.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">UF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;numpy.ndarray(float): Floquet unitary.</span>

<span class="sd">        Requires __init__ argument UF=True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_UF&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_UF</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;missing atrribute &#39;UF&#39;.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">thetaF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;numpy.ndarray(float): Floquet eigenphases.</span>

<span class="sd">        Requires __init__ argument thetaF=True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_thetaF&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thetaF</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;missing atrribute &#39;thetaF&#39;.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">VF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;numpy.ndarray(float): Floquet eigenbasis (in columns).</span>

<span class="sd">        Requires __init__ argument VF=True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_VF&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VF</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;missing atrribute &#39;VF&#39;.&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="Floquet_t_vec">
<a class="viewcode-back" href="../../../generated/quspin.tools.Floquet.Floquet_t_vec.html#quspin.tools.Floquet.Floquet_t_vec">[docs]</a>
<span class="k">class</span> <span class="nc">Floquet_t_vec</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a Floquet time vector with fixed number of points per period.</span>

<span class="sd">    This time vector hits all stroboscopic times, and has many useful attributes. The time vector</span>
<span class="sd">    can be divided in three parts corresponding to three regimes of periodic evolution:</span>
<span class="sd">    ramp-up, constant and ramp-down.</span>

<span class="sd">    Particularly useful for studying periodically-driven systems.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    The following code shows how to use the `Floquet_t_vec` class.</span>

<span class="sd">    .. literalinclude:: ../../doc_examples/Floquet_t_vec-example.py</span>
<span class="sd">            :linenos:</span>
<span class="sd">            :language: python</span>
<span class="sd">            :lines: 7-</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Floquet_t_vec.__init__">
<a class="viewcode-back" href="../../../generated/quspin.tools.Floquet.Floquet_t_vec.html#quspin.tools.Floquet.Floquet_t_vec.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Omega</span><span class="p">,</span> <span class="n">N_const</span><span class="p">,</span> <span class="n">len_T</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">N_up</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_down</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Omega : float</span>
<span class="sd">                Drive frequency.</span>
<span class="sd">        N_const : int</span>
<span class="sd">                Number of time periods in the constant part (period) of the time vector.</span>
<span class="sd">        len_T : int</span>
<span class="sd">                Number of time points within a single period. N.B. the last period interval is assumed</span>
<span class="sd">                open on the right, i.e. [0,T) and the point T is NOT counted towards &#39;len_T&#39;.</span>
<span class="sd">        N_up : int, optional</span>
<span class="sd">                Number of time periods in the up-part (period) of time vector.</span>
<span class="sd">        N_down : int, optional</span>
<span class="sd">                Number of time periods in the down-part (period) of time vector.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># total number of periods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">=</span> <span class="n">N_up</span> <span class="o">+</span> <span class="n">N_const</span> <span class="o">+</span> <span class="n">N_down</span>
        <span class="c1"># total length of a period</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len_T</span> <span class="o">=</span> <span class="n">len_T</span>
        <span class="c1"># driving period T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_T</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">Omega</span>

        <span class="c1"># define time vector</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">N_up</span><span class="p">,</span> <span class="n">N_const</span> <span class="o">+</span> <span class="n">N_down</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="n">len_T</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">n</span>
        <span class="c1"># total length of time vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">size</span>
        <span class="c1"># shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># time step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_T</span>
        <span class="c1"># define index of period -N_up</span>
        <span class="n">ind0</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># int( _np.squeeze( (n==-N_up).nonzero() ) )</span>

        <span class="c1"># calculate stroboscopic times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strobo</span> <span class="o">=</span> <span class="n">_strobo_times</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_T</span><span class="p">,</span> <span class="n">ind0</span><span class="p">)</span>

        <span class="c1"># define initial and final times and total duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_i</span>

        <span class="c1"># if ramp is on, define more attributes</span>
        <span class="k">if</span> <span class="n">N_up</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">N_down</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">t_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_up</span> <span class="o">=</span> <span class="n">_periodic_ramp</span><span class="p">(</span><span class="n">N_up</span><span class="p">,</span> <span class="n">t_up</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_T</span><span class="p">,</span> <span class="n">ind0</span><span class="p">)</span>

            <span class="n">t_const</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span><span class="p">]</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span> <span class="o">+</span> <span class="n">N_const</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">]</span>
            <span class="n">ind0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">up</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_const</span> <span class="o">=</span> <span class="n">_periodic_ramp</span><span class="p">(</span><span class="n">N_const</span><span class="p">,</span> <span class="n">t_const</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_T</span><span class="p">,</span> <span class="n">ind0</span><span class="p">)</span>

            <span class="n">t_down</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span> <span class="o">+</span> <span class="n">N_const</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">]</span>
            <span class="n">ind0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_down</span> <span class="o">=</span> <span class="n">_periodic_ramp</span><span class="p">(</span><span class="n">N_down</span><span class="p">,</span> <span class="n">t_down</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_T</span><span class="p">,</span> <span class="n">ind0</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">N_up</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">t_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_up</span> <span class="o">=</span> <span class="n">_periodic_ramp</span><span class="p">(</span><span class="n">N_up</span><span class="p">,</span> <span class="n">t_up</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_T</span><span class="p">,</span> <span class="n">ind0</span><span class="p">)</span>

            <span class="n">t_const</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span><span class="p">]</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span> <span class="o">+</span> <span class="n">N_const</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">]</span>
            <span class="n">ind0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">up</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_const</span> <span class="o">=</span> <span class="n">_periodic_ramp</span><span class="p">(</span><span class="n">N_const</span><span class="p">,</span> <span class="n">t_const</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_T</span><span class="p">,</span> <span class="n">ind0</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">N_down</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">t_const</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span><span class="p">]</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span> <span class="o">+</span> <span class="n">N_const</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_const</span> <span class="o">=</span> <span class="n">_periodic_ramp</span><span class="p">(</span><span class="n">N_const</span><span class="p">,</span> <span class="n">t_const</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_T</span><span class="p">,</span> <span class="n">ind0</span><span class="p">)</span>

            <span class="n">t_down</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span> <span class="o">+</span> <span class="n">N_const</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">]</span>
            <span class="n">ind0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_down</span> <span class="o">=</span> <span class="n">_periodic_ramp</span><span class="p">(</span><span class="n">N_down</span><span class="p">,</span> <span class="n">t_down</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_T</span><span class="p">,</span> <span class="n">ind0</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span> <span class="o">*</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span> <span class="o">/</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span> <span class="o">/</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">N</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int: total number of periods.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;tuple: shape of array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">len_T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int: number of time points within one period, assumed half-open; [0,T).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len_T</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;float: drive period.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_T</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;np.ndarray(float): time vector values.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int: length of time vector.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;float: time vector step size.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">i</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;float: initial time value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_i</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;foat: final time value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;float: total time duration; `_.f - _.i` .&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tot</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">strobo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;obj: calculates stroboscopic times in time vector with period length `len_T` and assigns them as</span>
<span class="sd">        attributes:</span>

<span class="sd">        _.strobo.inds : numpy.ndarray(int)</span>
<span class="sd">                indices of stroboscopic times (full periods).</span>

<span class="sd">        _.strobo.vals : numpy.ndarray(float)</span>
<span class="sd">                values of stroboscopic times (full periods).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strobo</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">up</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;obj: refers to time vector of up-part (regime).</span>

<span class="sd">        Inherits all attributes (e.g. `_.up.strobo.inds`) except `_.T`, `_.dt`, and `_.lenT`.</span>

<span class="sd">        Requires optional `__init___` parameter `N_up` to be specified.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_up&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_up</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;missing attribute &#39;up&#39;&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">const</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;obj: refers to time vector of const-part (regime).</span>

<span class="sd">        Inherits all attributes (e.g. `_.const.strobo.inds`) except `_.T`, `_.dt`, and `_.lenT`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_const&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_const</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;missing attribute &#39;const&#39;&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">down</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;obj: refers to time vector of down-part (regime).</span>

<span class="sd">        Inherits all attributes (e.g. `_.down.strobo.inds`) except `_.T`, `_.dt`, and `_.lenT`.</span>

<span class="sd">        Requires optional __init___ parameter N_down to be specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_down&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_down</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;missing attribute &#39;down&#39;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Floquet_t_vec.get_coordinates">
<a class="viewcode-back" href="../../../generated/quspin.tools.Floquet.Floquet_t_vec.html#quspin.tools.Floquet.Floquet_t_vec.get_coordinates">[docs]</a>
    <span class="k">def</span> <span class="nf">get_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns (period number, index within period) of the `Floquet_t_vec` value stored at `index`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">                * This function finds the indegers (i,j), such that `t_evolve[t_evolve.strobo.inds[i-1] + j] = t_evolve[index]`.</span>

<span class="sd">                * The function may return wrong results if the spacing between two consecutive (i.e. nonstroboscopic) `Floquet_t_vec` values is smaller than `1E-15`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int</span>
<span class="sd">                Index, to compute the `Floquet_t_vec` coordinates of.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">                (i,j) such that `t_evolve[t_evolve.strobo.inds[i] + j] = t_evolve[index]`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; t = Floquet_t_vec(10.0,10) # define a Floquet vector</span>
<span class="sd">        &gt;&gt;&gt; index = 145 # pick a random index</span>
<span class="sd">        &gt;&gt;&gt; print(t[index]) # check element</span>
<span class="sd">        &gt;&gt;&gt; (i,j) = t.get_coordinates(index) # decompose index into stroboscopic coordinates</span>
<span class="sd">        &gt;&gt;&gt; print( t[t.strobo.inds[i] + j] ) # we obtain back original element</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-15</span>

        <span class="n">i</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">_vals</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">j</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">_np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_T</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">&lt;</span> <span class="n">eps</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span></div>
</div>



<span class="k">class</span> <span class="nc">_strobo_times</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">len_T</span><span class="p">,</span> <span class="n">ind0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates stroboscopic times in time vector t with period length len_T and assigns them as</span>
<span class="sd">        attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># indices of strobo times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inds</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">len_T</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># discrete stroboscopic t_vecs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inds</span><span class="p">)</span>
        <span class="c1"># update strobo indices to match shifted (ramped) ones</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inds</span> <span class="o">+=</span> <span class="n">ind0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inds</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span> <span class="o">*</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span> <span class="o">/</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span> <span class="o">/</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">_periodic_ramp</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">len_T</span><span class="p">,</span> <span class="n">ind0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Defines time vector attributes of each regime.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">=</span> <span class="n">N</span>  <span class="c1"># total # periods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span> <span class="o">=</span> <span class="n">t</span>  <span class="c1"># time values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># initial value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># final value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">*</span> <span class="n">T</span>  <span class="c1"># total duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="o">.</span><span class="n">size</span>  <span class="c1"># total length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strobo</span> <span class="o">=</span> <span class="n">_strobo_times</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="p">,</span> <span class="n">len_T</span><span class="p">,</span> <span class="n">ind0</span><span class="p">)</span>  <span class="c1"># strobo attributes</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span> <span class="o">*</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span> <span class="o">/</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span> <span class="o">/</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">N</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">i</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_i</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tot</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">strobo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strobo</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016, Phillip Weinberg, Markus Schmitt, and Marin Bukov.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-6885KZ7NH6"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-6885KZ7NH6', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>