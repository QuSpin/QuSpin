
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-110543543-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <title>quspin.tools.measurements &#8212; QuSpin 0.3.6 documentation</title>
    <link rel="stylesheet" href="../../../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../static/classic.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../static/documentation_options.js"></script>
    <script src="../../../static/jquery.js"></script>
    <script src="../../../static/underscore.js"></script>
    <script src="../../../static/doctools.js"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">QuSpin 0.3.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">quspin.tools.measurements</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for quspin.tools.measurements</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="c1"># need linear algebra packages</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span> <span class="k">as</span> <span class="nn">_sla</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">_la</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">_npla</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">_sp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">_np</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">isgenerator</span> <span class="k">as</span> <span class="n">_isgenerator</span> 

<span class="c1"># needed for isinstance only</span>
<span class="kn">from</span> <span class="nn">..basis</span> <span class="kn">import</span> <span class="n">isbasis</span> <span class="k">as</span> <span class="n">_isbasis</span>
<span class="kn">from</span> <span class="nn">..basis.photon</span> <span class="kn">import</span> <span class="n">photon_Hspace_dim</span>
<span class="kn">from</span> <span class="nn">.evolution</span> <span class="kn">import</span> <span class="n">ED_state_vs_time</span>
<span class="kn">from</span> <span class="nn">.misc</span> <span class="kn">import</span> <span class="n">project_op</span><span class="p">,</span><span class="n">KL_div</span><span class="p">,</span><span class="n">mean_level_spacing</span>

<span class="kn">import</span> <span class="nn">warnings</span>


<span class="n">__all__</span> <span class="o">=</span>  <span class="p">[</span><span class="s2">&quot;ent_entropy&quot;</span><span class="p">,</span> 
			<span class="s2">&quot;diag_ensemble&quot;</span><span class="p">,</span>
			<span class="s2">&quot;obs_vs_time&quot;</span><span class="p">,</span>
			<span class="s2">&quot;ED_state_vs_time&quot;</span><span class="p">,</span>
			<span class="s2">&quot;project_op&quot;</span><span class="p">,</span>
			<span class="s2">&quot;mean_level_spacing&quot;</span>
			<span class="p">]</span>



<div class="viewcode-block" id="ent_entropy"><a class="viewcode-back" href="../../../generated/quspin.tools.measurements.ent_entropy.html#quspin.tools.measurements.ent_entropy">[docs]</a><span class="k">def</span> <span class="nf">ent_entropy</span><span class="p">(</span><span class="n">system_state</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">chain_subsys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">DM</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">svd_return_vec</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span><span class="kc">False</span><span class="p">,</span><span class="kc">False</span><span class="p">],</span><span class="o">**</span><span class="n">_basis_kwargs</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;DEPRECATED (cf `basis.ent_entropy`). Calculates entanglement entropy of a subsystem using Singular Value Decomposition (svd).</span>

<span class="sd">	:red:`Note: we recommend the use of the &quot;basis.ent_entropy()&quot; method instead of this function. This function is now deprecated!`</span>

<span class="sd">	&quot;&quot;&quot;</span>

	<span class="c1"># initiate variables</span>
	<span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Sent&quot;</span><span class="p">]</span>
	<span class="n">translate_dict</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Sent&quot;</span><span class="p">:</span><span class="s2">&quot;Sent_A&quot;</span><span class="p">}</span>

	<span class="k">if</span> <span class="n">DM</span> <span class="o">==</span> <span class="s1">&#39;chain_subsys&#39;</span><span class="p">:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DM_chain_subsys&quot;</span><span class="p">)</span>
		<span class="n">_basis_kwargs</span><span class="p">[</span><span class="s2">&quot;return_rdm&quot;</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;A&quot;</span>
		

	<span class="k">elif</span> <span class="n">DM</span> <span class="o">==</span><span class="s1">&#39;other_subsys&#39;</span><span class="p">:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DM_other_subsys&quot;</span><span class="p">)</span>
		<span class="n">_basis_kwargs</span><span class="p">[</span><span class="s2">&quot;return_rdm&quot;</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;B&quot;</span>
		<span class="n">translate_dict</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Sent&quot;</span><span class="p">:</span><span class="s2">&quot;Sent_B&quot;</span><span class="p">}</span>

	<span class="k">elif</span> <span class="n">DM</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DM_chain_subsys&quot;</span><span class="p">)</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DM_other_subsys&quot;</span><span class="p">)</span>
		<span class="n">_basis_kwargs</span><span class="p">[</span><span class="s2">&quot;return_rdm&quot;</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;both&quot;</span>

	<span class="k">elif</span> <span class="n">DM</span> <span class="ow">and</span> <span class="n">DM</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;chain_subsys&#39;</span><span class="p">,</span><span class="s1">&#39;other_subsys&#39;</span><span class="p">,</span><span class="s1">&#39;both&#39;</span><span class="p">]:</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unexpected keyword argument for &#39;DM&#39;!&quot;</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">svd_return_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;lmbda&#39;</span><span class="p">)</span>
		<span class="n">_basis_kwargs</span><span class="p">[</span><span class="s2">&quot;return_rdm_EVs&quot;</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>

	<span class="c1">### translate arguments</span>
	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">system_state</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
		<span class="k">if</span> <span class="s2">&quot;rho_d&quot;</span> <span class="ow">in</span> <span class="n">system_state</span> <span class="ow">and</span> <span class="s2">&quot;V_rho&quot;</span> <span class="ow">in</span> <span class="n">system_state</span><span class="p">:</span>
			<span class="n">V_rho</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s2">&quot;V_rho&quot;</span><span class="p">]</span>
			<span class="n">rho_d</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s2">&quot;rho_d&quot;</span><span class="p">]</span> 
			<span class="n">state</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ji,j,jk-&gt;ik&quot;</span><span class="p">,</span><span class="n">V_rho</span><span class="p">,</span><span class="n">rho_d</span><span class="p">,</span><span class="n">V_rho</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
		<span class="k">elif</span> <span class="s2">&quot;V_states&quot;</span> <span class="ow">in</span> <span class="n">system_state</span><span class="p">:</span>
			<span class="n">state</span><span class="o">=</span><span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;V_states&#39;</span><span class="p">]</span>
			<span class="n">_basis_kwargs</span><span class="p">[</span><span class="s2">&quot;enforce_pure&quot;</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting dictionary with keys [&#39;V_rho&#39;,&#39;rho_d&#39;] or [&#39;V_states&#39;]&quot;</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">state</span><span class="o">=</span><span class="n">system_state</span>

	<span class="n">translate_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;DM_chain_subsys&quot;</span><span class="p">:</span><span class="s1">&#39;rdm_A&#39;</span><span class="p">,</span><span class="s2">&quot;DM_other_subsys&quot;</span><span class="p">:</span><span class="s1">&#39;rdm_B&#39;</span><span class="p">,</span><span class="s2">&quot;both&quot;</span><span class="p">:</span><span class="s1">&#39;both&#39;</span><span class="p">,</span><span class="s1">&#39;lmbda&#39;</span><span class="p">:</span><span class="s2">&quot;p_A&quot;</span><span class="p">})</span>
	
	
	<span class="n">Sent</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">ent_entropy</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">sub_sys_A</span><span class="o">=</span><span class="n">chain_subsys</span><span class="p">,</span><span class="o">**</span><span class="n">_basis_kwargs</span><span class="p">)</span>
	



	<span class="c1"># store variables to dictionary</span>
	<span class="n">return_dict</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
		<span class="n">j</span><span class="o">=</span><span class="n">translate_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;lmbda&#39;</span><span class="p">:</span>
			<span class="n">return_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">Sent</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">return_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sent</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

	<span class="n">return_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Sent</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">return_dict</span></div>
		
<div class="viewcode-block" id="diag_ensemble"><a class="viewcode-back" href="../../../generated/quspin.tools.measurements.diag_ensemble.html#quspin.tools.measurements.diag_ensemble">[docs]</a><span class="k">def</span> <span class="nf">diag_ensemble</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">system_state</span><span class="p">,</span><span class="n">E2</span><span class="p">,</span><span class="n">V2</span><span class="p">,</span><span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">rho_d</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">Obs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">delta_t_Obs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">delta_q_Obs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">Sd_Renyi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">Srdm_Renyi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">Srdm_args</span><span class="o">=</span><span class="p">{}):</span>
	<span class="sd">&quot;&quot;&quot;Calculates expectation values in the Diagonal ensemble of the initial state. </span>

<span class="sd">	Equivalently, these are also the infinite-time expectation values after a sudden quench from a </span>
<span class="sd">	Hamiltonian :math:`H_1` to a Hamiltonian :math:`H_2`. Let us label the two eigenbases by</span>

<span class="sd">	.. math::</span>
<span class="sd">		V_1=\\{|n_1\\rangle: H_1|n_1\\rangle=E_1|n_1\\rangle\\} \\qquad V_2=\\{|n_2\\rangle: H_2|n_2\\rangle=E_2|n_2\\rangle\\}</span>

<span class="sd">	See eg. `arXiv:1509.06411 &lt;https://arxiv.org/abs/1509.06411&gt;`_ for the physical definition of Diagonal Ensemble.</span>
<span class="sd">	</span>
<span class="sd">	**Note: All expectation values depend statistically on the symmetry block used via the available number of </span>
<span class="sd">	states, due to the generic system-size dependence!**</span>

<span class="sd">	Examples</span>
<span class="sd">	--------</span>

<span class="sd">	We prepare a quantum system in an eigenstate :math:`\\psi_1` of the Hamiltonian :math:`H_1=\\sum_j hS^x_j + g S^z_j`.</span>
<span class="sd">	At time :math:`t=0` we quench to the Hamiltonian :math:`H_2=\\sum_j JS^z_{j+1}S^z_j+ hS^x_j + g S^z_j`, and evolve</span>
<span class="sd">	the initial state :math:`\\psi_1` with it. We compute the infinite-time (i.e. Diagonal Ensemble) expectation value of the Hamiltonian :math:`H_1`, and</span>
<span class="sd">	it&#39;s infinite-time temporal fluctuations :math:`\\delta_t\\mathcal{O}^\\psi_d` (see above for the definition). </span>

<span class="sd">	.. literalinclude:: ../../doc_examples/diag_ens-example.py</span>
<span class="sd">		:linenos:</span>
<span class="sd">		:language: python</span>
<span class="sd">		:lines: 7-</span>

<span class="sd">	Parameters</span>
<span class="sd">	-----------</span>
<span class="sd">	N : int</span>
<span class="sd">		System size/dimension (e.g. number of sites).</span>
<span class="sd">	system_state : {array_like,dict}</span>
<span class="sd">		State of the quantum system; can be either of:</span>

<span class="sd">			* numpy.ndarray: pure state, shape = (Ns,) or (,Ns).</span>
<span class="sd">			* numpy.ndarray: density matrix (DM), shape = (Ns,Ns).</span>
<span class="sd">			* dict: mixed DM as dictionary `{&quot;V1&quot;:V1, &quot;E1&quot;:E1, &quot;f&quot;:f, &quot;f_args&quot;:f_args, &quot;V1_state&quot;:int, &quot;f_norm&quot;:`False`}` to define a diagonal DM in the basis :math:`V_1` of the Hamiltonian :math:`H_1`. The meaning of the keys (keys CANNOT be chosen arbitrarily) is as flollows:</span>

<span class="sd">				* numpy.ndarray: `V1` (required) contains eigenbasis of :math:`H_1` in the columns.</span>
<span class="sd">				* numpy.ndarray: `E1` (required) eigenenergies of :math:`H_1`.</span>
<span class="sd">				* :obj:`function` &#39;f&#39; (optional) is a function which represents the distribution of the spectrum </span>
<span class="sd">					used to define the mixed DM of the initial state (see example). </span>

<span class="sd">					Default is a thermal distribution with inverse temperature `beta`: </span>
<span class="sd">					`f = lambda E,beta: numpy.exp(-beta*(E - E[0]) )`. </span>
<span class="sd">				* list(float): `f_args` (required) list of arguments for function `f`. </span>

<span class="sd">					If `f` is not defined, by default we have :math:`f(E)=\\exp(-\\beta(E - E_\\mathrm{GS}))`, </span>
<span class="sd">					and `f_args=[beta]` specifies the inverse temeprature.</span>
<span class="sd">				* list(int): `V1_state` (optional) is a list of integers to specify arbitrary states of `V1` </span>
<span class="sd">					whose pure expectations are also returned.</span>
<span class="sd">				* bool: `f_norm` (optional). If set to `False` the mixed DM built from `f` is NOT normalised</span>
<span class="sd">					and the norm is returned under the key `f_norm`. </span>

<span class="sd">					Use this option if you need to average your results over multiple symmetry blocks, which</span>
<span class="sd">					require a separate normalisations. </span>

<span class="sd">				If this option is specified, then all Diagonal Ensemble quantities are averaged over </span>
<span class="sd">				the energy distribution :math:`f(E_1,f\\_args)`:</span>
<span class="sd">				</span>
<span class="sd">				.. math::</span>
<span class="sd">					\\overline{\\mathcal{M}_d} = \\frac{1}{Z_f}\\sum_{n_1} f(E_{n_1},f\\_args)\\mathcal{M}^{n_1}_d, \\qquad \\mathcal{M}^{\\psi}_d = \\langle\\mathcal{O}\\rangle_d^\\psi,\\ \\delta_q\\mathcal{O}^\\psi_d,\\ \\delta_t\\mathcal{O}^\\psi_d,\\ S_d^\\psi,\\ S_\\mathrm{rdm}^\\psi</span>
<span class="sd">	V2 : numpy.ndarray</span>
<span class="sd">		Contains the basis of the Hamiltonian :math:`H_2` in the columns.</span>
<span class="sd">	E2 : numpy.ndarray</span>
<span class="sd">		Contains the eigenenergies corresponding to the eigenstates in `V2`. </span>

<span class="sd">		This variable is only used to check for degeneracies, in which case the function is NOT expected to</span>
<span class="sd">		produce correct resultsand raises an error.</span>
<span class="sd">	rho_d : bool, optional </span>
<span class="sd">		When set to `True`, returns the Diagonal ensemble DM. Default is `False`.</span>

<span class="sd">		Adds the key &quot;rho_d&quot; to output. </span>

<span class="sd">		For example, if `system_state` is the pure state :math:`|\\psi\\rangle`:</span>
<span class="sd">		</span>
<span class="sd">		.. math::</span>
<span class="sd">			\\rho_d^\\psi = \\sum_{n_2} \\left|\\langle\\psi|n_2\\rangle\\right|^2\\left|n_2\\rangle\\langle n_2\\right| = \\sum_{n_2} \\left(\\rho_d^\\psi\\right)_{n_2n_2}\\left|n_2\\rangle\\langle n_2\\right| </span>
<span class="sd">	Obs : :obj:, optional</span>
<span class="sd">		Hermitian matrix of the same shape as `V2`, to calculate the Diagonal ensemble expectation value of. </span>
<span class="sd">		</span>
<span class="sd">		Adds the key &quot;Obs&quot; to output. Can be of type `numpy.ndarray` or an instance of the `hamiltonian` class.</span>

<span class="sd">		For example, if `system_state` is the pure state :math:`|\\psi\\rangle`:</span>
<span class="sd">  		</span>
<span class="sd">  		.. math::</span>
<span class="sd">  			\\langle\\mathcal{O}\\rangle_d^\\psi = \\lim_{T\\to\\infty}\\frac{1}{T}\\int_0^T\\mathrm{d}t \\frac{1}{N}\\langle\\psi\\left|\\mathcal{O}(t)\\right|\\psi\\rangle = \\frac{1}{N}\\sum_{n_2}\\left(\\rho_d^\\psi\\right)_{n_2n_2} \\langle n_2\\left|\\mathcal{O}\\right|n_2\\rangle</span>
<span class="sd">	delta_q_Obs : bool, optional</span>
<span class="sd">		QUANTUM fluctuations of the expectation of `Obs` at infinite times. Requires `Obs`. Calculates</span>
<span class="sd">		temporal fluctuations `delta_t_Obs` for along the way (see above).</span>
<span class="sd">		</span>
<span class="sd">		Adds keys &quot;delta_q_Obs&quot; and &quot;delta_t_Obs&quot; to output.</span>

<span class="sd">		For example, if `system_state` is the pure state :math:`|\\psi\\rangle`:</span>
<span class="sd">  		</span>
<span class="sd">  		.. math::</span>
<span class="sd">  			\\delta_q\\mathcal{O}^\\psi_d = \\frac{1}{N}\\sqrt{\\lim_{T\\to\\infty}\\frac{1}{T}\\int_0^T\\mathrm{d}t \\langle\\psi\\left| \\mathcal{O}(t)\\right| \\psi\\rangle^2 - \\langle\\mathcal{O}\\rangle_d^2}= \\frac{1}{N}\\sqrt{ \\sum_{n_2\\neq m_2} \\left(\\rho_d^\\psi\\right)_{n_2n_2} [\\mathcal{O}]^2_{n_2m_2} \\left(\\rho_d^\\psi\\right)_{m_2m_2} }</span>
<span class="sd">	delta_t_Obs : bool, optional</span>
<span class="sd">		TEMPORAL fluctuations around infinite-time expectation of `Obs`. Requires `Obs`. </span>
<span class="sd">		</span>
<span class="sd">		Adds the key &quot;delta_t_Obs&quot; to output.</span>

<span class="sd">		For example, if `system_state` is the pure state :math:`|\\psi\\rangle`:</span>

<span class="sd">		.. math::  </span>
<span class="sd">  			\\delta_t\\mathcal{O}^\\psi_d = \\frac{1}{N}\\sqrt{ \\lim_{T\\to\\infty}\\frac{1}{T}\\int_0^T\\mathrm{d}t \\langle\\psi\\left|[\\mathcal{O}(t)]^2\\right|\\psi\\rangle - \\langle\\psi\\left|\\mathcal{O}(t)\\right|\\psi\\rangle^2} = \\frac{1}{N}\\sqrt{\\langle\\mathcal{O}^2\\rangle_d - \\langle\\mathcal{O}\\rangle_d^2 - \\left(\\delta_q\\mathcal{O}^\\psi_d\\right)^2 }</span>
<span class="sd">	alpha : float, optional</span>
<span class="sd">		Renyi :math:`alpha` parameter. Default is `alpha = 1.0`.</span>
<span class="sd">	Sd_Renyi : bool, optional</span>
<span class="sd">		Computes the DIAGONAL Renyi entropy in the basis of :math:`H_2`. \</span>

<span class="sd">		The default Renyi parameter is `alpha=1.0` (see below). \</span>

<span class="sd">		Adds the key &quot;Sd_Renyi&quot; to output.\</span>

<span class="sd">		For example, if `system_state` is the pure state :math:`|\\psi\\rangle`:</span>
<span class="sd">  		</span>
<span class="sd">  		.. math::</span>
<span class="sd">  			S_d^\\psi = \\frac{1}{1-\\alpha}\\log\\mathrm{tr}\\left(\\rho_d^\\psi\\right)^\\alpha</span>
<span class="sd">	Srdm_Renyi : bool, optional</span>
<span class="sd">		Computes ENTANGLEMENT Renyi entropy of a subsystem (see `Srdm_args` for subsystem definition). </span>

<span class="sd">		Requires passing the (otherwise optional) argument `Srdm_args` (see below).</span>
<span class="sd">		</span>
<span class="sd">		The default Renyi parameter is `alpha=1.0` (see below). </span>

<span class="sd">		Adds the key &quot;Srdm_Renyi&quot; to output.</span>

<span class="sd">		For example, if `system_state` is the pure state :math:`|\\psi\\rangle` </span>
<span class="sd">		(see also notation in documentation of `ent_entropy`):</span>
<span class="sd">  		</span>
<span class="sd">  		.. math::</span>
<span class="sd">  			S_\\mathrm{rdm}^\\psi = \\frac{1}{1-\\alpha}\\log \\mathrm{tr}_{A} \\left( \\mathrm{tr}_{A^c} \\rho_d^\\psi \\right)^\\alpha </span>
<span class="sd">	Srdm_args : dict, semi-optional</span>
<span class="sd">		Dictionary which contains all arguments required for the computation of the entanglement Renyi </span>
<span class="sd">		entropy. Required when `Srdm_Renyi = True`. The following keys are allowed/supported:</span>

<span class="sd">			* &quot;basis&quot;: obj(basis), required</span>
<span class="sd">				Basis used to build `system_state` in. Must be an instance of the `basis` class. </span>
<span class="sd">			* &quot;chain_subsys&quot; : list, optional </span>
<span class="sd">				Lattice sites to specify the chain subsystem of interest. Default is:</span>

<span class="sd">				-- [0,1,...,N/2-1,N/2] for `spin_basis_1d`, `fermion_basis_1d`, `boson_basis_1d`.</span>

<span class="sd">				-- [0,1,...,N-1,N] for `photon_basis`.</span>
<span class="sd">	density : bool, optional </span>
<span class="sd">		If set to `True`, all observables are normalised by the system size `N`, except</span>
<span class="sd">		for the `Srdm_Renyi` which is normalised by the subsystem size, i.e. by the length of `chain_subsys`.</span>
<span class="sd">		Default is &#39;True&#39;.</span>

<span class="sd">	Returns</span>
<span class="sd">	-------- </span>
<span class="sd">	dict</span>
<span class="sd">		The following keys of the output are possible, depending on the choice of flags:</span>

<span class="sd">		* &quot;rho_d&quot;: density matrix of Diagonal Ensemble.</span>
<span class="sd">		* &quot;Obs...&quot;: infinite-time expectation of observable `Obs`.</span>
<span class="sd">		* &quot;delta_t_Obs...&quot;: infinite-time temporal fluctuations of `Obs`.</span>
<span class="sd">		* &quot;delta_q_Obs...&quot;: infinite-time quantum fluctuations of `Obs`.</span>
<span class="sd">		* &quot;Sd...&quot; (&quot;Sd_Renyi...&quot; for :math:`\\alpha\\neq1.0`): Renyi diagonal entropy of density matrix of `rho_d` with parameter `alpha`.</span>
<span class="sd">		* &quot;Srdm...&quot; (&quot;Srdm_Renyi...&quot; for :math:`\\alpha\\neq1.0`): Renyi entanglement entropy of reduced DM of`rho_d` (`rho_d` is a mixed DM itself) with parameter `alpha`.</span>

<span class="sd">		Replace &quot;...&quot; above by &#39;pure&#39;, &#39;thermal&#39; or &#39;mixed&#39; depending on input parameters.</span>

<span class="sd">	</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="c1"># check if E2 are all unique</span>
	<span class="n">E2</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">E2</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span> <span class="n">_np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">E2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1E3</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">E2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot use function &#39;diag_ensemble&#39; with dengenerate e&#39;values &#39;E2&#39;!&quot;</span><span class="p">)</span>
	<span class="k">del</span> <span class="n">E2</span>

	<span class="k">if</span> <span class="n">N</span> <span class="ow">and</span> <span class="ow">not</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;System size &#39;N&#39; must be a positive integer!&quot;</span><span class="p">)</span>


	<span class="c1"># various checks</span>
	<span class="k">if</span> <span class="n">delta_t_Obs</span> <span class="ow">or</span> <span class="n">delta_q_Obs</span><span class="p">:</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">Obs</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expecting to parse the observable &#39;Obs&#39; whenever &#39;delta_t_Obs = True&#39; or &#39;delta_q_Obs = True&#39;!&quot;</span><span class="p">)</span>
	
	<span class="c1"># calculate diagonal ensemble DM</span>

	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">system_state</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span> <span class="c1"># initial state either pure or DM</span>

		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">system_state</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># pure state</span>
			<span class="n">istate</span> <span class="o">=</span> <span class="s1">&#39;pure&#39;</span>
			<span class="c1"># calculate diag ensemble DM</span>
			<span class="n">rho</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">system_state</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V2</span><span class="p">)</span> <span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">;</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">system_state</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># DM</span>
			<span class="n">istate</span> <span class="o">=</span> <span class="s1">&#39;DM&#39;</span>
			<span class="c1"># calculate diag ensemble DM</span>
			<span class="n">rho</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span> <span class="s1">&#39;ij,ji-&gt;i&#39;</span><span class="p">,</span> <span class="n">V2</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">system_state</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V2</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">real</span>

	
	<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">system_state</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span> <span class="c1"># initial state is defined by diag distr</span>
		<span class="c1"># define allowed keys</span>
		<span class="n">key_strings</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;V1&#39;</span><span class="p">,</span><span class="s1">&#39;E1&#39;</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">,</span><span class="s1">&#39;f_args&#39;</span><span class="p">,</span><span class="s1">&#39;V1_state&#39;</span><span class="p">,</span><span class="s1">&#39;f_norm&#39;</span><span class="p">]</span>

		<span class="k">if</span> <span class="s1">&#39;V1&#39;</span> <span class="ow">in</span> <span class="n">system_state</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">V1</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;V1&#39;</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Dictionary &#39;system_state&#39; must contain states matrix &#39;V1&#39;!&quot;</span><span class="p">)</span>
		
		<span class="k">if</span> <span class="s1">&#39;E1&#39;</span> <span class="ow">in</span> <span class="n">system_state</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">E1</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span> <span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;E1&#39;</span><span class="p">]</span> <span class="p">)</span>
			<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">E1</span><span class="p">)</span><span class="o">!=</span><span class="n">E1</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expecting ordered vector of energies &#39;E1&#39;!&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Dictionary &#39;system_state&#39; must contain eigenvalues vector &#39;E1&#39;!&quot;</span><span class="p">)</span>
		
		<span class="k">if</span> <span class="s1">&#39;f_args&#39;</span> <span class="ow">in</span> <span class="n">system_state</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">f_args</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;f_args&#39;</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Dictionary &#39;system_state&#39; must contain function arguments list &#39;f_args&#39;!&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="s1">&#39;V1_state&#39;</span> <span class="ow">in</span> <span class="n">system_state</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">V1_state</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;V1_state&#39;</span><span class="p">]</span>

		<span class="c1"># check if user has passed the distribution &#39;f&#39;</span>
		<span class="k">if</span> <span class="s1">&#39;f&#39;</span> <span class="ow">in</span> <span class="n">system_state</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">f</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span>
			<span class="n">istate</span> <span class="o">=</span> <span class="s1">&#39;mixed&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">istate</span> <span class="o">=</span> <span class="s1">&#39;thermal&#39;</span>
			<span class="c1"># define Gibbs distribution (up to normalisation)</span>
			<span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">E1</span><span class="p">,</span><span class="n">beta</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span><span class="o">*</span><span class="p">(</span><span class="n">E1</span> <span class="o">-</span> <span class="n">E1</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

		<span class="k">if</span> <span class="s1">&#39;f_norm&#39;</span> <span class="ow">in</span> <span class="n">system_state</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">f_norm</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;f_norm&#39;</span><span class="p">]</span>
			<span class="n">f_norms</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">f_args</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">f_args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">f_norm</span> <span class="o">=</span> <span class="kc">True</span>

		<span class="k">if</span> <span class="s1">&#39;V1_state&#39;</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">V1_state</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expecting an integer value for variable &#39;V1_state&#39;!&quot;</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">V1_state</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">V1_state</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">E1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Value &#39;V1_state&#39; violates &#39;0 &lt;= V1_state &lt;= len(E1)-1&#39;!&quot;</span><span class="p">)</span>

		<span class="c1"># define diagonal (in V1) mixed DM</span>
		
		<span class="n">rho_mixed</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">E1</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">f_args</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">f_args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="p">)</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
			<span class="k">if</span> <span class="n">f_norm</span><span class="p">:</span>
				<span class="n">rho_mixed</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">E1</span><span class="p">,</span><span class="n">arg</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">E1</span><span class="p">,</span><span class="n">arg</span><span class="p">))</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">rho_mixed</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">E1</span><span class="p">,</span><span class="n">arg</span><span class="p">)</span>
				<span class="c1"># calculate normalisation</span>
				<span class="n">f_norms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">E1</span><span class="p">,</span><span class="n">arg</span><span class="p">))</span>


		<span class="c1"># calculate diag ensemble DM for each state in V1</span>
		<span class="n">rho</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">V2</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V1</span><span class="p">)</span> <span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="c1"># components are (n,psi)</span>

		<span class="k">del</span> <span class="n">V1</span><span class="p">,</span> <span class="n">E1</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Wrong variable type for &#39;system_state&#39;! E.g., use np.ndarray.&quot;</span><span class="p">)</span>


	<span class="c1"># clear up memory</span>
	<span class="k">del</span> <span class="n">system_state</span>

	<span class="c1"># add floating point number to zero elements</span>
	<span class="n">rho</span><span class="p">[</span><span class="n">rho</span><span class="o">&lt;=</span><span class="mf">1E-16</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">rho</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>


	<span class="c1"># prepare observables</span>
	<span class="k">if</span> <span class="n">Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">delta_t_Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">delta_q_Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">delta_t_Obs</span> <span class="ow">or</span> <span class="n">delta_q_Obs</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
			<span class="c1"># diagonal matrix elements of Obs^2 in the basis V2</span>
			<span class="c1">#delta_t_Obs =  _np.einsum( &#39;ij,ji-&gt;i&#39;, V2.T.conj(), Obs.dot(Obs).dot(V2) ).real</span>
			<span class="n">Obs</span> <span class="o">=</span> <span class="n">V2</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">Obs</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V2</span><span class="p">)</span> <span class="p">)</span>
			<span class="n">delta_t_Obs</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">Obs</span><span class="p">)</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">delta_t_Obs</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">delta_q_Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
				<span class="n">delta_q_Obs</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Obs</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Obs</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
			<span class="n">Obs</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Obs</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
			
		<span class="k">elif</span> <span class="n">Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
			<span class="c1"># diagonal matrix elements of Obs in the basis V2</span>
			<span class="n">Obs</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ji-&gt;i&#39;</span><span class="p">,</span> <span class="n">V2</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">Obs</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V2</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">real</span>

		
	<span class="k">if</span> <span class="n">Srdm_Renyi</span><span class="p">:</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		# calculate singular values of columns of V2</span>
<span class="sd">		v, _, N_A = _reshape_as_subsys({&quot;V_states&quot;:V2},**Srdm_args)</span>

<span class="sd">		U, lmbda, _ = _npla.svd(v, full_matrices=False)</span>
<span class="sd">		if istate in [&#39;mixed&#39;,&#39;thermal&#39;]:</span>
<span class="sd">			DM_chain_subsys = _np.einsum(&#39;nm,nij,nj,nkj-&gt;mik&#39;,rho,U,lmbda**2,U.conj() )</span>
<span class="sd">		else:</span>
<span class="sd">			DM_chain_subsys = _np.einsum(&#39;n,nij,nj,nkj-&gt;ik&#39;,rho,U,lmbda**2,U.conj() )</span>
<span class="sd">			</span>
<span class="sd">		Srdm_Renyi = _npla.eigvalsh(DM_chain_subsys).T # components (i,psi)</span>
<span class="sd">		del v, U, DM_chain_subsys</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">basis</span><span class="o">=</span><span class="n">Srdm_args</span><span class="p">[</span><span class="s1">&#39;basis&#39;</span><span class="p">]</span>
		<span class="n">partial_tr_args</span><span class="o">=</span><span class="n">Srdm_args</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="k">del</span> <span class="n">partial_tr_args</span><span class="p">[</span><span class="s1">&#39;basis&#39;</span><span class="p">]</span>
		<span class="k">if</span> <span class="s1">&#39;sub_sys_A&#39;</span> <span class="ow">in</span> <span class="n">Srdm_args</span><span class="p">:</span>
			<span class="n">sub_sys_A</span> <span class="o">=</span> <span class="n">Srdm_args</span><span class="p">[</span><span class="s1">&#39;sub_sys_A&#39;</span><span class="p">]</span>
			<span class="k">del</span> <span class="n">partial_tr_args</span><span class="p">[</span><span class="s1">&#39;sub_sys_A&#39;</span><span class="p">]</span>

		<span class="k">elif</span> <span class="s1">&#39;chain_subsys&#39;</span> <span class="ow">in</span> <span class="n">Srdm_args</span><span class="p">:</span>
			<span class="n">sub_sys_A</span> <span class="o">=</span> <span class="n">Srdm_args</span><span class="p">[</span><span class="s1">&#39;chain_subsys&#39;</span><span class="p">]</span>
			<span class="k">del</span> <span class="n">partial_tr_args</span><span class="p">[</span><span class="s1">&#39;chain_subsys&#39;</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">sub_sys_A</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">L</span><span class="o">//</span><span class="mi">2</span><span class="p">))</span>
		<span class="n">N_A</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">sub_sys_A</span><span class="p">)</span>
		<span class="n">rdm_A</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">partial_trace</span><span class="p">(</span><span class="n">V2</span><span class="p">,</span><span class="n">sub_sys_A</span><span class="o">=</span><span class="n">sub_sys_A</span><span class="p">,</span><span class="n">enforce_pure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="o">**</span><span class="n">partial_tr_args</span><span class="p">)</span>
		<span class="n">rdm</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;n...,nij-&gt;...ij&#39;</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">rdm_A</span><span class="p">)</span>
	
		<span class="n">Srdm_Renyi</span> <span class="o">=</span> <span class="n">_npla</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">rdm</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c1"># components (i,psi) </span>
		
	<span class="c1"># clear up memory</span>
	<span class="k">del</span> <span class="n">V2</span>

	<span class="c1"># calculate diag expectation values</span>
	<span class="n">Expt_Diag</span> <span class="o">=</span> <span class="n">_inf_time_obs</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="n">istate</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span><span class="n">Obs</span><span class="o">=</span><span class="n">Obs</span><span class="p">,</span><span class="n">delta_t_Obs</span><span class="o">=</span><span class="n">delta_t_Obs</span><span class="p">,</span><span class="n">delta_q_Obs</span><span class="o">=</span><span class="n">delta_q_Obs</span><span class="p">,</span><span class="n">Srdm_Renyi</span><span class="o">=</span><span class="n">Srdm_Renyi</span><span class="p">,</span><span class="n">Sd_Renyi</span><span class="o">=</span><span class="n">Sd_Renyi</span><span class="p">)</span>
	

	<span class="n">Expt_Diag_Vstate</span><span class="o">=</span><span class="p">{}</span>
	<span class="c1"># compute density</span>
	<span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">Expt_Diag</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
		<span class="k">if</span> <span class="n">density</span><span class="p">:</span>
			<span class="k">if</span> <span class="s1">&#39;rdm&#39;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
				<span class="n">value</span> <span class="o">/=</span> <span class="n">N_A</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">value</span> <span class="o">/=</span> <span class="n">N</span>

		<span class="n">Expt_Diag</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
		<span class="c1"># calculate thermal expectations</span>
		<span class="k">if</span> <span class="n">istate</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mixed&#39;</span><span class="p">,</span><span class="s1">&#39;thermal&#39;</span><span class="p">]:</span>
			<span class="n">Expt_Diag_state</span> <span class="o">=</span> <span class="p">{}</span>
			<span class="n">Expt_Diag</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rho_mixed</span><span class="p">)</span>
			<span class="c1"># if &#39;GS&#39; option is passed save GS value</span>
			<span class="k">if</span> <span class="s1">&#39;V1_state&#39;</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
				<span class="n">state_key</span> <span class="o">=</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">istate</span><span class="p">)]</span><span class="o">+</span><span class="s1">&#39;V1_state&#39;</span>
				<span class="n">Expt_Diag_Vstate</span><span class="p">[</span><span class="n">state_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">V1_state</span><span class="p">]</span>
			<span class="c1"># merge state and mixed dicts</span>
			<span class="n">Expt_Diag</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Expt_Diag_state</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">istate</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mixed&#39;</span><span class="p">,</span><span class="s1">&#39;thermal&#39;</span><span class="p">]:</span>
		<span class="k">if</span> <span class="n">f_norm</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
			<span class="n">Expt_Diag</span><span class="p">[</span><span class="s1">&#39;f_norm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_norms</span>
		<span class="k">if</span> <span class="s1">&#39;V1_state&#39;</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
			<span class="n">Expt_Diag</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Expt_Diag_Vstate</span><span class="p">)</span>
			
	<span class="c1"># return diag ensemble density matrix if requested</span>
	<span class="k">if</span> <span class="n">rho_d</span><span class="p">:</span>
		<span class="k">if</span> <span class="s1">&#39;V1_state&#39;</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
			<span class="n">Expt_Diag</span><span class="p">[</span><span class="s1">&#39;rho_d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[:,</span><span class="n">V1_state</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">Expt_Diag</span><span class="p">[</span><span class="s1">&#39;rho_d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span>


	<span class="k">return</span> <span class="n">Expt_Diag</span></div>

<div class="viewcode-block" id="obs_vs_time"><a class="viewcode-back" href="../../../generated/quspin.tools.measurements.obs_vs_time.html#quspin.tools.measurements.obs_vs_time">[docs]</a><span class="k">def</span> <span class="nf">obs_vs_time</span><span class="p">(</span><span class="n">psi_t</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">Obs_dict</span><span class="p">,</span><span class="n">return_state</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">Sent_args</span><span class="o">=</span><span class="p">{},</span><span class="n">enforce_pure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Calculates expectation value of observable(s) as a function of time in a time-dependent state.</span>
<span class="sd">	</span>
<span class="sd">	This function computes the expectation of a time-dependent state :math:`|\\psi(t)\\rangle` in a time-dependent observable :math:`\\mathcal{O}(t)`. </span>
<span class="sd">	It automatically handles the cases where only the state or only the observable is time-dependent.</span>

<span class="sd">	.. math::</span>
<span class="sd">		\\langle\\psi(t)|\\mathcal{O}(t)|\\psi(t)\\rangle</span>

<span class="sd">	Examples</span>
<span class="sd">	--------</span>

<span class="sd">	The following example shows how to calculate the expectation values :math:`\\langle\\psi_1(t)|H_1|\\psi_1(t)\\rangle`</span>
<span class="sd">	and :math:`\\langle\\psi_1(t)|H_2|\\psi_1(t)\\rangle`.</span>

<span class="sd">	The initial state is an eigenstate of :math:`H_1=\\sum_j hS^x_j + g S^z_j`. The time evolution is done </span>
<span class="sd">	under :math:`H_2=\\sum_j JS^z_{j+1}S^z_j+ hS^x_j + g S^z_j`.</span>

<span class="sd">	.. literalinclude:: ../../doc_examples/obs_vs_time-example.py</span>
<span class="sd">		:linenos:</span>
<span class="sd">		:language: python</span>
<span class="sd">		:lines: 7-</span>

<span class="sd">	Parameters</span>
<span class="sd">	-----------</span>
<span class="sd">	psi_t : {tuple,aray_like,generator}</span>
<span class="sd">		Time-dependent state data; can be either one of:</span>

<span class="sd">		* tuple: `psi_t = (psi, E, V)` where </span>
<span class="sd">			-- np.ndarray: initial state `psi`.</span>

<span class="sd">			-- np.ndarray: unitary matrix `V`, contains all eigenstates of the Hamiltonian :math:`H`.</span>

<span class="sd">			-- np.ndarray: real-valued array `E`, contains all eigenvalues of the Hamiltonian :math:`H`. </span>
<span class="sd">			   The order of the eigenvalues must correspond to the order of the columns of `V`.</span>

<span class="sd">			Use this option when the initial state is evolved with a time-INdependent Hamiltonian :math:`H`.</span>
<span class="sd">		* numpy.ndarray: array with the states evaluated at `times` stored in the last dimension. </span>
<span class="sd">			Can be 2D (single time-dependent state) or 3D (many time-dependent states or </span>
<span class="sd">			time-dep mixed density matrix, see `enforce_pure` argument.)</span>

<span class="sd">			Use this option for PARALLELISATION over many states.</span>
<span class="sd">		* obj: generator which generates the states.</span>

<span class="sd">	Obs_dict : dict</span>
<span class="sd">		Dictionary with observables (e.g. `hamiltonian objects`) stored in the `values`, to calculate </span>
<span class="sd">		their time-dependent expectation value. Dictionary `keys` are chosen by user.</span>
<span class="sd">	times : numpy.ndarray</span>
<span class="sd">		Vector of times to evaluate the expectation values at. This is important for time-dependent observables. </span>
<span class="sd">	return_state : bool, optional</span>
<span class="sd">		If set to `True`, adds key &quot;psi_time&quot; to output. The columns of the array</span>
<span class="sd">		contain the state vector at the `times` which specifies the column index. Default is `False`, unless</span>
<span class="sd">		`Sent_args` is nonempty.</span>
<span class="sd">	Srdm_args : dict, optional </span>
<span class="sd">		If nonempty, this dictionary contains the arguments necessary for the calculation of the entanglement</span>
<span class="sd">		entropy. The following key is required:</span>
<span class="sd">			</span>
<span class="sd">			* &quot;basis&quot;: the basis used to build `system_state` in. Must be an instance of the `basis` class.</span>

<span class="sd">		The user can choose optional arguments according to those provided in the function method </span>
<span class="sd">		`basis.ent_entropy()` of the `basis` class [preferred], or the function `ent_entropy()`. </span>

<span class="sd">		If only the `basis` is passed, the default parameters of `basis.ent_entropy()` are assumed.</span>
<span class="sd">	enforce_pure : bool, optional</span>
<span class="sd">		Flag to enforce pure state expectation values in the case that `psi_t` is an array of pure states</span>
<span class="sd">		in the columns. (`psi_t` will otherwise be interpreted as a mixed density matrix).</span>
<span class="sd">	verbose : bool, optional</span>
<span class="sd">		If set to `True`, displays a message at every `times` step after the calculation is complete.</span>
<span class="sd">		Default is `False`.</span>

<span class="sd">	Returns</span>
<span class="sd">	--------</span>
<span class="sd">	dict</span>
<span class="sd">		The following keys of the output are possible, depending on the choice of flags:</span>
<span class="sd">		</span>
<span class="sd">			* &quot;custom_name&quot;: for each key of `Obs_dict`, the time-dependent expectation of the </span>
<span class="sd">				corresponding observable `Obs_dict[key]` is calculated and returned under the user-defined name</span>
<span class="sd">				for the observable.</span>
<span class="sd">			* &quot;psi_t&quot;: (optional) returns time-dependent state, if `return_state=True` or `Srdm_args` is nonempty.</span>
<span class="sd">			* &quot;Sent_time&quot;: (optional) returns dictionary with keys corresponding to the entanglement entropy </span>
<span class="sd">				calculation for each time in `times`. Can have more keys than just &quot;Sent_A&quot;, e.g. if the reduced</span>
<span class="sd">				DM was also requested (toggled through `Srdm_args`.)</span>

<span class="sd">	&quot;&quot;&quot;</span>
	<span class="kn">from</span> <span class="nn">..operators</span> <span class="kn">import</span> <span class="n">ishamiltonian</span><span class="p">,</span><span class="n">hamiltonian</span>
	
	<span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Expt_time&#39;</span><span class="p">]</span>
	
	<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Obs_dict</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Obs_dict must be a dictionary.&quot;</span><span class="p">)</span>

	<span class="n">num_Obs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Obs_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

	<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">Obs_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">ishamiltonian</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
			<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">_sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">val</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">in</span> <span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="n">_np</span><span class="o">.</span><span class="n">matrix</span><span class="p">]):</span>
				<span class="n">val</span> <span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

			<span class="n">Obs_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">hamiltonian</span><span class="p">([</span><span class="n">val</span><span class="p">],[],</span><span class="n">dtype</span><span class="o">=</span><span class="n">val</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>


	<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">psi_t</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>

		<span class="n">psi</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">psi_t</span>

		<span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;V&#39; must be a square matrix&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Number of eigenstates in &#39;V&#39; must equal number of eigenvalues in &#39;E&#39;!&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Variables &#39;psi&#39; and &#39;E&#39; must have the same dimension!&quot;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">Obs</span> <span class="ow">in</span> <span class="n">Obs_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
			<span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Obs</span><span class="o">.</span><span class="n">_shape</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;shapes of &#39;V1&#39; and &#39;Obs&#39; must be equal!&quot;</span><span class="p">)</span>
			

		<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
			<span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Variable &#39;times&#39; must be a array or iter like object!&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">return_state</span><span class="p">:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;psi_t&quot;</span><span class="p">)</span>

		
		<span class="c1"># get iterator over time dependent state (see function above)</span>
		<span class="k">if</span> <span class="n">return_state</span><span class="p">:</span>
			<span class="n">psi_t</span> <span class="o">=</span> <span class="n">ED_state_vs_time</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">iterate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">psi_t</span> <span class="o">=</span> <span class="n">ED_state_vs_time</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">iterate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


	<span class="k">elif</span> <span class="n">psi_t</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">in</span> <span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="n">_np</span><span class="o">.</span><span class="n">matrix</span><span class="p">]:</span>


		<span class="k">for</span> <span class="n">Obs</span> <span class="ow">in</span> <span class="n">Obs_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
			<span class="k">if</span> <span class="n">psi_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Obs</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;states must be in columns of input matrix.&quot;</span><span class="p">)</span>


		<span class="k">if</span> <span class="n">return_state</span><span class="p">:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;psi_t&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">return_state</span><span class="o">=</span><span class="kc">True</span> <span class="c1"># set to True to use einsum but do not return state</span>

	<span class="k">elif</span> <span class="n">_isgenerator</span><span class="p">(</span><span class="n">psi_t</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">return_state</span><span class="p">:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;psi_t&quot;</span><span class="p">)</span>
			<span class="n">psi_t_list</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">psi</span> <span class="ow">in</span> <span class="n">psi_t</span><span class="p">:</span>
				<span class="n">psi_t_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>

			<span class="n">psi_t</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">psi_t_list</span><span class="p">))</span>

			<span class="k">for</span> <span class="n">Obs</span> <span class="ow">in</span> <span class="n">Obs_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="k">if</span> <span class="n">psi_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Obs</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;states must be in columns of input matrix.&quot;</span><span class="p">)</span>

	<span class="k">else</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input not recognized&quot;</span><span class="p">)</span>
	
	<span class="c1"># calculate observables and Sent</span>
	<span class="n">Expt_time</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">calc_Sent</span> <span class="o">=</span> <span class="kc">False</span>
	
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Sent_args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
		<span class="n">Sent_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">Sent_args</span><span class="p">)</span>
		<span class="n">basis</span> <span class="o">=</span> <span class="n">Sent_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;basis&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">basis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sent_args requires &#39;basis&#39; for calculation&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">_isbasis</span><span class="p">(</span><span class="n">basis</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;basis&#39; object must be a proper basis object&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="p">(</span><span class="s2">&quot;chain_subsys&quot;</span> <span class="ow">in</span> <span class="n">Sent_args</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;DM&quot;</span> <span class="ow">in</span> <span class="n">Sent_args</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;svd_return_vec&quot;</span> <span class="ow">in</span> <span class="n">Sent_args</span><span class="p">):</span>
			<span class="n">calc_ent_entropy</span> <span class="o">=</span> <span class="n">ent_entropy</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">calc_ent_entropy</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">ent_entropy</span>
			<span class="k">del</span> <span class="n">Sent_args</span><span class="p">[</span><span class="s2">&quot;basis&quot;</span><span class="p">]</span>

		<span class="n">calc_Sent</span> <span class="o">=</span> <span class="kc">True</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Sent_time&quot;</span><span class="p">)</span>
	
	<span class="k">if</span> <span class="n">return_state</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">Obs</span> <span class="ow">in</span> <span class="n">Obs_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="n">Expt_time</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">Obs</span><span class="o">.</span><span class="n">expt_value</span><span class="p">(</span><span class="n">psi_t</span><span class="p">,</span><span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">enforce_pure</span><span class="o">=</span><span class="n">enforce_pure</span><span class="p">)</span>
			
		<span class="c1"># calculate entanglement entropy if requested	</span>
		<span class="k">if</span> <span class="n">calc_Sent</span><span class="p">:</span>
			<span class="n">Sent_time</span> <span class="o">=</span> <span class="n">calc_ent_entropy</span><span class="p">(</span><span class="n">psi_t</span><span class="p">,</span><span class="o">**</span><span class="n">Sent_args</span><span class="p">)</span>


	<span class="k">else</span><span class="p">:</span>
		<span class="n">psi</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">psi_t</span><span class="p">)</span> <span class="c1"># get first state from iterator.</span>
		<span class="c1"># do first calculations of loop</span>

		<span class="n">time</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

		<span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">Obs</span> <span class="ow">in</span> <span class="n">Obs_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">Obs</span><span class="o">.</span><span class="n">expt_value</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">Expt_time</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span>



		<span class="c1"># get initial dictionary from ent_entropy function</span>
		<span class="c1"># use this to set up dictionary for the rest of calculation.</span>
		<span class="k">if</span> <span class="n">calc_Sent</span><span class="p">:</span>
			<span class="n">Sent_time</span> <span class="o">=</span> <span class="n">calc_ent_entropy</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="o">**</span><span class="n">Sent_args</span><span class="p">)</span>

			<span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="n">Sent_time</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
				<span class="n">val</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
				<span class="n">dtype</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">dtype</span>
				<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),)</span> <span class="o">+</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span>
				<span class="n">Sent_time</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
				<span class="n">Sent_time</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

		<span class="c1"># loop over psi generator</span>
		<span class="k">for</span> <span class="n">m</span><span class="p">,</span><span class="n">psi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">psi_t</span><span class="p">):</span>

			<span class="n">time</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

			<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;obs_vs_time integrated to t=</span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>

			<span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">Obs</span> <span class="ow">in</span> <span class="n">Obs_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
				<span class="n">Expt_time</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Obs</span><span class="o">.</span><span class="n">expt_value</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

			<span class="k">if</span> <span class="n">calc_Sent</span><span class="p">:</span>
				<span class="n">Sent_time_update</span> <span class="o">=</span> <span class="n">calc_ent_entropy</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="o">**</span><span class="n">Sent_args</span><span class="p">)</span>
				<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">Sent_time</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
					<span class="n">Sent_time</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sent_time_update</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

		
	<span class="n">return_dict</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;Expt_time&#39;</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="n">Expt_time</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
				<span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">return_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span>

	<span class="k">return</span> <span class="n">return_dict</span></div>

<span class="c1">##### private functions</span>

<span class="k">def</span> <span class="nf">_ent_entropy</span><span class="p">(</span><span class="n">system_state</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">chain_subsys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">density</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">subsys_ordering</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">DM</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">svd_return_vec</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span><span class="kc">False</span><span class="p">,</span><span class="kc">False</span><span class="p">]):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	This function calculates the entanglement entropy of a lattice quantum subsystem based on the Singular Value Decomposition (svd). The entanglement entropy is NORMALISED by the size of the</span>
<span class="sd">	reduced subsystem. </span>

<span class="sd">	RETURNS:	dictionary with keys:</span>

<span class="sd">	&#39;Sent&#39;: entanglement entropy.</span>

<span class="sd">	&#39;DM_chain_subsys&#39;: (optional) reduced density matrix of chain subsystem.</span>

<span class="sd">	&#39;DM_other_subsys&#39;: (optional) reduced density matrix of the complement subsystem.</span>

<span class="sd">	&#39;U&#39;: (optional) svd U matrix</span>

<span class="sd">	&#39;V&#39;: (optional) svd V matrix</span>

<span class="sd">	&#39;lmbda&#39;: (optional) svd singular values</span>

<span class="sd">	--- arguments ---</span>

<span class="sd">	system_state: (required) the state of the quantum system. Can be a:</span>

<span class="sd">				-- pure state [numpy array of shape (Ns,)].</span>

<span class="sd">				-- density matrix (DM) [numpy array of shape (Ns,Ns)].</span>

<span class="sd">				-- diagonal DM [dictionary {&#39;V_rho&#39;: V_rho, &#39;rho_d&#39;: rho_d} containing the diagonal DM</span>
<span class="sd">					rho_d [numpy array of shape (Ns,)] and its eigenbasis in the columns of V_rho</span>
<span class="sd">					[numpy arary of shape (Ns,Ns)]. The keys CANNOT be chosen arbitrarily.].</span>

<span class="sd">				-- a collection of states [dictionary {&#39;V_states&#39;:V_states}] containing the states</span>
<span class="sd">					in the columns of V_states [shape (Ns,Nvecs)]</span>

<span class="sd">	basis: (required) the basis used to build &#39;system_state&#39;. Must be an instance of &#39;photon_basis&#39;,</span>
<span class="sd">				&#39;spin_basis_1d&#39;, &#39;fermion_basis_1d&#39;, &#39;boson_basis_1d&#39;. </span>

<span class="sd">	chain_subsys: (optional) a list of lattice sites to specify the chain subsystem. Default is</span>

<span class="sd">				-- [0,1,...,N/2-1,N/2] for &#39;spin_basis_1d&#39;, &#39;fermion_basis_1d&#39;, &#39;boson_basis_1d&#39;.</span>

<span class="sd">				-- [0,1,...,N-1,N] for &#39;photon_basis&#39;.</span>

<span class="sd">	DM: (optional) String to enable the calculation of the reduced density matrix. Available options are</span>

<span class="sd">				-- &#39;chain_subsys&#39;: calculates the reduced DM of the subsystem &#39;chain_subsys&#39; and</span>
<span class="sd">					returns it under the key &#39;DM_chain_subsys&#39;.</span>

<span class="sd">				-- &#39;other_subsys&#39;: calculates the reduced DM of the complement of &#39;chain_subsys&#39; and</span>
<span class="sd">					returns it under the key &#39;DM_other_subsys&#39;.</span>

<span class="sd">				-- &#39;both&#39;: calculates and returns both density matrices as defined above.</span>

<span class="sd">				Default is &#39;False&#39;. 	</span>

<span class="sd">	alpha: (optional) Renyi alpha parameter. Default is &#39;1.0&#39;. When alpha is different from unity,</span>
<span class="sd">				the _entropy keys have attached &#39;_Renyi&#39; to their label.</span>

<span class="sd">	density: (optional) if set to &#39;True&#39;, the entanglement _entropy is normalised by the size of the</span>
<span class="sd">				subsystem [i.e., by the length of &#39;chain_subsys&#39;]. Detault is &#39;False&#39;.</span>

<span class="sd">	subsys_ordering: (optional) if set to &#39;True&#39;, &#39;chain_subsys&#39; is being ordered. Default is &#39;True&#39;.</span>

<span class="sd">	svd_return_vec: (optional) list of three booleans to return Singular Value Decomposition (svd) </span>
<span class="sd">				parameters:</span>

<span class="sd">				-- [True, . , . ] returns the svd matrix &#39;U&#39;.</span>

<span class="sd">				-- [ . ,True, . ] returns the singular values &#39;lmbda&#39;.</span>

<span class="sd">				-- [ . , . ,True] returns the svd matrix &#39;V&#39;.</span>

<span class="sd">				Any combination of the above is possible. Default is [False,False,False].</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="c1"># initiate variables</span>
	<span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Sent&quot;</span><span class="p">]</span>

	<span class="k">if</span> <span class="n">DM</span><span class="o">==</span><span class="s1">&#39;chain_subsys&#39;</span><span class="p">:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DM_chain_subsys&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">svd_return_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">DM</span><span class="o">==</span><span class="s1">&#39;other_subsys&#39;</span><span class="p">:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DM_other_subsys&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">svd_return_vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">DM</span><span class="o">==</span><span class="s1">&#39;both&#39;</span><span class="p">:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DM_chain_subsys&quot;</span><span class="p">)</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DM_other_subsys&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">svd_return_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">svd_return_vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">DM</span> <span class="ow">and</span> <span class="n">DM</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;chain_subsys&#39;</span><span class="p">,</span><span class="s1">&#39;other_subsys&#39;</span><span class="p">,</span><span class="s1">&#39;both&#39;</span><span class="p">]:</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unexpected keyword argument for &#39;DM&#39;!&quot;</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">svd_return_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;lmbda&#39;</span><span class="p">)</span>
	
	

	<span class="c1"># calculate reshaped system_state</span>
	<span class="n">v</span><span class="p">,</span> <span class="n">rho_d</span><span class="p">,</span> <span class="n">N_A</span> <span class="o">=</span> <span class="n">_reshape_as_subsys</span><span class="p">(</span><span class="n">system_state</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">chain_subsys</span><span class="o">=</span><span class="n">chain_subsys</span><span class="p">,</span><span class="n">subsys_ordering</span><span class="o">=</span><span class="n">subsys_ordering</span><span class="p">)</span>
	<span class="k">del</span> <span class="n">system_state</span>
	
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	This function has room for improvement: if only DM is requested, it can be obtained by</span>
<span class="sd">	DM_chain_subsys = v[0].dot(v[0].T)</span>
<span class="sd">	DM_other_subsys = v[0].T.dot(v[0])</span>
<span class="sd">	so there&#39;s NO NEED for an SVD!!!</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="k">if</span> <span class="n">DM</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">rho_d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rho_d</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="p">(</span><span class="mi">1</span><span class="p">,):</span> <span class="c1"># need DM for Sent of a mixed system_state</span>
			<span class="n">U</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_npla</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">DM_chain_subsys</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;n,nij,nj,nkj-&gt;ik&#39;</span><span class="p">,</span><span class="n">rho_d</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">lmbda</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">U</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="p">)</span>
			<span class="n">DM</span><span class="o">=</span><span class="s1">&#39;chain_subsys&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">lmbda</span> <span class="o">=</span> <span class="n">_npla</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">DM</span> <span class="o">==</span> <span class="s1">&#39;chain_subsys&#39;</span><span class="p">:</span>
		<span class="n">U</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_npla</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">rho_d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">DM_chain_subsys</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;n,nij,nj,nkj-&gt;ik&#39;</span><span class="p">,</span><span class="n">rho_d</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">lmbda</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">U</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">DM_chain_subsys</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;nij,nj,nkj-&gt;nik&#39;</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">lmbda</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">U</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="p">)</span>
	<span class="k">elif</span> <span class="n">DM</span> <span class="o">==</span> <span class="s1">&#39;other_subsys&#39;</span><span class="p">:</span>
		<span class="n">_</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">_npla</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">rho_d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">DM_other_subsys</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;n,nji,nj,njk-&gt;ik&#39;</span><span class="p">,</span><span class="n">rho_d</span><span class="p">,</span><span class="n">V</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">lmbda</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">V</span> <span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">DM_other_subsys</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;nji,nj,njk-&gt;nik&#39;</span><span class="p">,</span><span class="n">V</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">lmbda</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">V</span> <span class="p">)</span>
	<span class="k">elif</span> <span class="n">DM</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
		<span class="n">U</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">_npla</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">rho_d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">DM_chain_subsys</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;n,nij,nj,nkj-&gt;ik&#39;</span><span class="p">,</span><span class="n">rho_d</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">lmbda</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">U</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="p">)</span>
			<span class="n">DM_other_subsys</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;n,nji,nj,njk-&gt;ik&#39;</span><span class="p">,</span><span class="n">rho_d</span><span class="p">,</span><span class="n">V</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">lmbda</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">V</span> <span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">DM_chain_subsys</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;nij,nj,nkj-&gt;nik&#39;</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">lmbda</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">U</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="p">)</span>
			<span class="n">DM_other_subsys</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;nji,nj,njk-&gt;nik&#39;</span><span class="p">,</span><span class="n">V</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">lmbda</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">V</span> <span class="p">)</span>

	<span class="k">del</span> <span class="n">v</span>

	<span class="c1"># calculate singular values of reduced DM and the corresponding probabilities</span>
	<span class="k">if</span> <span class="n">rho_d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rho_d</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
		<span class="c1"># diagonalise reduced DM</span>
		<span class="k">if</span> <span class="n">DM</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;chain_subsys&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">]:</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">_npla</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">DM_chain_subsys</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">DM</span> <span class="o">==</span> <span class="s1">&#39;other_subsys&#39;</span><span class="p">:</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">_npla</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">DM_other_subsys</span><span class="p">)</span>
			
		<span class="k">if</span> <span class="n">svd_return_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># if lmdas requested by user</span>
			<span class="n">lmbda</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
	<span class="k">else</span><span class="p">:</span><span class="c1"># calculate probabilities</span>
		<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">lmbda</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
	
	<span class="c1"># add floating point number to zero elements</span>
	<span class="n">p</span><span class="p">[</span><span class="n">p</span><span class="o">&lt;=</span><span class="mf">1E-16</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
		
	<span class="c1"># calculate entanglement _entropy of &#39;system_state&#39;</span>
	<span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
		<span class="n">Sent</span> <span class="o">=</span> <span class="o">-</span><span class="n">_np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">p</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">Sent</span> <span class="o">=</span>  <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">alpha</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
	
	<span class="k">if</span> <span class="n">density</span><span class="p">:</span>
		<span class="n">Sent</span> <span class="o">/=</span> <span class="n">N_A</span>

	<span class="c1"># store variables to dictionar</span>
	<span class="n">return_dict</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
		<span class="n">return_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span>

	<span class="k">return</span> <span class="n">return_dict</span>

<span class="k">def</span> <span class="nf">_reshape_as_subsys</span><span class="p">(</span><span class="n">system_state</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">chain_subsys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">subsys_ordering</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	This function reshapes an input state (or matrix with &#39;Nstates&#39; initial states) into an array of</span>
<span class="sd">	the shape (Nstates,Ns_subsys,Ns_other) with &#39;Ns_subsys&#39; and &#39;Ns_other&#39; the Hilbert space dimensions</span>
<span class="sd">	of the subsystem and its complement, respectively.</span>

<span class="sd">	RETURNS:	reshaped state, </span>
<span class="sd">				vector with eigenvalues of the DM associated with the initial state, </span>
<span class="sd">				subsystem size</span>

<span class="sd">	--- arguments ---</span>

<span class="sd">	system_state: (required) the state of the quantum system. Can be a:</span>

<span class="sd">				-- pure state [numpy array of shape (1,) or (,1)].</span>

<span class="sd">				-- density matrix (DM) [numpy array of shape (1,1)].</span>

<span class="sd">				-- diagonal DM [dictionary {&#39;V_rho&#39;: V_rho, &#39;rho_d&#39;: rho_d} containing the diagonal DM</span>
<span class="sd">					rho_d [numpy array of shape (1,) or (,1)] and its eigenbasis in the columns of V_rho</span>
<span class="sd">					[numpy arary of shape (1,1)]. The keys are CANNOT be chosen arbitrarily. &#39;rho_d&#39;</span>
<span class="sd">					can be &#39;None&#39;, but needs to always be passed.</span>

<span class="sd">				-- a collection of states [dictionary {&#39;V_states&#39;:V_states}] containing the states</span>
<span class="sd">					in the columns of V_states [shape (Ns,Nvecs)]</span>

<span class="sd">	basis: (required) the basis used to build &#39;system_state&#39;. Must be an instance of &#39;photon_basis&#39;,</span>
<span class="sd">				&#39;spin_basis_1d&#39;, &#39;fermion_basis_1d&#39;, &#39;boson_basis_1d&#39;. </span>

<span class="sd">	chain_subsys: (optional) a list of lattice sites to specify the chain subsystem. Default is</span>

<span class="sd">				-- [0,1,...,N/2-1,N/2] for &#39;spin_basis_1d&#39;, &#39;fermion_basis_1d&#39;, &#39;boson_basis_1d&#39;.</span>

<span class="sd">				-- [0,1,...,N-1,N] for &#39;photon_basis&#39;. </span>

<span class="sd">	subsys_ordering: (optional) if set to &#39;True&#39;, &#39;chain_subsys&#39; is being ordered. Default is &#39;True&#39;. </span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="k">try</span><span class="p">:</span>
		<span class="n">N</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">N</span>
	<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
		<span class="n">N</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">particle_N</span>



	<span class="k">if</span> <span class="n">chain_subsys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">chain_subsys</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">)]</span>
		<span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expecting iterable for for &#39;chain_subsys&#39;!&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expecting a nonempty iterable for &#39;chain_subsys&#39;!&quot;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;subsys&#39; must be contain nonnegative numbers!&quot;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">max</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;subsys&#39; contains sites exceeding the total lattice site number!&quot;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;subsys&#39; cannot contain repeating site indices!&quot;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">_np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">),</span><span class="n">_np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">chain_subsys</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;subsys&#39; must iterable of integers with values in {0,...,L-1}!&quot;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">subsys_ordering</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">))</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">)</span><span class="o">!=</span><span class="n">chain_subsys</span><span class="p">:</span>
				<span class="c1"># if chain subsys is def with unordered sites, order them</span>
				<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&#39;subsys&#39; </span><span class="si">{}</span><span class="s2"> contains non-ordered sites. &#39;subsys&#39; re-ordered! To change default set &#39;subsys_ordering = False&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">),</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
				<span class="n">chain_subsys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">)</span>

	
	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">system_state</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
		<span class="n">keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">system_state</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
		<span class="k">if</span> <span class="n">keys</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;V_rho&#39;</span><span class="p">,</span><span class="s1">&#39;rho_d&#39;</span><span class="p">]):</span>
			<span class="n">istate</span> <span class="o">=</span> <span class="s1">&#39;DM&#39;</span>
			<span class="c1"># define initial state</span>
			<span class="n">rho_d</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;rho_d&#39;</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">rho_d</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">,):</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting a 1d array &#39;rho_d&#39; of size </span><span class="si">{}</span><span class="s2">!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">))</span>
			<span class="k">elif</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rho_d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting positive eigenvalues for &#39;rho_d&#39;!&quot;</span><span class="p">)</span>
			<span class="n">psi</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;V_rho&#39;</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">psi</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting a 2d array &#39;V_rho&#39; of size (</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">)!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">))</span>
		<span class="k">elif</span> <span class="n">keys</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;V_states&#39;</span><span class="p">]):</span>
			<span class="n">istate</span> <span class="o">=</span> <span class="s1">&#39;pure&#39;</span>
			<span class="n">rho_d</span> <span class="o">=</span> <span class="kc">None</span>
			<span class="n">psi</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;V_states&#39;</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting dictionary with keys [&#39;V_rho&#39;,&#39;rho_d&#39;] or [&#39;V_states&#39;]&quot;</span><span class="p">)</span>


		<span class="k">if</span> <span class="n">_sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">system_state</span><span class="p">):</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;ent_entropy function only handles numpy.ndarrays, sparse matrix will be comverted to dense matrix.&quot;</span><span class="p">,</span><span class="ne">UserWarning</span><span class="p">,</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
			<span class="n">system_state</span> <span class="o">=</span> <span class="n">system_state</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">system_state</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">system_state</span> <span class="o">=</span> <span class="n">system_state</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

		<span class="k">elif</span> <span class="n">system_state</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">not</span> <span class="ow">in</span>  <span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="n">_np</span><span class="o">.</span><span class="n">matrix</span><span class="p">]:</span>
			<span class="n">system_state</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">system_state</span><span class="p">)</span>


		<span class="k">if</span> <span class="n">psi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting ndim == 2 for V_states.&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">psi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;V_states shape </span><span class="si">{0}</span><span class="s2"> not compatible with basis size: </span><span class="si">{1}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">))</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">_sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">system_state</span><span class="p">):</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;ent_entropy function only handles numpy.ndarrays, sparse matrix will be comverted to dense matrix.&quot;</span><span class="p">,</span><span class="ne">UserWarning</span><span class="p">,</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
			<span class="n">system_state</span> <span class="o">=</span> <span class="n">system_state</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">system_state</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">system_state</span> <span class="o">=</span> <span class="n">system_state</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
		<span class="k">elif</span> <span class="n">system_state</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">not</span> <span class="ow">in</span>  <span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="n">_np</span><span class="o">.</span><span class="n">matrix</span><span class="p">]:</span>
			<span class="n">system_state</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">system_state</span><span class="p">)</span>

			


		<span class="k">if</span> <span class="n">system_state</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># pure state</span>
			<span class="n">istate</span> <span class="o">=</span> <span class="s1">&#39;pure&#39;</span>
			<span class="c1"># define initial state</span>
			<span class="n">psi</span> <span class="o">=</span> <span class="n">system_state</span>
			<span class="n">rho_d</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,(</span><span class="mi">1</span><span class="p">,))</span>
		<span class="k">elif</span> <span class="n">system_state</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># DM</span>
			<span class="k">if</span> <span class="n">system_state</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">system_state</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting square array for Density Matrix.&quot;</span><span class="p">)</span>
			<span class="n">istate</span> <span class="o">=</span> <span class="s1">&#39;DM&#39;</span>
			<span class="c1"># diagonalise DM</span>
			<span class="n">rho_d</span><span class="p">,</span> <span class="n">psi</span> <span class="o">=</span> <span class="n">_la</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">system_state</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">rho_d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">rho_d</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1E3</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">rho_d</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting DM to have positive spectrum&quot;</span><span class="p">)</span>
			<span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">_np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rho_d</span><span class="p">)</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1E3</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">rho_d</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting eigenvalues of DM to sum to unity!&quot;</span><span class="p">)</span>
			<span class="n">rho_d</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rho_d</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">psi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;V_states shape </span><span class="si">{0}</span><span class="s2"> not compatible with basis size: </span><span class="si">{1}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">))</span>			
			


	<span class="c1"># clear up memory</span>
	<span class="k">del</span> <span class="n">system_state</span>


	<span class="c1"># define number of participating states in &#39;system_state&#39;</span>
	<span class="n">Ns</span> <span class="o">=</span> <span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">,]</span><span class="o">.</span><span class="n">size</span>

	<span class="k">if</span> <span class="n">basis</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">[:</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;spin&#39;</span><span class="p">,</span><span class="s1">&#39;boson&#39;</span><span class="p">,</span><span class="s1">&#39;fermion&#39;</span><span class="p">]:</span>

		<span class="c1"># set chain subsys if not defined</span>
		<span class="k">if</span> <span class="n">chain_subsys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
			<span class="n">chain_subsys</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span> <span class="p">))</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Subsystem contains sites </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">),</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
		
	
		<span class="c1"># re-write the state in the initial basis</span>
		<span class="k">if</span> <span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="o">&lt;</span><span class="n">basis</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="n">N</span><span class="p">:</span>
			<span class="n">psi</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">get_vec</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
			
		<span class="c1">#calculate H-space dimensions of the subsystem and the system</span>
		<span class="n">N_A</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">)</span>
		<span class="n">Ns_A</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="n">N_A</span>
		<span class="c1"># define lattice indices putting the subsystem to the left</span>
		<span class="n">system</span> <span class="o">=</span> <span class="n">chain_subsys</span><span class="p">[:]</span>
		<span class="p">[</span><span class="n">system</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">chain_subsys</span><span class="p">]</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		the algorithm for the entanglement _entropy of an arbitrary subsystem goes as follows </span>
<span class="sd">		for spin-1/2 and fermions [replace the onsite DOF (=2 below) with # states per site (basis.sps)]:</span>

<span class="sd">		1) the initial state psi has 2^N entries corresponding to the spin-z configs</span>
<span class="sd">		2) reshape psi into a 2x2x2x2x...x2 dimensional array (N products in total). Call this array v.</span>
<span class="sd">		3) v should satisfy the property that v[0,1,0,0,0,1,...,1,0], total of N entries, should give the entry of psi </span>
<span class="sd">		   along the the spin-z basis vector direction (0,1,0,0,0,1,...,1,0). This ensures a correspondence of the v-indices</span>
<span class="sd">		   (and thus the psi-entries) to the N lattice sites.</span>
<span class="sd">		4) fix the lattice sites that define the subsystem N_A, and reshuffle the array v according to this: e.g. if the </span>
<span class="sd">	 	   subsystem consistes of sites (k,l) then v should be reshuffled such that v[(k,l), (all other sites)]</span>
<span class="sd">	 	5) reshape v[(k,l), (all other sites)] into a 2D array of dimension ( N_A x N/N_A ) and proceed with the SVD as below  </span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">chain_subsys</span><span class="o">==</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">))):</span>
			<span class="c1"># chain_subsys sites come in consecutive order</span>
			<span class="c1"># define reshape tuple</span>
			<span class="n">reshape_tuple2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ns</span><span class="p">,</span> <span class="n">Ns_A</span><span class="p">,</span> <span class="n">basis</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="n">N</span><span class="o">//</span><span class="n">Ns_A</span><span class="p">)</span>
			<span class="c1"># reshape states</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">reshape_tuple2</span><span class="p">)</span>
			<span class="k">del</span> <span class="n">psi</span>
		<span class="k">else</span><span class="p">:</span> <span class="c1"># if chain_subsys not consecutive or staring site not [0]</span>
			<span class="c1"># performs 2) and 3)</span>
			<span class="c1"># update reshape tuple</span>
			<span class="n">reshape_tuple1</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ns</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">basis</span><span class="o">.</span><span class="n">sps</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>
			<span class="c1"># upadte axes dimensions</span>
			<span class="n">system</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">system</span><span class="p">]</span>
			<span class="n">system</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
			<span class="c1"># reshape states</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">reshape_tuple1</span><span class="p">)</span>
			<span class="k">del</span> <span class="n">psi</span>
			<span class="c1"># performs 4)</span>
			<span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
			<span class="c1"># performs 5)</span>
			<span class="n">reshape_tuple2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ns</span><span class="p">,</span> <span class="n">Ns_A</span><span class="p">,</span> <span class="n">basis</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="n">N</span><span class="o">//</span><span class="n">Ns_A</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">reshape_tuple2</span><span class="p">)</span>
			

	<span class="k">elif</span> <span class="n">basis</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">[:</span><span class="o">-</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;photon&#39;</span><span class="p">:</span>

		<span class="c1"># set chain subsys if not defined; </span>
		<span class="k">if</span> <span class="n">chain_subsys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
			<span class="n">chain_subsys</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span> <span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="p">))</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;subsystem set to the entire chain.&quot;</span><span class="p">,</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>


		<span class="c1">#calculate H-space dimensions of the subsystem and the system</span>
		<span class="n">N_A</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">)</span>
		<span class="n">Ns_A</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="n">N_A</span>

		<span class="c1"># define lattice indices putting the subsystem to the left</span>
		<span class="n">system</span> <span class="o">=</span> <span class="n">chain_subsys</span><span class="p">[:]</span>
		<span class="p">[</span><span class="n">system</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">chain_subsys</span><span class="p">]</span>
		
		<span class="c1"># re-write the state in the initial basis</span>
		<span class="k">if</span> <span class="n">basis</span><span class="o">.</span><span class="n">Nph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># no total particle conservation</span>
			<span class="n">Nph</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">Nph</span>
			<span class="k">if</span> <span class="n">basis</span><span class="o">.</span><span class="n">Ns</span> <span class="o">&lt;</span> <span class="n">photon_Hspace_dim</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="o">.</span><span class="n">Ntot</span><span class="p">,</span><span class="n">basis</span><span class="o">.</span><span class="n">Nph</span><span class="p">):</span> <span class="c1">#chain symmetries present</span>
				<span class="k">if</span> <span class="n">N_A</span><span class="o">!=</span><span class="n">N</span><span class="p">:</span> <span class="c1"># doesn&#39;t make use of chain symmetries</span>
					<span class="n">psi</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">get_vec</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">full_part</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span> <span class="c1"># makes use of symmetries</span>
					<span class="n">Ns_chain</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">chain_Ns</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Ns_chain</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="n">N</span>

		<span class="k">elif</span> <span class="n">basis</span><span class="o">.</span><span class="n">Ntot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># total particle-conservation</span>
			<span class="n">Nph</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">Ntot</span>
			<span class="k">if</span> <span class="n">basis</span><span class="o">.</span><span class="n">Ns</span> <span class="o">&lt;</span> <span class="n">photon_Hspace_dim</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="o">.</span><span class="n">Ntot</span><span class="p">,</span><span class="n">basis</span><span class="o">.</span><span class="n">Nph</span><span class="p">):</span> <span class="c1">#chain symmetries present</span>
				<span class="k">if</span> <span class="n">N_A</span><span class="o">==</span><span class="n">N</span><span class="p">:</span> <span class="c1"># make use of symmetries</span>
					<span class="n">psi</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">get_vec</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">full_part</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
					<span class="n">Ns_chain</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">chain_Ns</span>
				<span class="k">else</span><span class="p">:</span> <span class="c1"># doesn&#39;t make use of symmetries</span>
					<span class="n">psi</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">get_vec</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">full_part</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
					<span class="n">Ns_chain</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="n">N</span>
			<span class="k">else</span><span class="p">:</span> <span class="c1"># no chain symmetries present</span>
				<span class="k">if</span> <span class="n">N_A</span><span class="o">==</span><span class="n">N</span><span class="p">:</span>
					<span class="n">psi</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">get_vec</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">full_part</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">psi</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">get_vec</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">full_part</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
				<span class="n">Ns_chain</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">chain_Ns</span>

		<span class="k">if</span> <span class="n">chain_subsys</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">))):</span> 
			<span class="c1"># chain_subsys sites come in consecutive order or staring site not [0]</span>
			<span class="c1"># define reshape tuple</span>
			<span class="k">if</span> <span class="n">N_A</span><span class="o">==</span><span class="n">N</span><span class="p">:</span> <span class="c1"># chain_subsys equals entire lattice</span>
				<span class="n">reshape_tuple2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ns</span><span class="p">,</span> <span class="n">Ns_chain</span><span class="p">,</span><span class="n">Nph</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span> <span class="c1">#chain_subsys is smaller than entire lattice</span>
				<span class="n">reshape_tuple2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ns</span><span class="p">,</span> <span class="n">Ns_A</span><span class="p">,</span> <span class="n">basis</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">N_A</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Nph</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">reshape_tuple2</span><span class="p">)</span>
			<span class="k">del</span> <span class="n">psi</span>
		<span class="k">else</span><span class="p">:</span> <span class="c1"># if chain_subsys not consecutive</span>
			<span class="c1"># performs 2) and 3)	</span>
			<span class="n">reshape_tuple1</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ns</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">basis</span><span class="o">.</span><span class="n">sps</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span> <span class="o">+</span> <span class="p">(</span><span class="n">Nph</span><span class="o">+</span><span class="mi">1</span><span class="p">,)</span>
			<span class="c1"># upadte axes dimensions</span>
			<span class="n">system</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">system</span><span class="p">]</span>
			<span class="n">system</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
			<span class="c1"># reshape states</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">reshape_tuple1</span><span class="p">)</span>
			<span class="k">del</span> <span class="n">psi</span>
			<span class="c1"># performs 4)</span>
			<span class="n">system</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">system</span><span class="p">))</span>
			<span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
			<span class="c1"># performs 5)</span>
			<span class="n">reshape_tuple2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ns</span><span class="p">,</span> <span class="n">Ns_A</span><span class="p">,</span> <span class="n">basis</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">N_A</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Nph</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">reshape_tuple2</span><span class="p">)</span>
				
	<span class="k">else</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;basis&#39; class </span><span class="si">{}</span><span class="s2"> not supported!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

	<span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="n">rho_d</span><span class="p">,</span> <span class="n">N_A</span>

<span class="k">def</span> <span class="nf">_inf_time_obs</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="n">istate</span><span class="p">,</span><span class="n">Obs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">delta_t_Obs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">delta_q_Obs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">Sd_Renyi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">Srdm_Renyi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	This function calculates various quantities (observables, fluctuations, entropies) written in the</span>
<span class="sd">	diagonal basis of a density matrix &#39;rho&#39;. See also documentation of &#39;Diagonal_Ensemble&#39;. The </span>
<span class="sd">	fuction is vectorised, meaning that &#39;rho&#39; can be an array containing the diagonal density matrices</span>
<span class="sd">	in the columns.</span>

<span class="sd">	RETURNS:	dictionary with keys corresponding to the observables</span>

<span class="sd">	--- variables --- </span>

<span class="sd">	istate: (required) type of initial state. Allowed strings are &#39;pure&#39;, &#39;DM&#39;, &#39;mixed&#39;, &#39;thermal&#39;.</span>

<span class="sd">	Obs: (optional) array of shape (,1) with the diagonal matrix elements of an observable in the basis</span>
<span class="sd">			where the density matrix &#39;rho&#39; is diagonal.</span>

<span class="sd">	delta_t_Obs: (optional) array of shape (1,1) containing the off-diagonal matrix elements of the </span>
<span class="sd">			square of an observable, to evaluate the infinite-time temporal fluctuations</span>

<span class="sd">	delta_q_Obs: (optional) array containing the diagonal elements (Obs^2)_{nn} - (Obs_{nn})^2 in the </span>
<span class="sd">			basis where the DM &#39;rho&#39; is diagonal. Evaluates the infinite-time quantum fluctuations.</span>

<span class="sd">	Sd_Renyi: (optional) when set to &#39;True&#39;, returns the key with diagonal density matrix of &#39;rho&#39;.</span>

<span class="sd">	Srdm_Renyi: (optional) (i,n) array containing the singular values of the i-th state of the eigenbasis</span>
<span class="sd">			of &#39;rho&#39;. Returns the key with the entanglement _entropy of &#39;rho&#39; reduced to a subsystem of</span>
<span class="sd">			given choice at infinite times.</span>

<span class="sd">	alpha: (optional) Renyi _entropy parameter. </span>
<span class="sd">	&quot;&quot;&quot;</span> 

	<span class="c1"># if Obs or deltaObs: parse V2</span>

	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="nb">complex</span><span class="p">)</span> <span class="ow">or</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Renyi parameter &#39;alpha&#39; must be real-valued and non-negative!&quot;</span><span class="p">)</span>

	<span class="n">istates</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;pure&#39;</span><span class="p">,</span> <span class="s1">&#39;DM&#39;</span><span class="p">,</span><span class="s1">&#39;mixed&#39;</span><span class="p">,</span><span class="s1">&#39;thermal&#39;</span><span class="p">]</span>
	<span class="k">if</span> <span class="n">istate</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">istates</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Uknown type &#39;istate&#39; encountered! Try </span><span class="si">{}</span><span class="s2">!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">istates</span><span class="p">))</span>

	<span class="c1"># initiate observables dict</span>
	<span class="n">variables</span> <span class="o">=</span> <span class="p">[]</span>


	<span class="k">if</span> <span class="n">Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Obs_&quot;</span><span class="o">+</span><span class="n">istate</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">delta_t_Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;delta_t_Obs_&quot;</span><span class="o">+</span><span class="n">istate</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">delta_q_Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;delta_q_Obs_&quot;</span><span class="o">+</span><span class="n">istate</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">Sd_Renyi</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Sd_&quot;</span><span class="o">+</span><span class="n">istate</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Sd_Renyi_&quot;</span><span class="o">+</span><span class="n">istate</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">Srdm_Renyi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Srdm_&quot;</span><span class="o">+</span><span class="n">istate</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Srdm_Renyi_&quot;</span><span class="o">+</span><span class="n">istate</span><span class="p">)</span>


	<span class="c1">#################################################################</span>
	<span class="c1"># calculate diag ens value of Obs</span>
	<span class="k">if</span> <span class="n">Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
		<span class="n">Obs_d</span> <span class="o">=</span> <span class="n">Obs</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>


	<span class="c1"># calculate diag ens value of Obs fluctuations</span>
	<span class="k">if</span> <span class="n">delta_t_Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
		<span class="n">delta_t_Obs_d</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;j...,jk,k...-&gt;...&#39;</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">delta_t_Obs</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>

		<span class="c1"># calculate diag ens value of Obs fluctuations</span>
		<span class="k">if</span> <span class="n">delta_q_Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
			<span class="n">delta_q_Obs_d</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;j...,j-&gt;...&#39;</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">delta_q_Obs</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">delta_t_Obs_d</span> <span class="o">-</span> <span class="n">Obs_d</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>

		<span class="n">delta_t_Obs_d</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">delta_t_Obs_d</span> <span class="p">)</span>

		
	<span class="c1"># calculate Shannon _entropy for the distribution p</span>
	<span class="k">def</span> <span class="nf">_entropy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">alpha</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; </span>
<span class="sd">		This function calculates the Renyi _entropy of the distribution p with parameter alpha.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
			<span class="c1">#warnings.warn(&quot;Renyi _entropy equals von Neumann _entropy.&quot;, UserWarning,stacklevel=4)</span>
			<span class="n">S</span> <span class="o">=</span> <span class="o">-</span> <span class="n">_np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">S</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">alpha</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
			
		<span class="k">return</span> <span class="n">S</span>

	<span class="c1"># calculate diag ens ent _entropy in post-quench basis</span>
	<span class="k">if</span> <span class="n">Srdm_Renyi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
		<span class="c1"># calculate effective diagonal singular values, \lambda_i^{(n)} = Srdm_Renyi</span>
		<span class="c1">#rho_ent = (Srdm_Renyi**2).dot(rho) # has components (i,psi)</span>
		<span class="n">rho_ent</span> <span class="o">=</span> <span class="n">Srdm_Renyi</span> <span class="c1"># has components (i,psi)</span>
		<span class="n">Srdm_Renyi_d</span> <span class="o">=</span> <span class="n">_entropy</span><span class="p">(</span><span class="n">rho_ent</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>

		
	<span class="c1"># calculate diag ens _entropy in post-quench basis</span>
	<span class="k">if</span> <span class="n">Sd_Renyi</span><span class="p">:</span>
		<span class="n">Sd_Renyi_d</span> <span class="o">=</span> <span class="n">_entropy</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>
		

	<span class="c1"># define return dict</span>
	<span class="n">return_dict</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>

		<span class="n">j</span><span class="o">=</span><span class="n">i</span>
		<span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mf">1.0</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;Srdm&quot;</span> <span class="ow">in</span> <span class="n">i</span> <span class="ow">or</span> <span class="s1">&#39;Sd&#39;</span> <span class="ow">in</span> <span class="n">i</span><span class="p">):</span>
			<span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">istate</span><span class="p">,</span><span class="s1">&#39;Renyi_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">istate</span><span class="p">))</span>

		<span class="n">return_dict</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">i</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">istate</span><span class="p">)]</span><span class="o">+</span><span class="s1">&#39;d&#39;</span><span class="p">]</span>
	

	<span class="k">return</span> <span class="n">return_dict</span>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">QuSpin 0.3.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">quspin.tools.measurements</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Phillip Weinberg, Markus Schmitt and Marin Bukov.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.4.
    </div>
  </body>
</html>