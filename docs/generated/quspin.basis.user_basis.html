
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-110543543-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <title>quspin.basis.user_basis &#8212; QuSpin 0.3.6 documentation</title>
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../static/classic.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../static/documentation_options.js"></script>
    <script src="../static/jquery.js"></script>
    <script src="../static/underscore.js"></script>
    <script src="../static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="quspin.basis.tensor_basis" href="quspin.basis.tensor_basis.html" />
    <link rel="prev" title="quspin.basis.spinful_fermion_basis_general" href="quspin.basis.spinful_fermion_basis_general.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="quspin.basis.tensor_basis.html" title="quspin.basis.tensor_basis"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="quspin.basis.spinful_fermion_basis_general.html" title="quspin.basis.spinful_fermion_basis_general"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">QuSpin 0.3.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../basis.html" accesskey="U">Basis module (<code class="xref py py-mod docutils literal notranslate"><span class="pre">quspin.basis</span></code>)</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">quspin.basis.user_basis</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <style> .red {color:#ff0000; font-weight:bold; font-style:italic; } </style>
<style> .green {color:#00b200; font-weight:bold; font-style:italic; } </style><div class="section" id="quspin-basis-user-basis">
<h1>quspin.basis.user_basis<a class="headerlink" href="#quspin-basis-user-basis" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt id="quspin.basis.user_basis">
<em class="property">class </em><code class="sig-prename descclassname">quspin.basis.</code><code class="sig-name descname">user_basis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">basis_dtype</span></em>, <em class="sig-param"><span class="n">N</span></em>, <em class="sig-param"><span class="n">op_dict</span></em>, <em class="sig-param"><span class="n">sps</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">pcon_dict</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pre_check_state</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">allowed_ops</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">parallel</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">Ns_block_est</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">_make_basis</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">block_order</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">noncommuting_bits</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">_Np</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">blocks</span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/quspin/basis/basis_general/base_user.html#user_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quspin.basis.user_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">quspin.basis.basis_general.base_general.basis_general</span></code></p>
<p>Constructs basis for USER-DEFINED functionality of a basis object.</p>
<p>The <cite>user_basis</cite> unveils the inner workings of QuSpin. This is the most advanced usage of the package, and requires some understanding of python,
the <cite>numba</cite> package used to interface QuSpin’s underlying cpp code with python, and some experience with bitwise operations to manipulate integers.</p>
<p>Since we believe that the users will benefit from a more detailed discussion on how the <cite>user_basis</cite> is intended to work, we also provide a detailed
tutorial: <a class="reference internal" href="../user_basis.html#user-basis-label"><span class="std std-ref">A tutorial on QuSpin’s user_basis</span></a>, which covers the general concepts and provides six complete examples of various complexity.</p>
<p class="rubric">Examples</p>
<p>The following example shows how to use the <cite>user_basis</cite> class to construct the Hamiltonian</p>
<div class="math notranslate nohighlight">
\[H = \sum_j P_{j-1}\sigma^x_j P_{j+1},\quad P_j = |\downarrow_j\rangle\langle\downarrow_j|\]</div>
<p>using translation and reflection symmetry. The projector operator <span class="math notranslate nohighlight">\(P_j\)</span>, which only allows a spin-up state in the basis to be preceded and succeeded by a spin-down,
is incorporated by constructing the corresponding <cite>user_basis</cite> object. One can then just build the Hamiltonian <span class="math notranslate nohighlight">\(H=\sum_j\sigma^x_j\)</span> in the
constrained Hilbert space.</p>
<p>More examples (including explanations of the class methods and attributes) can be found at: <a class="reference internal" href="../user_basis.html#user-basis-label"><span class="std std-ref">A tutorial on QuSpin’s user_basis</span></a>.</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">quspin.operators</span> <span class="kn">import</span> <span class="n">hamiltonian</span>
<span class="kn">from</span> <span class="nn">quspin.basis.user</span> <span class="kn">import</span> <span class="n">user_basis</span> <span class="c1"># Hilbert space user basis</span>
<span class="kn">from</span> <span class="nn">quspin.basis.user</span> <span class="kn">import</span> <span class="n">next_state_sig_32</span><span class="p">,</span><span class="n">pre_check_state_sig_32</span><span class="p">,</span><span class="n">op_sig_32</span><span class="p">,</span><span class="n">map_sig_32</span> <span class="c1"># user_basis dtypes</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">carray</span><span class="p">,</span><span class="n">cfunc</span> <span class="c1"># numba helper functions</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">uint32</span><span class="p">,</span><span class="n">int32</span> <span class="c1"># numba data types</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="c1">#</span>
<span class="n">N</span><span class="o">=</span><span class="mi">14</span> <span class="c1"># lattice sites</span>
<span class="c1">#</span>
<span class="c1">######  function to call when applying operators</span>
<span class="nd">@cfunc</span><span class="p">(</span><span class="n">op_sig_32</span><span class="p">,</span> <span class="nb">locals</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">int32</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="n">uint32</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">op</span><span class="p">(</span><span class="n">op_struct_ptr</span><span class="p">,</span><span class="n">op_str</span><span class="p">,</span><span class="n">ind</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="c1"># using struct pointer to pass op_struct_ptr back to C++ see numba Records</span>
    <span class="n">op_struct</span> <span class="o">=</span> <span class="n">carray</span><span class="p">(</span><span class="n">op_struct_ptr</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">ind</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># convention for QuSpin for mapping from bits to sites.</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">(((</span><span class="n">op_struct</span><span class="o">.</span><span class="n">state</span><span class="o">&gt;&gt;</span><span class="n">ind</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">ind</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">120</span><span class="p">:</span> <span class="c1"># &quot;x&quot; is integer value 120 (check with ord(&quot;x&quot;))</span>
        <span class="n">op_struct</span><span class="o">.</span><span class="n">state</span> <span class="o">^=</span> <span class="n">b</span>
    <span class="k">elif</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">121</span><span class="p">:</span> <span class="c1"># &quot;y&quot; is integer value 120 (check with ord(&quot;y&quot;))</span>
        <span class="n">op_struct</span><span class="o">.</span><span class="n">state</span> <span class="o">^=</span> <span class="n">b</span>
        <span class="n">op_struct</span><span class="o">.</span><span class="n">matrix_ele</span> <span class="o">*=</span> <span class="mf">1.0</span><span class="n">j</span><span class="o">*</span><span class="n">s</span>
    <span class="k">elif</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">122</span><span class="p">:</span> <span class="c1"># &quot;z&quot; is integer value 120 (check with ord(&quot;z&quot;))</span>
        <span class="n">op_struct</span><span class="o">.</span><span class="n">matrix_ele</span> <span class="o">*=</span> <span class="n">s</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">op_struct</span><span class="o">.</span><span class="n">matrix_ele</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1">#</span>
    <span class="k">return</span> <span class="n">err</span>
<span class="c1">#</span>
<span class="n">op_args</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1">######  function to filter states/project states out of the basis</span>
<span class="c1">#</span>
<span class="nd">@cfunc</span><span class="p">(</span><span class="n">pre_check_state_sig_32</span><span class="p">,</span>
    <span class="nb">locals</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">s_shift_left</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">s_shift_right</span><span class="o">=</span><span class="n">uint32</span><span class="p">),</span> <span class="p">)</span>
<span class="k">def</span> <span class="nf">pre_check_state</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; imposes that that a bit with 1 must be preceded and followed by 0,</span>
<span class="sd">    i.e. a particle on a given site must have empty neighboring sites.</span>
<span class="sd">    #</span>
<span class="sd">    Works only for lattices of up to N=32 sites (otherwise, change mask)</span>
<span class="sd">    #</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0xffffffff</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">N</span><span class="p">))</span> <span class="c1"># works for lattices of up to 32 sites</span>
    <span class="c1"># cycle bits left by 1 periodically</span>
    <span class="n">s_shift_left</span> <span class="o">=</span> <span class="p">(((</span><span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span>
    <span class="c1">#</span>
    <span class="c1"># cycle bits right by 1 periodically</span>
    <span class="n">s_shift_right</span> <span class="o">=</span> <span class="p">(((</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span>
    <span class="c1">#</span>
    <span class="k">return</span> <span class="p">(((</span><span class="n">s_shift_right</span><span class="o">|</span><span class="n">s_shift_left</span><span class="p">)</span><span class="o">&amp;</span><span class="n">s</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span>
<span class="c1">#</span>
<span class="n">pre_check_state_args</span><span class="o">=</span><span class="kc">None</span>
<span class="c1">#</span>
<span class="c1">######  define symmetry maps</span>
<span class="c1">#</span>
<span class="nd">@cfunc</span><span class="p">(</span><span class="n">map_sig_32</span><span class="p">,</span>
    <span class="nb">locals</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">shift</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">xmax</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">x1</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">period</span><span class="o">=</span><span class="n">int32</span><span class="p">,</span><span class="n">l</span><span class="o">=</span><span class="n">int32</span><span class="p">,)</span> <span class="p">)</span>
<span class="k">def</span> <span class="nf">translation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">sign_ptr</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; works for all system sizes N. &quot;&quot;&quot;</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># translate state by shift sites</span>
    <span class="n">period</span> <span class="o">=</span> <span class="n">N</span> <span class="c1"># periodicity/cyclicity of translation</span>
    <span class="n">xmax</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1">#</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">shift</span><span class="o">+</span><span class="n">period</span><span class="p">)</span><span class="o">%</span><span class="n">period</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">period</span> <span class="o">-</span> <span class="n">l</span><span class="p">))</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">l</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">xmax</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x2</span> <span class="o">|</span> <span class="n">x1</span><span class="p">)</span>
<span class="n">T_args</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="c1">#</span>
<span class="nd">@cfunc</span><span class="p">(</span><span class="n">map_sig_32</span><span class="p">,</span>
    <span class="nb">locals</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="n">int32</span><span class="p">,)</span> <span class="p">)</span>
<span class="k">def</span> <span class="nf">parity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">sign_ptr</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; works for all system sizes N. &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span> 
    <span class="n">s</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># N-1</span>
    <span class="c1">#</span>
    <span class="n">out</span> <span class="o">^=</span> <span class="p">(</span><span class="n">x</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
    <span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span>
        <span class="n">out</span> <span class="o">^=</span> <span class="p">(</span><span class="n">x</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
        <span class="n">s</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="c1">#</span>
    <span class="n">out</span> <span class="o">&lt;&lt;=</span> <span class="n">s</span>
    <span class="k">return</span> <span class="n">out</span>
<span class="n">P_args</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1">######  construct user_basis </span>
<span class="c1"># define maps dict</span>
<span class="n">maps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">T_block</span><span class="o">=</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">T_args</span><span class="p">),</span> <span class="n">P_block</span><span class="o">=</span><span class="p">(</span><span class="n">parity</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">P_args</span><span class="p">),)</span>
<span class="c1"># define particle conservation and op dicts</span>
<span class="n">op_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span><span class="n">op_args</span><span class="o">=</span><span class="n">op_args</span><span class="p">)</span>
<span class="c1"># define pre_check_state</span>
<span class="n">pre_check_state</span><span class="o">=</span><span class="p">(</span><span class="n">pre_check_state</span><span class="p">,</span><span class="n">pre_check_state_args</span><span class="p">)</span> <span class="c1"># None gives a null pinter to args</span>
<span class="c1"># create user basis</span>
<span class="n">basis</span> <span class="o">=</span> <span class="n">user_basis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">op_dict</span><span class="p">,</span><span class="n">allowed_ops</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="s2">&quot;xyz&quot;</span><span class="p">),</span><span class="n">sps</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="n">pre_check_state</span><span class="o">=</span><span class="n">pre_check_state</span><span class="p">,</span><span class="n">Ns_block_est</span><span class="o">=</span><span class="mi">300000</span><span class="p">,</span><span class="o">**</span><span class="n">maps</span><span class="p">)</span>
<span class="c1"># print basis</span>
<span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1">###### construct Hamiltonian</span>
<span class="c1"># site-coupling lists</span>
<span class="n">h_list</span>  <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="c1"># operator string lists</span>
<span class="n">static</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span><span class="n">h_list</span><span class="p">],]</span>
<span class="c1"># compute Hamiltonian, no checks have been implemented</span>
<span class="n">no_checks</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">check_symm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_pcon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_herm</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">hamiltonian</span><span class="p">(</span><span class="n">static</span><span class="p">,[],</span><span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span><span class="o">**</span><span class="n">no_checks</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<dl class="py method">
<dt id="quspin.basis.user_basis.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">basis_dtype</span></em>, <em class="sig-param"><span class="n">N</span></em>, <em class="sig-param"><span class="n">op_dict</span></em>, <em class="sig-param"><span class="n">sps</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">pcon_dict</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pre_check_state</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">allowed_ops</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">parallel</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">Ns_block_est</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">_make_basis</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">block_order</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">noncommuting_bits</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">_Np</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">blocks</span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/quspin/basis/basis_general/base_user.html#user_basis.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quspin.basis.user_basis.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Intializes the <cite>user_basis_general</cite> object (basis for user defined ED calculations).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>basis_dtype: numpy.dtype object</strong></dt><dd><p>the data type used to represent the states in the basis: must be either uint32 or uint64.</p>
</dd>
<dt><strong>N: int</strong></dt><dd><p>Number of sites.</p>
</dd>
<dt><strong>op_dict: dict</strong></dt><dd><dl class="simple">
<dt>used to define the <cite>basis.Op</cite> function; the dictionary contais the following items:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt><strong>op(op_struct_ptr,op_str,site_ind,N,args): numba.CFunc object</strong></dt><dd><p>This is a numba-compiled function (CFunc) which calculates the matrix elements <span class="math notranslate nohighlight">\(\mathrm{me}\)</span> given a state <span class="math notranslate nohighlight">\(|s\rangle\)</span> together with a character to
represent the operator, an integer <cite>site_ind</cite> specifying the site of that local operator, the total number of sites <cite>N</cite>, and a set of optional <cite>uint</cite>-dtype arguments <cite>args</cite>. See the above example for how
one would use this for spin-1/2 system.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>op_args: np.ndarray[basis_dtype]</strong></dt><dd><p>used to pass the arguments <cite>args</cite> to the CFunc <cite>op(…,args)</cite>. The corresponding key must be a <cite>np.ndarray[basis_dtype]</cite>.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>pcon_dict: dict, optional</strong></dt><dd><dl class="simple">
<dt>This dictionary contains the following items which are required to use particle conservation in this basis:</dt><dd><dl class="simple">
<dt><em>minimum requirements</em>:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt><strong>Np: tuple/int, list(tuple/int)</strong></dt><dd><p>specifies the particle sector(s).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>next_state(s,counter,N,args): numba.CFunc object</strong></dt><dd><p>given a quantum state <span class="math notranslate nohighlight">\(|s\rangle\)</span> in the integer-representation <cite>s</cite>, this CFunc generates the next lexicographically ordered particle conservation state.
<cite>counter</cite> is an intrinsic variable which increments by unity every time the function is called, <cite>N</cite> is the total number of lattice sites, and <cite>args</cite> holds any optional arguments stored in a <cite>np.ndarray[basis_dtype]</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>next_state_args: np.ndarray(basis_dtype)</strong></dt><dd><p>optional arguments for <cite>next_state(…,args)</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>get_Ns_pcon(N,Np): python function</strong></dt><dd><p>when called as get_Ns_pcon(N,Np), this python function returns the size of the symmetery-free particle conservation basis, given the <cite>N</cite> lattice sites and <cite>Np</cite> (see above).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>get_s0_pcon(N,Np): python function</strong></dt><dd><p>when called as get_s0_pcon(N,Np), this python function returns the starting state to generate the whole particle conservation basis by repeatedly calling <cite>next_state()</cite>.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><em>advanced requirements</em> to access <cite>basis.Op_bra_ket()</cite> functionality (on top of the minimum requirements):</dt><dd><ul class="simple">
<li><dl class="simple">
<dt><strong>n_sectors: int, list(int)</strong></dt><dd><p>number of integers which parameterize the particle sectors, e.g. with spinful fermions there is a particle number for both the up and the down sectors, and hence <cite>n_sectors=2</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>count_particles(s,p_number_ptr,args): numba.CFunc object</strong></dt><dd><p>For a quantum state <cite>s</cite> in the integer representation, this CFunc counts the number of particles in each particle sector and places them into a pointer <cite>p_number_ptr</cite> (<cite>count_particles</cite> does <strong>not</strong> return any output). The pointer provided will have <cite>n_sector</cite> slots of memory allocated. The components of the pointer <cite>p_number_ptr</cite> must correspond to the ordering of <cite>Np</cite>. The integer <cite>s</cite> cannot be changed.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>count_particles_args: np.ndarray(int)</strong></dt><dd><p>compulsory arguments for <cite>count_particles(…,args)</cite> (whenever used).</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt><strong>pre_check_state(s,N,args): numba.CFunc object or tuple(numba.CFunc object,ndarray(C-contiguous,dtype=basis_dtype)), optional</strong></dt><dd><p>This CFunc allows the user to specify a boolean criterion used to discard/filter states from the basis. In the low-level code, this function is applied before checking if a given state is
representative state (i.e. belogs to a given symmetry sector) or not. This allows the user to, e.g., enforce a local Hilbert-space constraint
(e.g. for a spinful fermion basis to never have a doubly occupied site). One can pass additional arguments <cite>args</cite> using a <cite>np.ndarray[basis_dtype]</cite>.</p>
</dd>
<dt><strong>allowed_ops: list/set, optional</strong></dt><dd><p>A list of allowed characters, each of which is to be passed in to the <cite>op</cite> in the form of <cite>op_str</cite> (see above).</p>
</dd>
<dt><strong>parallel: bool, optional</strong></dt><dd><p>turns on parallel code when constructing the basis even when no symmetries are implemented. Useful when constructing highly constrained Hilbert spaces with pre_check_state.</p>
</dd>
<dt><strong>sps: int, optional</strong></dt><dd><p>The number of states per site (i.e. the local on-site Hilbert space dimension).</p>
</dd>
<dt><strong>Ns_full: int, optional</strong></dt><dd><p>Total number of states in the Hilbert space without any symmetries. For a single species this value is <cite>sps**N</cite></p>
</dd>
<dt><strong>Ns_block_est: int, optional</strong></dt><dd><p>An estimate for the size of the symmetry reduced block, QuSpin does a simple estimate which is not always correct.</p>
</dd>
<dt><strong>block_order: tuple/list, optional</strong></dt><dd><p>A list of strings containing the names of the symmetry blocks which specifies the order in which the symmetries will be applied to the state when calculating the basis. The first element in the list is applied to the state first followed by the second element, etc. If the list is not specificed the ordering is such that the symmetry with the largest cycle is the first, followed by the second largest, etc.</p>
</dd>
<dt><strong>noncommuting_bits: list, optional</strong></dt><dd><p>A list of tuples specifying if bits belong to a group of sites that do not commute. The first element in each tuple represents the group of sites, and the second element represents the phase-factor that is given during the exchange.</p>
</dd>
<dt><strong>**blocks: optional</strong></dt><dd><p>keyword arguments which pass the symmetry generator arrays. For instance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="p">(</span><span class="o">...</span><span class="p">,</span><span class="n">kxblock</span><span class="o">=</span><span class="p">(</span><span class="n">CFunc</span><span class="p">,</span><span class="n">m_Q</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">args</span><span class="p">),</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>The key names of the symmetry sector, e.g. <cite>kxblock</cite>, can be defined arbitrarily by the user. The
values are tuples where the first entry contains the numba-CFunc which generates the symmetry transformation <span class="math notranslate nohighlight">\(Q\)</span>
acting on the state (see class example), the second entry is an integer <span class="math notranslate nohighlight">\(m_Q\)</span> which gives the periodicity
of the symmetry sector (<span class="math notranslate nohighlight">\(Q^{m_Q} = 1\)</span>), and <span class="math notranslate nohighlight">\(q\)</span> is the quantum number for the given sector. Optional arguments can be passed using the`args` argument which is a <cite>np.ndarray[basis_dtype]</cite>. Note that if the periodicity is wrong
the basis will give undefined behavior.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.user_basis.Op" title="quspin.basis.user_basis.Op"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Op</span></code></a>(opstr, indx, J, dtype)</p></td>
<td><p>Constructs operator from a site-coupling list and an operator string in a lattice basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.user_basis.Op_bra_ket" title="quspin.basis.user_basis.Op_bra_ket"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Op_bra_ket</span></code></a>(opstr, indx, J, dtype, ket_states)</p></td>
<td><p>Finds bra states which connect given ket states by operator from a site-coupling list and an operator string.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.user_basis.Op_shift_sector" title="quspin.basis.user_basis.Op_shift_sector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Op_shift_sector</span></code></a>(other_basis, op_list, v_in)</p></td>
<td><p>Applies symmetry non-conserving operator to state in symmetry-reduced basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.user_basis.__init__" title="quspin.basis.user_basis.__init__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code></a>(basis_dtype, N, op_dict[, sps, …])</p></td>
<td><p>Intializes the <cite>user_basis_general</cite> object (basis for user defined ED calculations).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.user_basis.check_hermitian" title="quspin.basis.user_basis.check_hermitian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_hermitian</span></code></a>(static, dynamic)</p></td>
<td><p>Checks operator string lists for hermiticity of the combined operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.user_basis.check_pcon" title="quspin.basis.user_basis.check_pcon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_pcon</span></code></a>(static, dynamic)</p></td>
<td><p>Checks operator string lists for particle number (magnetisation) conservartion of the combined operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.user_basis.check_symm" title="quspin.basis.user_basis.check_symm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_symm</span></code></a>(static, dynamic)</p></td>
<td><p>Checks operator string lists for the required symmetries of the combined operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.user_basis.ent_entropy" title="quspin.basis.user_basis.ent_entropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ent_entropy</span></code></a>(state[, sub_sys_A, density, …])</p></td>
<td><p>Calculates entanglement entropy of subsystem A and the corresponding reduced density matrix</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.user_basis.expanded_form" title="quspin.basis.user_basis.expanded_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expanded_form</span></code></a>([static, dynamic])</p></td>
<td><p>Splits up operator strings containing “x” and “y” into operator combinations of “+” and “-“.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.user_basis.get_amp" title="quspin.basis.user_basis.get_amp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_amp</span></code></a>(states[, out, amps, mode])</p></td>
<td><p>Computes the rescale factor of state amplitudes between the symmetry-reduced and full basis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.user_basis.get_proj" title="quspin.basis.user_basis.get_proj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_proj</span></code></a>(dtype[, pcon])</p></td>
<td><p>Calculates transformation/projector from symmetry-reduced basis to full (symmetry-free) basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.user_basis.get_vec" title="quspin.basis.user_basis.get_vec"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_vec</span></code></a>(v0[, sparse, pcon])</p></td>
<td><p>DEPRECATED (cf <cite>project_from</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.user_basis.index" title="quspin.basis.user_basis.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a>(s)</p></td>
<td><p>Finds the index of user-defined Fock state in any lattice basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.user_basis.inplace_Op" title="quspin.basis.user_basis.inplace_Op"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inplace_Op</span></code></a>(v_in, op_list, dtype[, …])</p></td>
<td><p>Calculates the action of an operator on a state.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.user_basis.int_to_state" title="quspin.basis.user_basis.int_to_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int_to_state</span></code></a>(state[, bracket_notation])</p></td>
<td><p>Finds string representation of a state defined in integer representation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.user_basis.make" title="quspin.basis.user_basis.make"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make</span></code></a>([Ns_block_est, N_p])</p></td>
<td><p>Creates the entire basis by calling the basis constructor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.user_basis.make_basis_blocks" title="quspin.basis.user_basis.make_basis_blocks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_basis_blocks</span></code></a>([N_p])</p></td>
<td><p>Creates/modifies the bounds for representatives based on prefix tages.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.user_basis.normalization" title="quspin.basis.user_basis.normalization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalization</span></code></a>(states[, out])</p></td>
<td><p>Computes normalization of <cite>basis</cite> states.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.user_basis.partial_trace" title="quspin.basis.user_basis.partial_trace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partial_trace</span></code></a>(state[, sub_sys_A, …])</p></td>
<td><p>Calculates reduced density matrix, through a partial trace of a quantum state in a lattice <cite>basis</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.user_basis.project_from" title="quspin.basis.user_basis.project_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">project_from</span></code></a>(v0[, sparse, pcon])</p></td>
<td><p>Transforms state from symmetry-reduced basis to full (symmetry-free) basis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.user_basis.project_to" title="quspin.basis.user_basis.project_to"><code class="xref py py-obj docutils literal notranslate"><span class="pre">project_to</span></code></a>(v0[, sparse, pcon])</p></td>
<td><p>Transforms state from full (symmetry-free) basis to symmetry-reduced basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.user_basis.representative" title="quspin.basis.user_basis.representative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">representative</span></code></a>(states[, out, return_g, …])</p></td>
<td><p>Maps states to their representatives under the <cite>basis</cite> symmetries.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.user_basis.state_to_int" title="quspin.basis.user_basis.state_to_int"><code class="xref py py-obj docutils literal notranslate"><span class="pre">state_to_int</span></code></a>(state)</p></td>
<td><p>Finds integer representation of a state defined in string format.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.user_basis.N" title="quspin.basis.user_basis.N"><code class="xref py py-obj docutils literal notranslate"><span class="pre">N</span></code></a></p></td>
<td><p>number of sites the basis is constructed with.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.user_basis.Ns" title="quspin.basis.user_basis.Ns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ns</span></code></a></p></td>
<td><p>number of states in the Hilbert space.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.user_basis.blocks" title="quspin.basis.user_basis.blocks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">blocks</span></code></a></p></td>
<td><p>contains the quantum numbers (blocks) for the symmetry sectors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.user_basis.description" title="quspin.basis.user_basis.description"><code class="xref py py-obj docutils literal notranslate"><span class="pre">description</span></code></a></p></td>
<td><p>information about <cite>basis</cite> object.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.user_basis.dtype" title="quspin.basis.user_basis.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></p></td>
<td><p>data type of basis state integers.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.user_basis.noncommuting_bits" title="quspin.basis.user_basis.noncommuting_bits"><code class="xref py py-obj docutils literal notranslate"><span class="pre">noncommuting_bits</span></code></a></p></td>
<td><p>list of bits that represent sites that do not commute along with the phase required from commuting sites</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.user_basis.operators" title="quspin.basis.user_basis.operators"><code class="xref py py-obj docutils literal notranslate"><span class="pre">operators</span></code></a></p></td>
<td><p>set of available operator strings.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.user_basis.sps" title="quspin.basis.user_basis.sps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sps</span></code></a></p></td>
<td><p>number of states per site (i.e.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.user_basis.states" title="quspin.basis.user_basis.states"><code class="xref py py-obj docutils literal notranslate"><span class="pre">states</span></code></a></p></td>
<td><p>basis states stored in their integer representation.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="quspin.basis.user_basis.N">
<em class="property">property </em><code class="sig-name descname">N</code><a class="headerlink" href="#quspin.basis.user_basis.N" title="Permalink to this definition">¶</a></dt>
<dd><p>number of sites the basis is constructed with.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.Ns">
<em class="property">property </em><code class="sig-name descname">Ns</code><a class="headerlink" href="#quspin.basis.user_basis.Ns" title="Permalink to this definition">¶</a></dt>
<dd><p>number of states in the Hilbert space.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.Op">
<code class="sig-name descname">Op</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">opstr</span></em>, <em class="sig-param"><span class="n">indx</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">dtype</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.Op" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs operator from a site-coupling list and an operator string in a lattice basis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>opstr</strong><span class="classifier">str</span></dt><dd><p>Operator string in the lattice basis format. For instance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">opstr</span> <span class="o">=</span> <span class="s2">&quot;zz&quot;</span>
</pre></div>
</div>
</dd>
<dt><strong>indx</strong><span class="classifier">list(int)</span></dt><dd><p>List of integers to designate the sites the lattice basis operator is defined on. For instance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</dd>
<dt><strong>J</strong><span class="classifier">scalar</span></dt><dd><p>Coupling strength.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">‘type’</span></dt><dd><p>Data type (e.g. numpy.float64) to construct the operator with.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tuple</dt><dd><dl class="simple">
<dt><cite>(ME,row,col)</cite>, where</dt><dd><ul class="simple">
<li><p>numpy.ndarray(scalar): <cite>ME</cite>: matrix elements of type <cite>dtype</cite>.</p></li>
<li><dl class="simple">
<dt>numpy.ndarray(int): <cite>row</cite>: row indices of matrix representing the operator in the lattice basis,</dt><dd><p>such that <cite>row[i]</cite> is the row index of <cite>ME[i]</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>numpy.ndarray(int): <cite>col</cite>: column index of matrix representing the operator in the lattice basis,</dt><dd><p>such that <cite>col[i]</cite> is the column index of <cite>ME[i]</cite>.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="mf">1.41</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opstr</span> <span class="o">=</span> <span class="s2">&quot;zz&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ME</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">Op</span><span class="p">(</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.Op_bra_ket">
<code class="sig-name descname">Op_bra_ket</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">opstr</span></em>, <em class="sig-param"><span class="n">indx</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">dtype</span></em>, <em class="sig-param"><span class="n">ket_states</span></em>, <em class="sig-param"><span class="n">reduce_output</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.Op_bra_ket" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds bra states which connect given ket states by operator from a site-coupling list and an operator string.</p>
<p>Given a set of ket states <span class="math notranslate nohighlight">\(|s\rangle\)</span>, the function returns the bra states <span class="math notranslate nohighlight">\(\langle s'|\)</span> which connect to them through an operator, together with the corresponding matrix elements.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>opstr</strong><span class="classifier">str</span></dt><dd><p>Operator string in the lattice basis format. For instance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">opstr</span> <span class="o">=</span> <span class="s2">&quot;zz&quot;</span>
</pre></div>
</div>
</dd>
<dt><strong>indx</strong><span class="classifier">list(int)</span></dt><dd><p>List of integers to designate the sites the lattice basis operator is defined on. For instance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</dd>
<dt><strong>J</strong><span class="classifier">scalar</span></dt><dd><p>Coupling strength.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">‘type’</span></dt><dd><p>Data type (e.g. numpy.float64) to construct the matrix elements with.</p>
</dd>
<dt><strong>ket_states</strong><span class="classifier">numpy.ndarray(int)</span></dt><dd><p>Ket states in integer representation. Must be of same data type as <cite>basis</cite>.</p>
</dd>
<dt><strong>reduce_output: bool, optional</strong></dt><dd><p>If set to <cite>False</cite>, the returned arrays have the same size as <cite>ket_states</cite>; If set to <cite>True</cite> zeros are purged.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tuple</dt><dd><dl class="simple">
<dt><cite>(ME,bra,ket)</cite>, where</dt><dd><ul class="simple">
<li><p>numpy.ndarray(scalar): <cite>ME</cite>: matrix elements of type <cite>dtype</cite>, which connects the ket and bra states.</p></li>
<li><dl class="simple">
<dt>numpy.ndarray(int): <cite>bra</cite>: bra states, obtained by applying the matrix representing the operator in the lattice basis,</dt><dd><p>to the ket states, such that <cite>bra[i]</cite> corresponds to <cite>ME[i]</cite> and connects to <cite>ket[i]</cite>.</p>
</dd>
</dl>
</li>
<li><p>numpy.ndarray(int): <cite>ket</cite>: ket states, such that <cite>ket[i]</cite> corresponds to <cite>ME[i]</cite> and connects to <cite>bra[i]</cite>.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Similar to <cite>Op</cite> but instead of returning the matrix indices (row,col), it returns the states (bra,ket) in integer representation.</p></li>
<li><p>Does NOT require the full basis (see <cite>basis</cite> optional argument <cite>make_basis</cite>).</p></li>
<li><p>If a state from <cite>ket_states</cite> does not have a non-zero matrix element, it is removed from the returned list. See otional argument <cite>reduce_output</cite>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="mf">1.41</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opstr</span> <span class="o">=</span> <span class="s2">&quot;zz&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ME</span><span class="p">,</span> <span class="n">bra</span><span class="p">,</span> <span class="n">ket</span> <span class="o">=</span> <span class="n">Op_bra_ket</span><span class="p">(</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">ket_states</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.Op_shift_sector">
<code class="sig-name descname">Op_shift_sector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other_basis</span></em>, <em class="sig-param"><span class="n">op_list</span></em>, <em class="sig-param"><span class="n">v_in</span></em>, <em class="sig-param"><span class="n">v_out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.Op_shift_sector" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies symmetry non-conserving operator to state in symmetry-reduced basis.</p>
<p>An operator, which does not conserve a symmetry, induces a change in the quantum number of a state defined in the corresponding symmetry sector. Hence, when the operator is applied on a quantum state, the state shifts the symmetry sector. <cite>Op_shift_sector()</cite> handles this automatically.</p>
<p><span class="red">NOTE: One has to make sure that (i) the operator moves the state between the two sectors, and (ii) the two bases objects have the same symmetries. This function will not give the correct results otherwise.</span></p>
<p>Formally  equivalent to:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P1</span> <span class="o">=</span> <span class="n">basis_sector_1</span><span class="o">.</span><span class="n">get_proj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span> <span class="c1"># projector between full and initial basis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P2</span> <span class="o">=</span> <span class="n">basis_sector_2</span><span class="o">.</span><span class="n">get_proj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span> <span class="c1"># projector between full and target basis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v_in_full</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v_in</span><span class="p">)</span> <span class="c1"># go from initial basis to to full basis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v_out_full</span> <span class="o">=</span> <span class="n">basis_full</span><span class="o">.</span><span class="n">inplace_Op</span><span class="p">(</span><span class="n">v_in_full</span><span class="p">,</span><span class="n">op_list</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span> <span class="c1"># apply Op</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v_out</span> <span class="o">=</span> <span class="n">P2</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v_out_full</span><span class="p">)</span> <span class="c1"># project to target basis</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>other_basis</strong><span class="classifier"><cite>basis</cite> object</span></dt><dd><p><cite>basis_general</cite> object for the initial symmetry sector. Must be the same <cite>basis</cite> class type as the basis whose instance is <cite>Op_shift_sector()</cite> (i.e. the basis in <cite>basis.Op_shift_sector()</cite>).</p>
</dd>
<dt><strong>op_list</strong><span class="classifier">list</span></dt><dd><p>Operator string list which defines the operator to apply. Follows the format <cite>[[“z”,[i],Jz[i]] for i in range(L)], [“x”,[i],Jx[j]] for j in range(L)],…]</cite>.</p>
</dd>
<dt><strong>v_in</strong><span class="classifier">array_like, (other_basis.Ns,…)</span></dt><dd><p>Initial state to apply the symmetry non-conserving operator on. Must have the same length as <cite>other_basis.Ns</cite>.</p>
</dd>
<dt><strong>v_out</strong><span class="classifier">array_like, (basis.Ns,…), optional</span></dt><dd><p>Optional array to write the result for the final/target state in.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">numpy dtype for matrix elements, optional</span></dt><dd><p>Data type (e.g. <cite>numpy.float64</cite>) to construct the operator with.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>(basis.Ns, ) numpy.ndarray</dt><dd><p>Array containing the state <cite>v_out</cite> in the current basis, i.e. the basis in <cite>basis.Op_shift_sector()</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>particularly useful when computing correlation functions.</p></li>
<li><p>supports parallelization to multiple states listed in the columns of <cite>v_in</cite>.</p></li>
<li><p>the user is strongly advised to use the code under “Formally equivalent” above to check the results of this function for small system sizes.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v_out</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">Op_shift_sector</span><span class="p">(</span><span class="n">initial_basis</span><span class="p">,</span> <span class="n">op_list</span><span class="p">,</span> <span class="n">v_in</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">v_out</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span> <span class="n">v_in</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">initial_basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.blocks">
<em class="property">property </em><code class="sig-name descname">blocks</code><a class="headerlink" href="#quspin.basis.user_basis.blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>contains the quantum numbers (blocks) for the symmetry sectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.check_hermitian">
<code class="sig-name descname">check_hermitian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">static</span></em>, <em class="sig-param"><span class="n">dynamic</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.check_hermitian" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks operator string lists for hermiticity of the combined operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static: list</strong></dt><dd><p>Static operators formatted to be passed into the static argument of the <cite>hamiltonian</cite> class.</p>
</dd>
<dt><strong>dynamic: list</strong></dt><dd><p>Dynamic operators formatted to be passed into the dynamic argument of the <cite>hamiltonian</cite> class.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.check_pcon">
<code class="sig-name descname">check_pcon</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">static</span></em>, <em class="sig-param"><span class="n">dynamic</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.check_pcon" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks operator string lists for particle number (magnetisation) conservartion of the combined operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static: list</strong></dt><dd><p>Static operators formatted to be passed into the static argument of the <cite>hamiltonian</cite> class.</p>
</dd>
<dt><strong>dynamic: list</strong></dt><dd><p>Dynamic operators formatted to be passed into the dynamic argument of the <cite>hamiltonian</cite> class.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.check_symm">
<code class="sig-name descname">check_symm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">static</span></em>, <em class="sig-param"><span class="n">dynamic</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.check_symm" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks operator string lists for the required symmetries of the combined operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static: list</strong></dt><dd><p>Static operators formatted to be passed into the static argument of the <cite>hamiltonian</cite> class.</p>
</dd>
<dt><strong>dynamic: list</strong></dt><dd><p>Dynamic operators formatted to be passed into the dynamic argument of the <cite>hamiltonian</cite> class.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.description">
<em class="property">property </em><code class="sig-name descname">description</code><a class="headerlink" href="#quspin.basis.user_basis.description" title="Permalink to this definition">¶</a></dt>
<dd><p>information about <cite>basis</cite> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.dtype">
<em class="property">property </em><code class="sig-name descname">dtype</code><a class="headerlink" href="#quspin.basis.user_basis.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>data type of basis state integers.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>numpy.dtype</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.ent_entropy">
<code class="sig-name descname">ent_entropy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">state</span></em>, <em class="sig-param"><span class="n">sub_sys_A</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">density</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">subsys_ordering</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">return_rdm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">enforce_pure</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_rdm_EVs</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">sparse</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">sparse_diag</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">svd_solver</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">svd_kwargs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.ent_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates entanglement entropy of subsystem A and the corresponding reduced density matrix</p>
<div class="math notranslate nohighlight">
\[S_\mathrm{ent}(\alpha) = \frac{1}{N}\frac{1}{1-\alpha}\log \mathrm{tr}_{A} \left( \mathrm{tr}_{A^c} \vert\psi\rangle\langle\psi\vert \right)^\alpha\]</div>
<p>where the normalization <span class="math notranslate nohighlight">\(N\)</span> can be switched on and off using the optional argument <cite>density</cite>.</p>
<p><strong>Note:</strong> The logarithm used is the natural logarithm (base e).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier">obj</span></dt><dd><p>State of the quantum system. Can be either one of:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy.ndarray [shape (Ns,)]: pure state (default).</p></li>
<li><p>numpy.ndarray [shape (Ns,Ns)]: density matrix (DM).</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>sub_sys_A</strong><span class="classifier">tuple/list, optional</span></dt><dd><p>Defines the sites contained in subsystem A [by python convention the first site of the chain is labelled j=0].
Default is <cite>tuple(range(N//2))</cite> with <cite>N</cite> the number of lattice sites.</p>
</dd>
<dt><strong>density</strong><span class="classifier">bool, optional</span></dt><dd><p>Toggles whether to return entanglement entropy normalized by the number of sites in the subsystem.</p>
</dd>
<dt><strong>return_rdm</strong><span class="classifier">str, optional</span></dt><dd><p>Toggles returning the reduced DM. Can be tierh one of:</p>
<blockquote>
<div><ul class="simple">
<li><p>“A”: returns reduced DM of subsystem A.</p></li>
<li><p>“B”: returns reduced DM of subsystem B.</p></li>
<li><p>“both”: returns reduced DM of both A and B subsystems.</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>enforce_pure</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to assume <cite>state</cite> is a collection of pure states or a mixed density matrix, if
it is a square array. Default is <cite>False</cite>.</p>
</dd>
<dt><strong>subsys_ordering</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to reorder the sites in <cite>sub_sys_A</cite> in ascending order. Default is <cite>True</cite>.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to return a sparse DM. Default is <cite>False</cite>.</p>
</dd>
<dt><strong>return_rdm_EVs</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to return the eigenvalues of rthe educed DM. If <cite>return_rdm</cite> is specified,
the eigenvalues of the corresponding DM are returned. If <cite>return_rdm</cite> is NOT specified,
the spectrum of <cite>rdm_A</cite> is returned by default. Default is <cite>False</cite>.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, optional</span></dt><dd><p>Renyi <span class="math notranslate nohighlight">\(\alpha\)</span> parameter for the entanglement entropy. Default is <span class="math notranslate nohighlight">\(\alpha=1\)</span>.</p>
</dd>
<dt><strong>sparse_diag</strong><span class="classifier">bool, optional</span></dt><dd><p>When <cite>sparse=True</cite>, this flag enforces the use of
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/generated/scipy.sparse.linalg.eigsh.html">scipy.sparse.linalg.eigsh()</a>
to calculate the eigenvaues of the reduced DM.</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int, optional</span></dt><dd><p>Specifies the number of iterations for Lanczos diagonalisation. Look up documentation for
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/generated/scipy.sparse.linalg.eigsh.html">scipy.sparse.linalg.eigsh()</a>.</p>
</dd>
<dt><strong>svd_solver</strong><span class="classifier">object, optional</span></dt><dd><p>Specifies the svd solver to be used, e.g. <cite>numpy.linalg.svd</cite> or <cite>scipy.linalg.svd</cite>, or a custom solver. Effective when <cite>enforce_pure=True</cite> or <cite>sparse=False</cite>.</p>
</dd>
<dt><strong>svd_kwargs</strong><span class="classifier">dict, optional</span></dt><dd><p>Specifies additional arguments for <cite>svd_solver</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>dict</dt><dd><dl class="simple">
<dt>Dictionary with following keys, depending on input parameters:</dt><dd><ul class="simple">
<li><p>“Sent_A”: entanglement entropy of subsystem A (default).</p></li>
<li><p>“Sent_B”: entanglement entropy of subsystem B.</p></li>
<li><p>“p_A”: singular values of reduced DM of subsystem A (default).</p></li>
<li><p>“p_B”: singular values of reduced DM of subsystem B.</p></li>
<li><p>“rdm_A”: reduced DM of subsystem A.</p></li>
<li><p>“rdm_B”: reduced DM of subsystem B.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Algorithm is based on both partial tracing and sigular value decomposition (SVD), optimised for speed.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ent_entropy</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">sub_sys_A</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span><span class="n">return_rdm</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="n">enforce_pure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">return_rdm_EVs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                            <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">sparse_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">subsys_ordering</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.expanded_form">
<code class="sig-name descname">expanded_form</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">static</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">dynamic</span><span class="o">=</span><span class="default_value">[]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.expanded_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits up operator strings containing “x” and “y” into operator combinations of “+” and “-“. This function is useful for higher spin hamiltonians where “x” and “y” operators are not appropriate operators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static: list</strong></dt><dd><p>Static operators formatted to be passed into the static argument of the <cite>hamiltonian</cite> class.</p>
</dd>
<dt><strong>dynamic: list</strong></dt><dd><p>Dynamic operators formatted to be passed into the dynamic argument of the <cite>hamiltonian</cite> class.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tuple</dt><dd><dl class="simple">
<dt><cite>(static, dynamic)</cite>, where</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>list: <cite>static</cite>: operator strings with “x” and “y” expanded into “+” and “-“, formatted to</dt><dd><p>be passed into the static argument of the <cite>hamiltonian</cite> class.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>list: <cite>dynamic</cite>: operator strings with “x” and “y” expanded into “+” and “-“, formatted to</dt><dd><p>be passed into the dynamic argument of the <cite>hamiltonian</cite> class.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function works with the <cite>tensor_basis</cite> and other basis which use the “|” symbol in the opstr.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">static</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;xx&quot;</span><span class="p">,[[</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]],[</span><span class="s2">&quot;yy&quot;</span><span class="p">,[[</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dynamic</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;y&quot;</span><span class="p">,[[</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">,[]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expanded_form</span><span class="p">(</span><span class="n">static</span><span class="p">,</span><span class="n">dynamic</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.get_amp">
<code class="sig-name descname">get_amp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">states</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">amps</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'representative'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.get_amp" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the rescale factor of state amplitudes between the symmetry-reduced and full basis.</p>
<p>Given a quantum state <span class="math notranslate nohighlight">\(s\)</span> and a state amplitude in the full basis <span class="math notranslate nohighlight">\(\psi_s\)</span>, its representative (under the symemtries)
<span class="math notranslate nohighlight">\(r(s)\)</span> with a corresponding amplitude <span class="math notranslate nohighlight">\(\psi^\text{sym}_r\)</span>, the function computes the ratio <span class="math notranslate nohighlight">\(C\)</span>, defined as</p>
<div class="math notranslate nohighlight">
\[\psi_s = C\psi_r^\text{sym}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>states</strong><span class="classifier">array_like(int)</span></dt><dd><p>Fock-basis (z-basis) states to find the amplitude rescale factor <span class="math notranslate nohighlight">\(C\)</span> of. States are stored in integer representations.</p>
</dd>
<dt><strong>out</strong><span class="classifier">numpy.ndarray(float), optional</span></dt><dd><p>variable to store the rescale factors <span class="math notranslate nohighlight">\(C\)</span> of the states in. Must be a real or complex-valued <cite>numpy.ndarray</cite> of the same shape as <cite>states</cite>.</p>
</dd>
<dt><strong>amps</strong><span class="classifier">numpy.ndarray(float), optional</span></dt><dd><p>array of amplitudes to rescale by the amplitude factor <span class="math notranslate nohighlight">\(C\)</span> (see <cite>mode</cite>). Updated in-place. Must be a real or complex-valued <cite>numpy.ndarray</cite> of the same shape as <cite>states</cite>.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">string, optional</span></dt><dd><ul class="simple">
<li><dl class="simple">
<dt>if <cite>mode=’representative’</cite> (default), then the function assumes that</dt><dd><ol class="lowerroman simple">
<li><p><cite>states</cite> already contains representatives (i.e. states in the symmetry-reduced basis);</p></li>
<li><p><cite>amps</cite> (if passed) are amplitudes in the symmetry-reduced basis (<span class="math notranslate nohighlight">\(\psi_r^\text{symm}\)</span>). The function will update <cite>amps</cite> in-place to <span class="math notranslate nohighlight">\(\psi_s\)</span>.</p></li>
</ol>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>if <cite>mode=’full_basis’</cite>, then the function assumes that</dt><dd><ol class="lowerroman simple">
<li><p><cite>states</cite> contains full-basis states (the funciton will compute the corresponding representatives);</p></li>
<li><dl class="simple">
<dt><cite>amps</cite> (if passed) are amplitudes in the full basis (<span class="math notranslate nohighlight">\(\psi_s\)</span>). The function will update <cite>amps</cite> in-place to <span class="math notranslate nohighlight">\(\psi_r^\text{symm}\)</span>;</dt><dd><p><strong>Note</strong>: the function will also update the variable <cite>states</cite> in place with the corresponding representatives.</p>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>array_like(float)</dt><dd><p>amplitude rescale factor <span class="math notranslate nohighlight">\(C\)</span> (see expression above).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Particularly useful when a given operation cannot be carried away in the symmetry-reduced basis in a straightforward manner.</p></li>
<li><p>To transform an entire state from a symmetry-reduced basis to the full (symmetry-free) basis, use the <cite>basis.get_vec()</cite> function.</p></li>
<li><p>Returns zero, if the state passed to the function is not part of the symmetry-reduced basis.</p></li>
<li><p>If <cite>amps</cite> is passed, the user has to make sure that the input data in <cite>amps</cite> correspond to the <cite>states</cite>.</p></li>
<li><p>The function assumes that <cite>states</cite> comply with the particle conservation symmetry the <cite>basis</cite> was constructed with.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">get_amp</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">amps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;representative&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.get_proj">
<code class="sig-name descname">get_proj</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dtype</span></em>, <em class="sig-param"><span class="n">pcon</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.get_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates transformation/projector from symmetry-reduced basis to full (symmetry-free) basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">‘type’</span></dt><dd><p>Data type (e.g. numpy.float64) to construct the projector with.</p>
</dd>
<dt><strong>pcon</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to return the projector to the particle number (magnetisation) conserving basis
(useful in bosonic/single particle systems). Default is <cite>pcon=False</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>scipy.sparse.csc_matrix</dt><dd><p>Transformation/projector between the symmetry-reduced and the full basis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>particularly useful when a given operation canot be carried out in the symmetry-reduced basis in a straightforward manner.</p></li>
<li><p>see also <cite>Op_shift_sector()</cite>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">get_proj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span><span class="n">pcon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.get_vec">
<code class="sig-name descname">get_vec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">v0</span></em>, <em class="sig-param"><span class="n">sparse</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">pcon</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.get_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>DEPRECATED (cf <cite>project_from</cite>). Transforms state from symmetry-reduced basis to full (symmetry-free) basis.</p>
<p class="rubric">Notes</p>
<p>This function is <span class="red">deprecated</span>. Use <cite>project_from()</cite> instead; see also the inverse function <cite>project_to()</cite>.</p>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.index">
<code class="sig-name descname">index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the index of user-defined Fock state in any lattice basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>s</strong><span class="classifier">{str, int}</span></dt><dd><p>Defines the Fock state with number of particles (spins) per site in underlying lattice <cite>basis</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>int</dt><dd><p>Position of the Fock state in the lattice basis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Particularly useful for defining initial Fock states through a unit vector in the direction specified
by <cite>index()</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i0</span> <span class="o">=</span> <span class="n">index</span><span class="p">(</span><span class="s2">&quot;111000&quot;</span><span class="p">)</span> <span class="c1"># pick state from basis set</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># define state corresponding to the string &quot;111000&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.inplace_Op">
<code class="sig-name descname">inplace_Op</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">v_in</span></em>, <em class="sig-param"><span class="n">op_list</span></em>, <em class="sig-param"><span class="n">dtype</span></em>, <em class="sig-param"><span class="n">transposed</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">conjugated</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">v_out</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.inplace_Op" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the action of an operator on a state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v_in</strong><span class="classifier">array_like</span></dt><dd><p>state (or states stored in columns) to act on with the operator.</p>
</dd>
<dt><strong>op_list</strong><span class="classifier">list</span></dt><dd><p>Operator string list which defines the operator to apply. Follows the format <cite>[[“z”,[i],Jz[i]] for i in range(L)], [“x”,[i],Jx[j]] for j in range(L)],…]</cite>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">‘type’</span></dt><dd><p>Data type (e.g. <cite>numpy.float64</cite>) to construct the operator with.</p>
</dd>
<dt><strong>transposed</strong><span class="classifier">bool, optional</span></dt><dd><p>if <cite>True</cite> this function will act with the trasposed operator.</p>
</dd>
<dt><strong>conjugated</strong><span class="classifier">bool, optional</span></dt><dd><p>if <cite>True</cite> this function will act with the conjugated operator.</p>
</dd>
<dt><strong>v_out</strong><span class="classifier">array_like</span></dt><dd><p>output array, must be the same shape as <cite>v_in</cite> and must match the type of the output.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><ul class="simple">
<li><p>if <cite>v_out</cite> is not <cite>None</cite>, this function modifies <cite>v_out</cite> inplace and returns it.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function works with the <cite>tensor_basis</cite> and other basis which use the “|” symbol in the opstr.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="mf">1.41</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opstr</span> <span class="o">=</span> <span class="s2">&quot;zz&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">op_list</span><span class="o">=</span><span class="p">[[</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ME</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">inplace_Op</span><span class="p">(</span><span class="n">op_list</span><span class="p">,</span><span class="n">dtype</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.int_to_state">
<code class="sig-name descname">int_to_state</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">state</span></em>, <em class="sig-param"><span class="n">bracket_notation</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.int_to_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds string representation of a state defined in integer representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">int</span></dt><dd><p>Defines the Fock state in integer representation in underlying lattice <cite>basis</cite>.</p>
</dd>
<dt><strong>bracket_notation</strong><span class="classifier">bool, optional</span></dt><dd><p>Toggles whether to return the state in <cite>|str&gt;</cite> notation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>str</dt><dd><p>String corresponding to the Fock <cite>state</cite> in the lattice basis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is the inverse of <cite>state_to_int</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># pick state from basis set</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_str</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">int_to_state</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s_str</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.make">
<code class="sig-name descname">make</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Ns_block_est</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">N_p</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.make" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the entire basis by calling the basis constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Ns_block_est: int, optional</strong></dt><dd><p>Overwrites the internal estimate of the size of the reduced Hilbert space for the given symmetries. This can be used to help conserve memory if the exact size of the H-space is known ahead of time.</p>
</dd>
<dt><strong>N_p: int, optional</strong></dt><dd><p>number of bits to use in the prefix label used to generate blocks for searching positions of representatives.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>int</dt><dd><p>Total number of states in the (symmetry-reduced) Hilbert space.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The memory stored in the basis grows exponentially as exactly <span class="math notranslate nohighlight">\(2^{N_p+1}\)</span>. The default behavior is to use <cite>N_p</cite> such that
the size of the stored information for the representative bounds is approximately as large as the basis. This is not as effective
for basis which small particle numbers as the blocks have very uneven sizes. To not use the blocks just set N_p=0.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="p">,</span> <span class="n">Nup</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="o">=</span><span class="n">spin_basis_general</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">Nup</span><span class="o">=</span><span class="n">Nup</span><span class="p">,</span><span class="n">make_basis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="o">.</span><span class="n">make</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.make_basis_blocks">
<code class="sig-name descname">make_basis_blocks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">N_p</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.make_basis_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates/modifies the bounds for representatives based on prefix tages.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N_p: int, optional</strong></dt><dd><p>number of bits to use in the prefix label used to generate blocks for searching positions of representatives.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The memory stored in the basis grows exponentially as exactly <span class="math notranslate nohighlight">\(2^{N_p+1}\)</span>. The default behavior is to use <cite>N_p</cite> such that
the size of the stored information for the representative bounds is approximately as large as the basis. This is not as effective
for basis which small particle numbers as the blocks have very uneven sizes. To not use the blocks just set N_p=0.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="p">,</span> <span class="n">Nup</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="o">=</span><span class="n">spin_basis_general</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">Nup</span><span class="o">=</span><span class="n">Nup</span><span class="p">,</span><span class="n">make_basis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="o">.</span><span class="n">make</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.noncommuting_bits">
<em class="property">property </em><code class="sig-name descname">noncommuting_bits</code><a class="headerlink" href="#quspin.basis.user_basis.noncommuting_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>list of bits that represent sites that do not commute along with the phase required from commuting sites</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.normalization">
<code class="sig-name descname">normalization</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">states</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.normalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes normalization of <cite>basis</cite> states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>states</strong><span class="classifier">array_like(int)</span></dt><dd><p>Fock-basis (z-basis) states to find the normalizations of. States are stored in integer representations.</p>
</dd>
<dt><strong>out</strong><span class="classifier">numpy.ndarray(unsigned int), optional</span></dt><dd><p>variable to store the normalizations of the states in. Must be a <cite>numpy.ndarray</cite> of datatype <cite>unsigned int</cite> (e.g. <cite>numpy.uint16</cite>), and same shape as <cite>states</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>array_like(int)</dt><dd><p>normalizations of <cite>states</cite> for the given (symmetry-reduced) <cite>basis</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Returns zero, if the state is not part of the symmetry-reduced basis.</p></li>
<li><p>The normalizations can be used to compute matrix elements in the symmetry-reduced basis.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="o">=</span><span class="n">spin_basis_general</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">Nup</span><span class="o">=</span><span class="n">Nup</span><span class="p">,</span><span class="n">make_basis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="mi">17</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">norm_s</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">normalization</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">norm_s</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.operators">
<em class="property">property </em><code class="sig-name descname">operators</code><a class="headerlink" href="#quspin.basis.user_basis.operators" title="Permalink to this definition">¶</a></dt>
<dd><p>set of available operator strings.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>set</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.partial_trace">
<code class="sig-name descname">partial_trace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">state</span></em>, <em class="sig-param"><span class="n">sub_sys_A</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">subsys_ordering</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">return_rdm</span><span class="o">=</span><span class="default_value">'A'</span></em>, <em class="sig-param"><span class="n">enforce_pure</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">sparse</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.partial_trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates reduced density matrix, through a partial trace of a quantum state in a lattice <cite>basis</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier">obj</span></dt><dd><p>State of the quantum system. Can be either one of:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy.ndarray [shape (Ns,)]: pure state (default).</p></li>
<li><p>numpy.ndarray [shape (Ns,Ns)]: density matrix (DM).</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>sub_sys_A</strong><span class="classifier">tuple/list, optional</span></dt><dd><p>Defines the sites contained in subsystem A [by python convention the first site of the chain is labelled j=0].
Default is <cite>tuple(range(N//2))</cite> with <cite>N</cite> the number of lattice sites.</p>
</dd>
<dt><strong>return_rdm</strong><span class="classifier">str, optional</span></dt><dd><p>Toggles returning the reduced DM. Can be tierh one of:</p>
<blockquote>
<div><ul class="simple">
<li><p>“A”: returns reduced DM of subsystem A.</p></li>
<li><p>“B”: returns reduced DM of subsystem B.</p></li>
<li><p>“both”: returns reduced DM of both A and B subsystems.</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>subsys_ordering</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to reorder the sites in <cite>sub_sys_A</cite> in ascending order. Default is <cite>True</cite>.</p>
</dd>
<dt><strong>enforce_pure</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to assume <cite>state</cite> is a colelction of pure states or a mixed density matrix, if
it is a square array. Default is <cite>False</cite>.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to return a sparse DM. Default is <cite>False</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>Density matrix associated with <cite>state</cite>. Depends on optional arguments.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>This function can also be applied to trace out operators/observables defined by the input <cite>state</cite>, in which case one has to additionally normalize the final output by the Hilbert space dimension of the traced-out space. However, if an operator is defined in a symmetry-reduced basis, there is a <span class="red">caveat</span>. In such a case, one has to:</dt><dd><ol class="arabic simple">
<li><p>use the <cite>basis.get_proj()</cite> function to lift the operator to the full basis;</p></li>
<li><p>apply <cite>basis.partial_trace()</cite>;</p></li>
<li><p>repeat this procedure for all symmetry sectors, and sum up the resulting reduced operators [this is becauce one has to add in the information about how the operator acts on the full Hilbert space].</p></li>
</ol>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">partial_trace</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">sub_sys_A</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">),</span><span class="n">return_rdm</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="n">enforce_pure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">subsys_ordering</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.project_from">
<code class="sig-name descname">project_from</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">v0</span></em>, <em class="sig-param"><span class="n">sparse</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">pcon</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.project_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms state from symmetry-reduced basis to full (symmetry-free) basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v0</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Contains in its columns the states in the symmetry-reduced basis.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not the output should be in sparse format. Default is <cite>True</cite>.</p>
</dd>
<dt><strong>pcon</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to return the output in the particle number (magnetisation) conserving basis
(useful in bosonic/single particle systems). Default is <cite>pcon=False</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>Array containing the state <cite>v0</cite> in the full basis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>particularly useful when a given operation cannot be carried out in the symmetry-reduced basis in a straightforward manner.</p></li>
<li><p>supports parallelisation to multiple states listed in the columns.</p></li>
<li><p>inverse function to <cite>project_to</cite>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v_full</span> <span class="o">=</span> <span class="n">project_from</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">v_full</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.project_to">
<code class="sig-name descname">project_to</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">v0</span></em>, <em class="sig-param"><span class="n">sparse</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">pcon</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.project_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms state from full (symmetry-free) basis to symmetry-reduced basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v0</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Contains in its columns the states in the full (symmetry-free) basis.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not the output should be in sparse format. Default is <cite>True</cite>.</p>
</dd>
<dt><strong>pcon</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to return the output in the particle number (magnetisation) conserving basis
(useful in bosonic/single particle systems). Default is <cite>pcon=False</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>Array containing the state <cite>v0</cite> in the symmetry-reduced basis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>particularly useful when a given operation cannot be carried out in the full basis.</p></li>
<li><p>supports parallelisation to multiple states listed in the columns.</p></li>
<li><p>inverse function to <cite>project_from</cite>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v_symm</span> <span class="o">=</span> <span class="n">project_to</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">v_symm</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.representative">
<code class="sig-name descname">representative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">states</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_g</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_sign</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.representative" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps states to their representatives under the <cite>basis</cite> symmetries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>states</strong><span class="classifier">array_like(int)</span></dt><dd><p>Fock-basis (z-basis) states to find the representatives of. States are stored in integer representations.</p>
</dd>
<dt><strong>out</strong><span class="classifier">numpy.ndarray(int), optional</span></dt><dd><p>variable to store the representative states in. Must be a <cite>numpy.ndarray</cite> of same datatype as <cite>basis</cite>, and same shape as <cite>states</cite>.</p>
</dd>
<dt><strong>return_g</strong><span class="classifier">bool, optional</span></dt><dd><p>if set to <cite>True</cite>, the function also returns the integer <cite>g</cite> corresponding to the number of times each basis symmetry needs to be applied to a given state to obtain its representative.</p>
</dd>
<dt><strong>return_sign</strong><span class="classifier">bool, optional</span></dt><dd><p>if set to <cite>True</cite>, the function returns the <cite>sign</cite> of the representative relative to the original state (nontrivial only for fermionic bases).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tuple</dt><dd><p>( representatives, g_array, sign_array )
* array_like(int): <cite>representatives</cite>: Representatives under <cite>basis</cite> symmetries, corresponding to <cite>states</cite>.
* array_like(int): <cite>g_array</cite> of size (number of states, number of symmetries). Requires <cite>return_g=True</cite>. Contains integers corresponding to the number of times each basis symmetry needs to be applied to a given state to obtain its representative.
* array_like(int): <cite>sign_array</cite> of size (number of states,). Requires <cite>return_sign=True</cite>. Contains <cite>sign</cite> of the representative relative to the original state (nontrivial only for fermionic bases).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="o">=</span><span class="n">spin_basis_general</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">Nup</span><span class="o">=</span><span class="n">Nup</span><span class="p">,</span><span class="n">make_basis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="mi">17</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">representative</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.sps">
<em class="property">property </em><code class="sig-name descname">sps</code><a class="headerlink" href="#quspin.basis.user_basis.sps" title="Permalink to this definition">¶</a></dt>
<dd><p>number of states per site (i.e. the on-site Hilbert space dimension).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.state_to_int">
<code class="sig-name descname">state_to_int</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">state</span></em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.state_to_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds integer representation of a state defined in string format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">str</span></dt><dd><p>Defines the Fock state with number of particles (spins) per site in underlying lattice <cite>basis</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>int</dt><dd><p>Integer corresponding to the Fock <cite>state</cite> in the lattice basis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is the einverse of <cite>int_to_state</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s_str</span> <span class="o">=</span> <span class="s2">&quot;111000&quot;</span> <span class="c1"># pick state from basis set</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">state_to_int</span><span class="p">(</span><span class="n">s_str</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="quspin.basis.user_basis.states">
<em class="property">property </em><code class="sig-name descname">states</code><a class="headerlink" href="#quspin.basis.user_basis.states" title="Permalink to this definition">¶</a></dt>
<dd><p>basis states stored in their integer representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>numpy.ndarray(int)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="quspin.basis.spinful_fermion_basis_general.html"
                        title="previous chapter">quspin.basis.spinful_fermion_basis_general</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="quspin.basis.tensor_basis.html"
                        title="next chapter">quspin.basis.tensor_basis</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../sources/generated/quspin.basis.user_basis.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="quspin.basis.tensor_basis.html" title="quspin.basis.tensor_basis"
             >next</a> |</li>
        <li class="right" >
          <a href="quspin.basis.spinful_fermion_basis_general.html" title="quspin.basis.spinful_fermion_basis_general"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">QuSpin 0.3.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../basis.html" >Basis module (<code class="xref py py-mod docutils literal notranslate"><span class="pre">quspin.basis</span></code>)</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">quspin.basis.user_basis</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Phillip Weinberg, Markus Schmitt and Marin Bukov.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>
  </body>
</html>