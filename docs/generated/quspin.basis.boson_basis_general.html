
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" /><script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-110543543-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <title>quspin.basis.boson_basis_general &#8212; QuSpin 0.3.4 documentation</title>
    <link rel="stylesheet" href="../static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../static/documentation_options.js"></script>
    <script src="../static/jquery.js"></script>
    <script src="../static/underscore.js"></script>
    <script src="../static/doctools.js"></script>
    <script src="../static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="quspin.basis.spinless_fermion_basis_general" href="quspin.basis.spinless_fermion_basis_general.html" />
    <link rel="prev" title="quspin.basis.spin_basis_general" href="quspin.basis.spin_basis_general.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="quspin.basis.spinless_fermion_basis_general.html" title="quspin.basis.spinless_fermion_basis_general"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="quspin.basis.spin_basis_general.html" title="quspin.basis.spin_basis_general"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">QuSpin 0.3.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../basis.html" accesskey="U">Basis module (<code class="xref py py-mod docutils literal notranslate"><span class="pre">quspin.basis</span></code>)</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <style> .red {color:#ff0000; font-weight:bold; font-style:italic; } </style>
<style> .green {color:#00b200; font-weight:bold; font-style:italic; } </style><div class="section" id="quspin-basis-boson-basis-general">
<h1>quspin.basis.boson_basis_general<a class="headerlink" href="#quspin-basis-boson-basis-general" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="quspin.basis.boson_basis_general">
<em class="property">class </em><code class="sig-prename descclassname">quspin.basis.</code><code class="sig-name descname">boson_basis_general</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">Nb=None</em>, <em class="sig-param">nb=None</em>, <em class="sig-param">sps=None</em>, <em class="sig-param">Ns_block_est=None</em>, <em class="sig-param">make_basis=True</em>, <em class="sig-param">block_order=None</em>, <em class="sig-param">**blocks</em><span class="sig-paren">)</span><a class="reference internal" href="../modules/quspin/basis/basis_general/boson.html#boson_basis_general"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quspin.basis.boson_basis_general" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs basis for boson operators for USER-DEFINED symmetries.</p>
<p>Any unitary symmetry transformation <span class="math notranslate nohighlight">\(Q\)</span> of periodicity <span class="math notranslate nohighlight">\(m_Q\)</span> (<span class="math notranslate nohighlight">\(Q^{m_Q}=1\)</span>) has
eigenvalues <span class="math notranslate nohighlight">\(\exp(-2\pi i q/m_Q)\)</span>, labelled by an ingeter <span class="math notranslate nohighlight">\(q\in\{0,1,\dots,m_Q-1\}\)</span>.
These integers <span class="math notranslate nohighlight">\(q\)</span> are used to define the symmetry blocks.</p>
<p>For instance, if <span class="math notranslate nohighlight">\(Q=P\)</span> is parity (reflection), then <span class="math notranslate nohighlight">\(q=0,1\)</span>. If <span class="math notranslate nohighlight">\(Q=T\)</span> is translation by one lattice site,
then <span class="math notranslate nohighlight">\(q\)</span> labels the mometum blocks in the same fashion as for the <cite>…_basis_1d</cite> classes.</p>
<p>User-defined symmetries with the <cite>boson_basis_general</cite> class can be programmed as follows. Suppose we have a system of
L sites, enumerated <span class="math notranslate nohighlight">\(s=(s_0,s_1,\dots,s_{L-1})\)</span>. There are two types of operations one can perform on the sites:</p>
<blockquote>
<div><ul class="simple">
<li><p>exchange the labels of two sites: <span class="math notranslate nohighlight">\(s_i \leftrightarrow s_j\)</span> (e.g., translation, parity)</p></li>
<li><p>invert the population on a given site: <span class="math notranslate nohighlight">\(s_i\leftrightarrow -(s_j+1)\)</span> (e.g., particle-hole symmetry, hardcore bosons only)</p></li>
</ul>
</div></blockquote>
<p>These two operations already comprise a variety of symmetries, including translation, parity (reflection) and 
spin inversion. For a specific example, see below.</p>
<p>The supported operator strings for <cite>boson_basis_general</cite> are:</p>
<div class="math notranslate nohighlight">
\[\begin{array}{cccc}
        \texttt{basis}/\texttt{opstr}   &amp;   \texttt{&quot;I&quot;}   &amp;   \texttt{&quot;+&quot;}   &amp;   \texttt{&quot;-&quot;}  &amp;   \texttt{&quot;n&quot;}   &amp;   \texttt{&quot;z&quot;}     \newline        
        \texttt{boson_basis_general}&amp;   \hat{1}        &amp;   \hat b^\dagger      &amp;       \hat b          &amp; \hat b^\dagger b     &amp;  \hat b^\dagger\hat b - \frac{\mathrm{sps}-1}{2}  \newline
\end{array}\]</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>if <cite>Nb</cite> or <cite>nb</cite> are specified, by default <cite>sps</cite> is set to the number of bosons on the lattice.</p></li>
<li><dl class="simple">
<dt>if <cite>sps</cite> is specified, while <cite>Nb</cite> or <cite>nb</cite> are not, all particle sectors are filled up to the maximumal </dt><dd><p>occupation.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>if <cite>Nb</cite> or <cite>nb</cite> and <cite>sps</cite> are specified, the finite boson basis is constructed with the local Hilbert space </dt><dd><p>restrited by <cite>sps</cite>.</p>
</dd>
</dl>
</li>
<li><p>QuSpin raises a warning to alert the reader when non-commuting symmetries are passed. In such cases, we recommend the user to manually check the combined usage of symmetries by, e.g., comparing the eigenvalues.</p></li>
</ul>
<p class="rubric">Examples</p>
<p>The code snippet below shows how to construct the two-dimensional Bose-Hubbard model.</p>
<div class="math notranslate nohighlight">
\[H = -J \sum_{\langle ij\rangle} b^\dagger_i b_j + \mathrm{h.c.} - \mu\sum_j n_j + \frac{U}{2}\sum_j n_j(n_j-1)\]</div>
<p>Moreover, it demonstrates how to pass user-defined symmetries to the <cite>boson_basis_general</cite> constructor. In particular,
we do translation invariance and parity (reflection) (along each lattice direction).</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">quspin.operators</span> <span class="kn">import</span> <span class="n">hamiltonian</span> <span class="c1"># operators</span>
<span class="kn">from</span> <span class="nn">quspin.basis</span> <span class="kn">import</span> <span class="n">boson_basis_general</span> <span class="c1"># spin basis constructor</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> <span class="c1"># general math functions</span>
<span class="c1">#</span>
<span class="c1">###### define model parameters ######</span>
<span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span> <span class="c1"># linear dimension of spin 1 2d lattice</span>
<span class="n">N_2d</span> <span class="o">=</span> <span class="n">Lx</span><span class="o">*</span><span class="n">Ly</span> <span class="c1"># number of sites for spin 1</span>
<span class="c1">#</span>
<span class="n">J</span><span class="o">=</span><span class="mf">1.0</span> <span class="c1"># hopping matrix element</span>
<span class="n">U</span><span class="o">=</span><span class="mf">2.0</span> <span class="c1"># onsite interaction</span>
<span class="n">mu</span><span class="o">=</span><span class="mf">0.5</span> <span class="c1"># chemical potential</span>
<span class="c1">#</span>
<span class="c1">###### setting up user-defined symmetry transformations for 2d lattice ######</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N_2d</span><span class="p">)</span> <span class="c1"># sites [0,1,2,....]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="o">%</span><span class="n">Lx</span> <span class="c1"># x positions for sites</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">s</span><span class="o">//</span><span class="n">Lx</span> <span class="c1"># y positions for sites</span>
<span class="n">T_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">Lx</span> <span class="o">+</span> <span class="n">Lx</span><span class="o">*</span><span class="n">y</span> <span class="c1"># translation along x-direction</span>
<span class="n">T_y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span><span class="n">Lx</span><span class="o">*</span><span class="p">((</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">Ly</span><span class="p">)</span> <span class="c1"># translation along y-direction</span>
<span class="n">P_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">Lx</span><span class="o">*</span><span class="p">(</span><span class="n">Ly</span><span class="o">-</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># reflection about x-axis</span>
<span class="n">P_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">Lx</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Lx</span><span class="o">*</span><span class="n">y</span> <span class="c1"># reflection about y-axis</span>
<span class="c1">#</span>
<span class="c1">###### setting up bases ######</span>
<span class="n">basis_2d</span> <span class="o">=</span> <span class="n">boson_basis_general</span><span class="p">(</span><span class="n">N_2d</span><span class="p">,</span><span class="n">sps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">kxblock</span><span class="o">=</span><span class="p">(</span><span class="n">T_x</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">kyblock</span><span class="o">=</span><span class="p">(</span><span class="n">T_y</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">pxblock</span><span class="o">=</span><span class="p">(</span><span class="n">P_x</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">pyblock</span><span class="o">=</span><span class="p">(</span><span class="n">P_y</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="c1">#</span>
<span class="c1">###### setting up hamiltonian ######</span>
<span class="c1"># setting up site-coupling lists</span>
<span class="n">hopping</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="n">J</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">T_x</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_2d</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[[</span><span class="o">-</span><span class="n">J</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">T_y</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_2d</span><span class="p">)]</span>
<span class="n">potential</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="n">mu</span><span class="o">-</span><span class="n">U</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_2d</span><span class="p">)]</span>
<span class="n">interaction</span><span class="o">=</span><span class="p">[[</span><span class="n">U</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_2d</span><span class="p">)]</span>
<span class="c1">#</span>
<span class="n">static</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;+-&quot;</span><span class="p">,</span><span class="n">hopping</span><span class="p">],[</span><span class="s2">&quot;-+&quot;</span><span class="p">,</span><span class="n">hopping</span><span class="p">],[</span><span class="s2">&quot;n&quot;</span><span class="p">,</span><span class="n">potential</span><span class="p">],[</span><span class="s2">&quot;nn&quot;</span><span class="p">,</span><span class="n">interaction</span><span class="p">]]</span>
<span class="c1"># build hamiltonian</span>
<span class="n">H</span><span class="o">=</span><span class="n">hamiltonian</span><span class="p">(</span><span class="n">static</span><span class="p">,[],</span><span class="n">basis</span><span class="o">=</span><span class="n">basis_2d</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="c1"># diagonalise H</span>
<span class="n">E</span><span class="o">=</span><span class="n">H</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#quspin.basis.boson_basis_general.N" title="quspin.basis.boson_basis_general.N"><code class="xref py py-obj docutils literal notranslate"><span class="pre">N</span></code></a></dt><dd><p>int: number of sites the basis is constructed with.</p>
</dd>
<dt><a class="reference internal" href="#quspin.basis.boson_basis_general.Ns" title="quspin.basis.boson_basis_general.Ns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ns</span></code></a></dt><dd><p>int: number of states in the Hilbert space.</p>
</dd>
<dt><a class="reference internal" href="#quspin.basis.boson_basis_general.blocks" title="quspin.basis.boson_basis_general.blocks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">blocks</span></code></a></dt><dd><p>dict: contains the quantum numbers (blocks) for the symmetry sectors.</p>
</dd>
<dt><a class="reference internal" href="#quspin.basis.boson_basis_general.description" title="quspin.basis.boson_basis_general.description"><code class="xref py py-obj docutils literal notranslate"><span class="pre">description</span></code></a></dt><dd><p>str: information about <cite>basis</cite> object.</p>
</dd>
<dt><a class="reference internal" href="#quspin.basis.boson_basis_general.dtype" title="quspin.basis.boson_basis_general.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></dt><dd><p>numpy.dtype: data type of basis state integers.</p>
</dd>
<dt><a class="reference internal" href="#quspin.basis.boson_basis_general.operators" title="quspin.basis.boson_basis_general.operators"><code class="xref py py-obj docutils literal notranslate"><span class="pre">operators</span></code></a></dt><dd><p>set: set of available operator strings.</p>
</dd>
<dt><a class="reference internal" href="#quspin.basis.boson_basis_general.sps" title="quspin.basis.boson_basis_general.sps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sps</span></code></a></dt><dd><p>int: number of states per site (i.e. the on-site Hilbert space dimension).</p>
</dd>
<dt><a class="reference internal" href="#quspin.basis.boson_basis_general.states" title="quspin.basis.boson_basis_general.states"><code class="xref py py-obj docutils literal notranslate"><span class="pre">states</span></code></a></dt><dd><p>numpy.ndarray(int): basis states stored in their integer representation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.Op" title="quspin.basis.boson_basis_general.Op"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Op</span></code></a>(opstr, indx, J, dtype)</p></td>
<td><p>Constructs operator from a site-coupling list and an operator string in a lattice basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.Op_bra_ket" title="quspin.basis.boson_basis_general.Op_bra_ket"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Op_bra_ket</span></code></a>(opstr, indx, J, dtype, ket_states)</p></td>
<td><p>Finds bra states which connect given ket states by operator from a site-coupling list and an operator string.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.Op_shift_sector" title="quspin.basis.boson_basis_general.Op_shift_sector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Op_shift_sector</span></code></a>(other_basis, op_list, v_in)</p></td>
<td><p>Applies symmetry non-conserving operator to state in symmetry-reduced basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.check_hermitian" title="quspin.basis.boson_basis_general.check_hermitian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_hermitian</span></code></a>(static, dynamic)</p></td>
<td><p>Checks operator string lists for hermiticity of the combined operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.check_pcon" title="quspin.basis.boson_basis_general.check_pcon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_pcon</span></code></a>(static, dynamic)</p></td>
<td><p>Checks operator string lists for particle number (magnetisation) conservartion of the combined operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.check_symm" title="quspin.basis.boson_basis_general.check_symm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_symm</span></code></a>(static, dynamic)</p></td>
<td><p>Checks operator string lists for the required symmetries of the combined operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.ent_entropy" title="quspin.basis.boson_basis_general.ent_entropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ent_entropy</span></code></a>(state[, sub_sys_A, density, …])</p></td>
<td><p>Calculates entanglement entropy of subsystem A and the corresponding reduced density matrix</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.expanded_form" title="quspin.basis.boson_basis_general.expanded_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expanded_form</span></code></a>([static, dynamic])</p></td>
<td><p>Splits up operator strings containing “x” and “y” into operator combinations of “+” and “-“.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.get_amp" title="quspin.basis.boson_basis_general.get_amp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_amp</span></code></a>(states[, out, amps, mode])</p></td>
<td><p>Computes the rescale factor of state amplitudes between the symmetry-reduced and full basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.get_proj" title="quspin.basis.boson_basis_general.get_proj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_proj</span></code></a>(dtype[, pcon])</p></td>
<td><p>Calculates transformation/projector from symmetry-reduced basis to full (symmetry-free) basis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.get_vec" title="quspin.basis.boson_basis_general.get_vec"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_vec</span></code></a>(v0[, sparse, pcon])</p></td>
<td><p>DEPRECATED (cf <cite>project_from</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.index" title="quspin.basis.boson_basis_general.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a>(s)</p></td>
<td><p>Finds the index of user-defined Fock state in any lattice basis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.inplace_Op" title="quspin.basis.boson_basis_general.inplace_Op"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inplace_Op</span></code></a>(v_in, op_list, dtype[, …])</p></td>
<td><p>Calculates the action of an operator on a state.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.int_to_state" title="quspin.basis.boson_basis_general.int_to_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int_to_state</span></code></a>(state[, bracket_notation])</p></td>
<td><p>Finds string representation of a state defined in integer representation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.make" title="quspin.basis.boson_basis_general.make"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make</span></code></a>([Ns_block_est, N_p])</p></td>
<td><p>Creates the entire basis by calling the basis constructor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.make_basis_blocks" title="quspin.basis.boson_basis_general.make_basis_blocks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_basis_blocks</span></code></a>([N_p])</p></td>
<td><p>Creates/modifies the bounds for representatives based on prefix tages.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.normalization" title="quspin.basis.boson_basis_general.normalization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalization</span></code></a>(states[, out])</p></td>
<td><p>Computes normalization of <cite>basis</cite> states.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.partial_trace" title="quspin.basis.boson_basis_general.partial_trace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partial_trace</span></code></a>(state[, sub_sys_A, …])</p></td>
<td><p>Calculates reduced density matrix, through a partial trace of a quantum state in a lattice <cite>basis</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.project_from" title="quspin.basis.boson_basis_general.project_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">project_from</span></code></a>(v0[, sparse, pcon])</p></td>
<td><p>Transforms state from symmetry-reduced basis to full (symmetry-free) basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.project_to" title="quspin.basis.boson_basis_general.project_to"><code class="xref py py-obj docutils literal notranslate"><span class="pre">project_to</span></code></a>(v0[, sparse, pcon])</p></td>
<td><p>Transforms state from full (symmetry-free) basis to symmetry-reduced basis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.representative" title="quspin.basis.boson_basis_general.representative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">representative</span></code></a>(states[, out, return_g, …])</p></td>
<td><p>Maps states to their representatives under the <cite>basis</cite> symmetries.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.state_to_int" title="quspin.basis.boson_basis_general.state_to_int"><code class="xref py py-obj docutils literal notranslate"><span class="pre">state_to_int</span></code></a>(state)</p></td>
<td><p>Finds integer representation of a state defined in string format.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="quspin.basis.boson_basis_general.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">Nb=None</em>, <em class="sig-param">nb=None</em>, <em class="sig-param">sps=None</em>, <em class="sig-param">Ns_block_est=None</em>, <em class="sig-param">make_basis=True</em>, <em class="sig-param">block_order=None</em>, <em class="sig-param">**blocks</em><span class="sig-paren">)</span><a class="reference internal" href="../modules/quspin/basis/basis_general/boson.html#boson_basis_general.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quspin.basis.boson_basis_general.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Intializes the <cite>boson_basis_general</cite> object (basis for bosonic operators).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>N: int</strong></dt><dd><p>Number of sites.</p>
</dd>
<dt><strong>Nb: {int,list}, optional</strong></dt><dd><p>Number of bosons in chain. Can be integer or list to specify one or more particle sectors.</p>
</dd>
<dt><strong>nb: float, optional</strong></dt><dd><p>Density of bosons in chain (bosons per site).</p>
</dd>
<dt><strong>sps: int, optional</strong></dt><dd><p>Number of states per site (including zero bosons), or on-site Hilbert space dimension.</p>
</dd>
<dt><strong>Ns_block_est: int, optional</strong></dt><dd><p>Overwrites the internal estimate of the size of the reduced Hilbert space for the given symmetries. This can be used to help conserve memory if the exact size of the H-space is known ahead of time.</p>
</dd>
<dt><strong>make_basis: bool, optional</strong></dt><dd><p>Boolean to control whether to make the basis. Allows the use to use some functionality of the basis constructor without constructing the entire basis.</p>
</dd>
<dt><strong>block_order: list of strings, optional</strong></dt><dd><p>A list of strings containing the names of the symmetry blocks which specifies the order in which the symmetries will be applied to the state when calculating the basis. The first element in the list is applied to the state first followed by the second element, etc. If the list is not specificed the ordering is such that the symmetry with the largest cycle is the first, followed by the second largest, etc.</p>
</dd>
<dt><strong>**blocks: optional</strong></dt><dd><p>keyword arguments which pass the symmetry generator arrays. For instance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="p">(</span><span class="o">...</span><span class="p">,</span><span class="n">kxblock</span><span class="o">=</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">q</span><span class="p">),</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>The keys of the symmetry sector, e.g. <cite>kxblock</cite>, can be chosen arbitrarily by the user. The
values are tuples where the first entry contains the symmetry transformation <span class="math notranslate nohighlight">\(Q\)</span> acting on the
lattice sites (see class example), and the second entry is an integer <span class="math notranslate nohighlight">\(q\)</span> to label the symmetry
sector.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.Op" title="quspin.basis.boson_basis_general.Op"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Op</span></code></a>(opstr, indx, J, dtype)</p></td>
<td><p>Constructs operator from a site-coupling list and an operator string in a lattice basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.Op_bra_ket" title="quspin.basis.boson_basis_general.Op_bra_ket"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Op_bra_ket</span></code></a>(opstr, indx, J, dtype, ket_states)</p></td>
<td><p>Finds bra states which connect given ket states by operator from a site-coupling list and an operator string.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.Op_shift_sector" title="quspin.basis.boson_basis_general.Op_shift_sector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Op_shift_sector</span></code></a>(other_basis, op_list, v_in)</p></td>
<td><p>Applies symmetry non-conserving operator to state in symmetry-reduced basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.__init__" title="quspin.basis.boson_basis_general.__init__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code></a>(N[, Nb, nb, sps, Ns_block_est, …])</p></td>
<td><p>Intializes the <cite>boson_basis_general</cite> object (basis for bosonic operators).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.check_hermitian" title="quspin.basis.boson_basis_general.check_hermitian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_hermitian</span></code></a>(static, dynamic)</p></td>
<td><p>Checks operator string lists for hermiticity of the combined operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.check_pcon" title="quspin.basis.boson_basis_general.check_pcon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_pcon</span></code></a>(static, dynamic)</p></td>
<td><p>Checks operator string lists for particle number (magnetisation) conservartion of the combined operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.check_symm" title="quspin.basis.boson_basis_general.check_symm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_symm</span></code></a>(static, dynamic)</p></td>
<td><p>Checks operator string lists for the required symmetries of the combined operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.ent_entropy" title="quspin.basis.boson_basis_general.ent_entropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ent_entropy</span></code></a>(state[, sub_sys_A, density, …])</p></td>
<td><p>Calculates entanglement entropy of subsystem A and the corresponding reduced density matrix</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.expanded_form" title="quspin.basis.boson_basis_general.expanded_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expanded_form</span></code></a>([static, dynamic])</p></td>
<td><p>Splits up operator strings containing “x” and “y” into operator combinations of “+” and “-“.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.get_amp" title="quspin.basis.boson_basis_general.get_amp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_amp</span></code></a>(states[, out, amps, mode])</p></td>
<td><p>Computes the rescale factor of state amplitudes between the symmetry-reduced and full basis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.get_proj" title="quspin.basis.boson_basis_general.get_proj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_proj</span></code></a>(dtype[, pcon])</p></td>
<td><p>Calculates transformation/projector from symmetry-reduced basis to full (symmetry-free) basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.get_vec" title="quspin.basis.boson_basis_general.get_vec"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_vec</span></code></a>(v0[, sparse, pcon])</p></td>
<td><p>DEPRECATED (cf <cite>project_from</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.index" title="quspin.basis.boson_basis_general.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a>(s)</p></td>
<td><p>Finds the index of user-defined Fock state in any lattice basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.inplace_Op" title="quspin.basis.boson_basis_general.inplace_Op"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inplace_Op</span></code></a>(v_in, op_list, dtype[, …])</p></td>
<td><p>Calculates the action of an operator on a state.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.int_to_state" title="quspin.basis.boson_basis_general.int_to_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int_to_state</span></code></a>(state[, bracket_notation])</p></td>
<td><p>Finds string representation of a state defined in integer representation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.make" title="quspin.basis.boson_basis_general.make"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make</span></code></a>([Ns_block_est, N_p])</p></td>
<td><p>Creates the entire basis by calling the basis constructor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.make_basis_blocks" title="quspin.basis.boson_basis_general.make_basis_blocks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_basis_blocks</span></code></a>([N_p])</p></td>
<td><p>Creates/modifies the bounds for representatives based on prefix tages.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.normalization" title="quspin.basis.boson_basis_general.normalization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalization</span></code></a>(states[, out])</p></td>
<td><p>Computes normalization of <cite>basis</cite> states.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.partial_trace" title="quspin.basis.boson_basis_general.partial_trace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partial_trace</span></code></a>(state[, sub_sys_A, …])</p></td>
<td><p>Calculates reduced density matrix, through a partial trace of a quantum state in a lattice <cite>basis</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.representative" title="quspin.basis.boson_basis_general.representative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">representative</span></code></a>(states[, out, return_g, …])</p></td>
<td><p>Maps states to their representatives under the <cite>basis</cite> symmetries.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.state_to_int" title="quspin.basis.boson_basis_general.state_to_int"><code class="xref py py-obj docutils literal notranslate"><span class="pre">state_to_int</span></code></a>(state)</p></td>
<td><p>Finds integer representation of a state defined in string format.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.N" title="quspin.basis.boson_basis_general.N"><code class="xref py py-obj docutils literal notranslate"><span class="pre">N</span></code></a></p></td>
<td><p>int: number of sites the basis is constructed with.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.Ns" title="quspin.basis.boson_basis_general.Ns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ns</span></code></a></p></td>
<td><p>int: number of states in the Hilbert space.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.blocks" title="quspin.basis.boson_basis_general.blocks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">blocks</span></code></a></p></td>
<td><p>dict: contains the quantum numbers (blocks) for the symmetry sectors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.description" title="quspin.basis.boson_basis_general.description"><code class="xref py py-obj docutils literal notranslate"><span class="pre">description</span></code></a></p></td>
<td><p>str: information about <cite>basis</cite> object.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.dtype" title="quspin.basis.boson_basis_general.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></p></td>
<td><p>numpy.dtype: data type of basis state integers.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.operators" title="quspin.basis.boson_basis_general.operators"><code class="xref py py-obj docutils literal notranslate"><span class="pre">operators</span></code></a></p></td>
<td><p>set: set of available operator strings.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.sps" title="quspin.basis.boson_basis_general.sps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sps</span></code></a></p></td>
<td><p>int: number of states per site (i.e.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#quspin.basis.boson_basis_general.states" title="quspin.basis.boson_basis_general.states"><code class="xref py py-obj docutils literal notranslate"><span class="pre">states</span></code></a></p></td>
<td><p>numpy.ndarray(int): basis states stored in their integer representation.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="quspin.basis.boson_basis_general.N">
<em class="property">property </em><code class="sig-name descname">N</code><a class="headerlink" href="#quspin.basis.boson_basis_general.N" title="Permalink to this definition">¶</a></dt>
<dd><p>int: number of sites the basis is constructed with.</p>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.Ns">
<em class="property">property </em><code class="sig-name descname">Ns</code><a class="headerlink" href="#quspin.basis.boson_basis_general.Ns" title="Permalink to this definition">¶</a></dt>
<dd><p>int: number of states in the Hilbert space.</p>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.Op">
<code class="sig-name descname">Op</code><span class="sig-paren">(</span><em class="sig-param">opstr</em>, <em class="sig-param">indx</em>, <em class="sig-param">J</em>, <em class="sig-param">dtype</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.Op" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs operator from a site-coupling list and an operator string in a lattice basis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>opstr</strong><span class="classifier">str</span></dt><dd><p>Operator string in the lattice basis format. For instance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">opstr</span> <span class="o">=</span> <span class="s2">&quot;zz&quot;</span>
</pre></div>
</div>
</dd>
<dt><strong>indx</strong><span class="classifier">list(int)</span></dt><dd><p>List of integers to designate the sites the lattice basis operator is defined on. For instance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</dd>
<dt><strong>J</strong><span class="classifier">scalar</span></dt><dd><p>Coupling strength.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">‘type’</span></dt><dd><p>Data type (e.g. numpy.float64) to construct the operator with.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tuple</strong></dt><dd><dl class="simple">
<dt><cite>(ME,row,col)</cite>, where</dt><dd><ul class="simple">
<li><p>numpy.ndarray(scalar): <cite>ME</cite>: matrix elements of type <cite>dtype</cite>.</p></li>
<li><dl class="simple">
<dt>numpy.ndarray(int): <cite>row</cite>: row indices of matrix representing the operator in the lattice basis,</dt><dd><p>such that <cite>row[i]</cite> is the row index of <cite>ME[i]</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>numpy.ndarray(int): <cite>col</cite>: column index of matrix representing the operator in the lattice basis,</dt><dd><p>such that <cite>col[i]</cite> is the column index of <cite>ME[i]</cite>.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="mf">1.41</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opstr</span> <span class="o">=</span> <span class="s2">&quot;zz&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ME</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">Op</span><span class="p">(</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.Op_bra_ket">
<code class="sig-name descname">Op_bra_ket</code><span class="sig-paren">(</span><em class="sig-param">opstr</em>, <em class="sig-param">indx</em>, <em class="sig-param">J</em>, <em class="sig-param">dtype</em>, <em class="sig-param">ket_states</em>, <em class="sig-param">reduce_output=True</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.Op_bra_ket" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds bra states which connect given ket states by operator from a site-coupling list and an operator string.</p>
<p>Given a set of ket states <span class="math notranslate nohighlight">\(|s\rangle\)</span>, the function returns the bra states <span class="math notranslate nohighlight">\(\langle s'|\)</span> which connect to them through an operator, together with the corresponding matrix elements.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>opstr</strong><span class="classifier">str</span></dt><dd><p>Operator string in the lattice basis format. For instance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">opstr</span> <span class="o">=</span> <span class="s2">&quot;zz&quot;</span>
</pre></div>
</div>
</dd>
<dt><strong>indx</strong><span class="classifier">list(int)</span></dt><dd><p>List of integers to designate the sites the lattice basis operator is defined on. For instance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</dd>
<dt><strong>J</strong><span class="classifier">scalar</span></dt><dd><p>Coupling strength.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">‘type’</span></dt><dd><p>Data type (e.g. numpy.float64) to construct the matrix elements with.</p>
</dd>
<dt><strong>ket_states</strong><span class="classifier">numpy.ndarray(int)</span></dt><dd><p>Ket states in integer representation. Must be of same data type as <cite>basis</cite>.</p>
</dd>
<dt><strong>reduce_output: bool, optional</strong></dt><dd><p>If set to <cite>True</cite>, the returned arrays have the same size as <cite>ket_states</cite>; If set to <cite>False</cite> zeros are purged.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tuple</strong></dt><dd><dl class="simple">
<dt><cite>(ME,bra,ket)</cite>, where</dt><dd><ul class="simple">
<li><p>numpy.ndarray(scalar): <cite>ME</cite>: matrix elements of type <cite>dtype</cite>, which connects the ket and bra states.</p></li>
<li><dl class="simple">
<dt>numpy.ndarray(int): <cite>bra</cite>: bra states, obtained by applying the matrix representing the operator in the lattice basis,</dt><dd><p>to the ket states, such that <cite>bra[i]</cite> corresponds to <cite>ME[i]</cite> and connects to <cite>ket[i]</cite>.</p>
</dd>
</dl>
</li>
<li><p>numpy.ndarray(int): <cite>ket</cite>: ket states, such that <cite>ket[i]</cite> corresponds to <cite>ME[i]</cite> and connects to <cite>bra[i]</cite>.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Similar to <cite>Op</cite> but instead of returning the matrix indices (row,col), it returns the states (bra,ket) in integer representation.</p></li>
<li><p>Does NOT require the full basis (see <cite>basis</cite> optional argument <cite>make_basis</cite>).</p></li>
<li><p>If a state from <cite>ket_states</cite> does not have a non-zero matrix element, it is removed from the returned list. See otional argument <cite>reduce_output</cite>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="mf">1.41</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opstr</span> <span class="o">=</span> <span class="s2">&quot;zz&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ME</span><span class="p">,</span> <span class="n">bra</span><span class="p">,</span> <span class="n">ket</span> <span class="o">=</span> <span class="n">Op_bra_ket</span><span class="p">(</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">ket_states</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.Op_shift_sector">
<code class="sig-name descname">Op_shift_sector</code><span class="sig-paren">(</span><em class="sig-param">other_basis</em>, <em class="sig-param">op_list</em>, <em class="sig-param">v_in</em>, <em class="sig-param">v_out=None</em>, <em class="sig-param">dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.Op_shift_sector" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies symmetry non-conserving operator to state in symmetry-reduced basis.</p>
<p>An operator, which does not conserve a symmetry, induces a change in the quantum number of a state defined in the corresponding symmetry sector. Hence, when the operator is applied on a quantum state, the state shifts the symmetry sector. <cite>Op_shift_sector()</cite> handles this automatically.</p>
<p><span class="red">NOTE: One has to make sure that the operator moves the state between the two sectors this function will not give the correct results otherwise.</span></p>
<p>Formally  equivalent to:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P1</span> <span class="o">=</span> <span class="n">basis_sector_1</span><span class="o">.</span><span class="n">get_proj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span> <span class="c1"># projector between full and initial basis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P2</span> <span class="o">=</span> <span class="n">basis_sector_2</span><span class="o">.</span><span class="n">get_proj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span> <span class="c1"># projector between full and target basis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v_in_full</span> <span class="o">=</span> <span class="n">P1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v_in</span><span class="p">)</span> <span class="c1"># go from initial basis to to full basis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v_out_full</span> <span class="o">=</span> <span class="n">basis_full</span><span class="o">.</span><span class="n">inplace_Op</span><span class="p">(</span><span class="n">v_in_full</span><span class="p">,</span><span class="n">op_list</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span> <span class="c1"># apply Op</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v_out</span> <span class="o">=</span> <span class="n">P2</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v_out_full</span><span class="p">)</span> <span class="c1"># project to target basis</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>other_basis</strong><span class="classifier"><cite>basis</cite> object</span></dt><dd><p><cite>basis_general</cite> object for the initial symmetry sector. Must be the same <cite>basis</cite> class type as the basis whose instance is <cite>Op_shift_sector()</cite> (i.e. the basis in <cite>basis.Op_shift_sector()</cite>).</p>
</dd>
<dt><strong>op_list</strong><span class="classifier">list</span></dt><dd><p>Operator string list which defines the operator to apply. Follows the format <cite>[[“z”,[i],Jz[i]] for i in range(L)], [“x”,[i],Jx[j]] for j in range(L)],…]</cite>.</p>
</dd>
<dt><strong>v_in</strong><span class="classifier">array_like, (other_basis.Ns,…)</span></dt><dd><p>Initial state to apply the symmetry non-conserving operator on. Must have the same length as <cite>other_basis.Ns</cite>.</p>
</dd>
<dt><strong>v_out</strong><span class="classifier">array_like, (basis.Ns,…), optional</span></dt><dd><p>Optional array to write the result for the final/target state in.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">numpy dtype for matrix elements, optional</span></dt><dd><p>Data type (e.g. <cite>numpy.float64</cite>) to construct the operator with.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>(basis.Ns, ) numpy.ndarray</strong></dt><dd><p>Array containing the state <cite>v_out</cite> in the current basis, i.e. the basis in <cite>basis.Op_shift_sector()</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>particularly useful when computing correlation functions.</p></li>
<li><p>supports parallelization to multiple states listed in the columns of <cite>v_in</cite>.</p></li>
<li><p>the user is strongly advised to use the code under “Formally equivalent” above to check the results of this function for small system sizes.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v_out</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">Op_shift_sector</span><span class="p">(</span><span class="n">initial_basis</span><span class="p">,</span> <span class="n">op_list</span><span class="p">,</span> <span class="n">v_in</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">v_out</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span> <span class="n">v_in</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">initial_basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.blocks">
<em class="property">property </em><code class="sig-name descname">blocks</code><a class="headerlink" href="#quspin.basis.boson_basis_general.blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>dict: contains the quantum numbers (blocks) for the symmetry sectors.</p>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.check_hermitian">
<code class="sig-name descname">check_hermitian</code><span class="sig-paren">(</span><em class="sig-param">static</em>, <em class="sig-param">dynamic</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.check_hermitian" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks operator string lists for hermiticity of the combined operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static: list</strong></dt><dd><p>Static operators formatted to be passed into the static argument of the <cite>hamiltonian</cite> class.</p>
</dd>
<dt><strong>dynamic: list</strong></dt><dd><p>Dynamic operators formatted to be passed into the dynamic argument of the <cite>hamiltonian</cite> class.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.check_pcon">
<code class="sig-name descname">check_pcon</code><span class="sig-paren">(</span><em class="sig-param">static</em>, <em class="sig-param">dynamic</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.check_pcon" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks operator string lists for particle number (magnetisation) conservartion of the combined operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static: list</strong></dt><dd><p>Static operators formatted to be passed into the static argument of the <cite>hamiltonian</cite> class.</p>
</dd>
<dt><strong>dynamic: list</strong></dt><dd><p>Dynamic operators formatted to be passed into the dynamic argument of the <cite>hamiltonian</cite> class.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.check_symm">
<code class="sig-name descname">check_symm</code><span class="sig-paren">(</span><em class="sig-param">static</em>, <em class="sig-param">dynamic</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.check_symm" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks operator string lists for the required symmetries of the combined operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static: list</strong></dt><dd><p>Static operators formatted to be passed into the static argument of the <cite>hamiltonian</cite> class.</p>
</dd>
<dt><strong>dynamic: list</strong></dt><dd><p>Dynamic operators formatted to be passed into the dynamic argument of the <cite>hamiltonian</cite> class.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.description">
<em class="property">property </em><code class="sig-name descname">description</code><a class="headerlink" href="#quspin.basis.boson_basis_general.description" title="Permalink to this definition">¶</a></dt>
<dd><p>str: information about <cite>basis</cite> object.</p>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.dtype">
<em class="property">property </em><code class="sig-name descname">dtype</code><a class="headerlink" href="#quspin.basis.boson_basis_general.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>numpy.dtype: data type of basis state integers.</p>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.ent_entropy">
<code class="sig-name descname">ent_entropy</code><span class="sig-paren">(</span><em class="sig-param">state</em>, <em class="sig-param">sub_sys_A=None</em>, <em class="sig-param">density=True</em>, <em class="sig-param">subsys_ordering=True</em>, <em class="sig-param">return_rdm=None</em>, <em class="sig-param">enforce_pure=False</em>, <em class="sig-param">return_rdm_EVs=False</em>, <em class="sig-param">sparse=False</em>, <em class="sig-param">alpha=1.0</em>, <em class="sig-param">sparse_diag=True</em>, <em class="sig-param">maxiter=None</em>, <em class="sig-param">svd_solver=None</em>, <em class="sig-param">svd_kwargs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.ent_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates entanglement entropy of subsystem A and the corresponding reduced density matrix</p>
<div class="math notranslate nohighlight">
\[S_\mathrm{ent}(\alpha) = \frac{1}{N}\frac{1}{1-\alpha}\log \mathrm{tr}_{A} \left( \mathrm{tr}_{A^c} \vert\psi\rangle\langle\psi\vert \right)^\alpha \]</div>
<p>where the normalization <span class="math notranslate nohighlight">\(N\)</span> can be switched on and off using the optional argument <cite>density</cite>.</p>
<p><strong>Note:</strong> The logarithm used is the natural logarithm (base e).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier">obj</span></dt><dd><p>State of the quantum system. Can be either one of:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy.ndarray [shape (Ns,)]: pure state (default).</p></li>
<li><p>numpy.ndarray [shape (Ns,Ns)]: density matrix (DM).</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>sub_sys_A</strong><span class="classifier">tuple/list, optional</span></dt><dd><p>Defines the sites contained in subsystem A [by python convention the first site of the chain is labelled j=0].
Default is <cite>tuple(range(N//2))</cite> with <cite>N</cite> the number of lattice sites.</p>
</dd>
<dt><strong>density</strong><span class="classifier">bool, optional</span></dt><dd><p>Toggles whether to return entanglement entropy normalized by the number of sites in the subsystem.</p>
</dd>
<dt><strong>return_rdm</strong><span class="classifier">str, optional</span></dt><dd><p>Toggles returning the reduced DM. Can be tierh one of:</p>
<blockquote>
<div><ul class="simple">
<li><p>“A”: returns reduced DM of subsystem A.</p></li>
<li><p>“B”: returns reduced DM of subsystem B.</p></li>
<li><p>“both”: returns reduced DM of both A and B subsystems.</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>enforce_pure</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to assume <cite>state</cite> is a collection of pure states or a mixed density matrix, if
it is a square array. Default is <cite>False</cite>.</p>
</dd>
<dt><strong>subsys_ordering</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to reorder the sites in <cite>sub_sys_A</cite> in ascending order. Default is <cite>True</cite>.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to return a sparse DM. Default is <cite>False</cite>.</p>
</dd>
<dt><strong>return_rdm_EVs</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to return the eigenvalues of rthe educed DM. If <cite>return_rdm</cite> is specified,
the eigenvalues of the corresponding DM are returned. If <cite>return_rdm</cite> is NOT specified, 
the spectrum of <cite>rdm_A</cite> is returned by default. Default is <cite>False</cite>.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, optional</span></dt><dd><p>Renyi <span class="math notranslate nohighlight">\(\alpha\)</span> parameter for the entanglement entropy. Default is <span class="math notranslate nohighlight">\(\alpha=1\)</span>.</p>
</dd>
<dt><strong>sparse_diag</strong><span class="classifier">bool, optional</span></dt><dd><p>When <cite>sparse=True</cite>, this flag enforces the use of
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/generated/scipy.sparse.linalg.eigsh.html">scipy.sparse.linalg.eigsh()</a>
to calculate the eigenvaues of the reduced DM.</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int, optional</span></dt><dd><p>Specifies the number of iterations for Lanczos diagonalisation. Look up documentation for 
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/generated/scipy.sparse.linalg.eigsh.html">scipy.sparse.linalg.eigsh()</a>.</p>
</dd>
<dt><strong>svd_solver</strong><span class="classifier">object, optional</span></dt><dd><p>Specifies the svd solver to be used, e.g. <cite>numpy.linalg.svd</cite> or <cite>scipy.linalg.svd</cite>, or a custom solver. Effective when <cite>enforce_pure=True</cite> or <cite>sparse=False</cite>.</p>
</dd>
<dt><strong>svd_kwargs</strong><span class="classifier">dict, optional</span></dt><dd><p>Specifies additional arguments for <cite>svd_solver</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dict</strong></dt><dd><dl class="simple">
<dt>Dictionary with following keys, depending on input parameters:</dt><dd><ul class="simple">
<li><p>“Sent_A”: entanglement entropy of subsystem A (default).</p></li>
<li><p>“Sent_B”: entanglement entropy of subsystem B.</p></li>
<li><p>“p_A”: singular values of reduced DM of subsystem A (default).</p></li>
<li><p>“p_B”: singular values of reduced DM of subsystem B.</p></li>
<li><p>“rdm_A”: reduced DM of subsystem A.</p></li>
<li><p>“rdm_B”: reduced DM of subsystem B.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Algorithm is based on both partial tracing and sigular value decomposition (SVD), optimised for speed.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ent_entropy</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">sub_sys_A</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span><span class="n">return_rdm</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="n">enforce_pure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">return_rdm_EVs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                            <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">sparse_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">subsys_ordering</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.expanded_form">
<code class="sig-name descname">expanded_form</code><span class="sig-paren">(</span><em class="sig-param">static=[]</em>, <em class="sig-param">dynamic=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.expanded_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits up operator strings containing “x” and “y” into operator combinations of “+” and “-“. This function is useful for higher spin hamiltonians where “x” and “y” operators are not appropriate operators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static: list</strong></dt><dd><p>Static operators formatted to be passed into the static argument of the <cite>hamiltonian</cite> class.</p>
</dd>
<dt><strong>dynamic: list</strong></dt><dd><p>Dynamic operators formatted to be passed into the dynamic argument of the <cite>hamiltonian</cite> class.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tuple</strong></dt><dd><dl class="simple">
<dt><cite>(static, dynamic)</cite>, where</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>list: <cite>static</cite>: operator strings with “x” and “y” expanded into “+” and “-“, formatted to </dt><dd><p>be passed into the static argument of the <cite>hamiltonian</cite> class.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>list: <cite>dynamic</cite>: operator strings with “x” and “y” expanded into “+” and “-“, formatted to </dt><dd><p>be passed into the dynamic argument of the <cite>hamiltonian</cite> class.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function works with the <cite>tensor_basis</cite> and other basis which use the “|” symbol in the opstr.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">static</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;xx&quot;</span><span class="p">,[[</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]],[</span><span class="s2">&quot;yy&quot;</span><span class="p">,[[</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dynamic</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;y&quot;</span><span class="p">,[[</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">,[]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expanded_form</span><span class="p">(</span><span class="n">static</span><span class="p">,</span><span class="n">dynamic</span><span class="p">)</span>               
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.get_amp">
<code class="sig-name descname">get_amp</code><span class="sig-paren">(</span><em class="sig-param">states</em>, <em class="sig-param">out=None</em>, <em class="sig-param">amps=None</em>, <em class="sig-param">mode='representative'</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.get_amp" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the rescale factor of state amplitudes between the symmetry-reduced and full basis.</p>
<p>Given a quantum state <span class="math notranslate nohighlight">\(s\)</span> and a state amplitude in the full basis <span class="math notranslate nohighlight">\(\psi_s\)</span>, its representative (under the symemtries) 
<span class="math notranslate nohighlight">\(r(s)\)</span> with a corresponding amplitude <span class="math notranslate nohighlight">\(\psi^\text{sym}_r\)</span>, the function computes the ratio <span class="math notranslate nohighlight">\(C\)</span>, defined as</p>
<div class="math notranslate nohighlight">
\[\psi_s = C\psi_r^\text{sym} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>states</strong><span class="classifier">array_like(int)</span></dt><dd><p>Fock-basis (z-basis) states to find the amplitude rescale factor <span class="math notranslate nohighlight">\(C\)</span> of. States are stored in integer representations.</p>
</dd>
<dt><strong>out</strong><span class="classifier">numpy.ndarray(float), optional</span></dt><dd><p>variable to store the rescale factors <span class="math notranslate nohighlight">\(C\)</span> of the states in. Must be a real or complex-valued <cite>numpy.ndarray</cite> of the same shape as <cite>states</cite>.</p>
</dd>
<dt><strong>amps</strong><span class="classifier">numpy.ndarray(float), optional</span></dt><dd><p>array of amplitudes to rescale by the amplitude factor <span class="math notranslate nohighlight">\(C\)</span> (see <cite>mode</cite>). Updated in-place. Must be a real or complex-valued <cite>numpy.ndarray</cite> of the same shape as <cite>states</cite>.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">string, optional</span></dt><dd><ul class="simple">
<li><dl class="simple">
<dt>if <cite>mode=’representative’</cite> (default), then the function assumes that</dt><dd><ol class="lowerroman simple">
<li><p><cite>states</cite> already contains representatives (i.e. states in the symmetry-reduced basis);</p></li>
<li><p><cite>amps</cite> (if passed) are amplitudes in the symmetry-reduced basis (<span class="math notranslate nohighlight">\(\psi_r^\text{symm}\)</span>). The function will update <cite>amps</cite> in-place to <span class="math notranslate nohighlight">\(\psi_s\)</span>.</p></li>
</ol>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>if <cite>mode=’full_basis’</cite>, then the function assumes that</dt><dd><ol class="lowerroman simple">
<li><p><cite>states</cite> contains full-basis states (the funciton will compute the corresponding representatives);</p></li>
<li><dl class="simple">
<dt><cite>amps</cite> (if passed) are amplitudes in the full basis (<span class="math notranslate nohighlight">\(\psi_s\)</span>). The function will update <cite>amps</cite> in-place to <span class="math notranslate nohighlight">\(\psi_r^\text{symm}\)</span>;</dt><dd><p><strong>Note</strong>: the function will also update the variable <cite>states</cite> in place with the corresponding representatives.</p>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>array_like(float)</strong></dt><dd><p>amplitude rescale factor <span class="math notranslate nohighlight">\(C\)</span> (see expression above).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Particularly useful when a given operation cannot be carried away in the symmetry-reduced basis in a straightforward manner.</p></li>
<li><p>To transform an entire state from a symmetry-reduced basis to the full (symmetry-free) basis, use the <cite>basis.get_vec()</cite> function.</p></li>
<li><p>Returns zero, if the state passed to the function is not part of the symmetry-reduced basis.</p></li>
<li><p>If <cite>amps</cite> is passed, the user has to make sure that the input data in <cite>amps</cite> correspond to the <cite>states</cite>.</p></li>
<li><p>The function assumes that <cite>states</cite> comply with the particle conservation symmetry the <cite>basis</cite> was constructed with.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">get_amp</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">amps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;representative&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.get_proj">
<code class="sig-name descname">get_proj</code><span class="sig-paren">(</span><em class="sig-param">dtype</em>, <em class="sig-param">pcon=False</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.get_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates transformation/projector from symmetry-reduced basis to full (symmetry-free) basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">‘type’</span></dt><dd><p>Data type (e.g. numpy.float64) to construct the projector with.</p>
</dd>
<dt><strong>pcon</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to return the projector to the particle number (magnetisation) conserving basis 
(useful in bosonic/single particle systems). Default is <cite>pcon=False</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scipy.sparse.csc_matrix</strong></dt><dd><p>Transformation/projector between the symmetry-reduced and the full basis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>particularly useful when a given operation canot be carried out in the symmetry-reduced basis</p></li>
</ul>
<p>in a straightforward manner.
* see also <cite>Op_shift_sector()</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">get_proj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span><span class="n">pcon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.get_vec">
<code class="sig-name descname">get_vec</code><span class="sig-paren">(</span><em class="sig-param">v0</em>, <em class="sig-param">sparse=True</em>, <em class="sig-param">pcon=False</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.get_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>DEPRECATED (cf <cite>project_from</cite>). Transforms state from symmetry-reduced basis to full (symmetry-free) basis.</p>
<p class="rubric">Notes</p>
<p>This function is <span class="red">deprecated</span>. Use <cite>project_from()</cite> instead; see also the inverse function <cite>project_to()</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.index">
<code class="sig-name descname">index</code><span class="sig-paren">(</span><em class="sig-param">s</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the index of user-defined Fock state in any lattice basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>s</strong><span class="classifier">{str, int}</span></dt><dd><p>Defines the Fock state with number of particles (spins) per site in underlying lattice <cite>basis</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>int</strong></dt><dd><p>Position of the Fock state in the lattice basis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Particularly useful for defining initial Fock states through a unit vector in the direction specified
by <cite>index()</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i0</span> <span class="o">=</span> <span class="n">index</span><span class="p">(</span><span class="s2">&quot;111000&quot;</span><span class="p">)</span> <span class="c1"># pick state from basis set</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># define state corresponding to the string &quot;111000&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.inplace_Op">
<code class="sig-name descname">inplace_Op</code><span class="sig-paren">(</span><em class="sig-param">v_in</em>, <em class="sig-param">op_list</em>, <em class="sig-param">dtype</em>, <em class="sig-param">transposed=False</em>, <em class="sig-param">conjugated=False</em>, <em class="sig-param">v_out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.inplace_Op" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the action of an operator on a state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v_in</strong><span class="classifier">array_like</span></dt><dd><p>state (or states stored in columns) to act on with the operator.</p>
</dd>
<dt><strong>op_list</strong><span class="classifier">list</span></dt><dd><p>Operator string list which defines the operator to apply. Follows the format <cite>[[“z”,[i],Jz[i]] for i in range(L)], [“x”,[i],Jx[j]] for j in range(L)],…]</cite>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">‘type’</span></dt><dd><p>Data type (e.g. <cite>numpy.float64</cite>) to construct the operator with.</p>
</dd>
<dt><strong>transposed</strong><span class="classifier">bool, optional</span></dt><dd><p>if <cite>True</cite> this function will act with the trasposed operator.</p>
</dd>
<dt><strong>conjugated</strong><span class="classifier">bool, optional</span></dt><dd><p>if <cite>True</cite> this function will act with the conjugated operator.</p>
</dd>
<dt><strong>v_out</strong><span class="classifier">array_like</span></dt><dd><p>output array, must be the same shape as <cite>v_in</cite> and must match the type of the output.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>numpy.ndarray</strong></dt><dd><ul class="simple">
<li><p>if <cite>v_out</cite> is not <cite>None</cite>, this function modifies <cite>v_out</cite> inplace and returns it.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function works with the <cite>tensor_basis</cite> and other basis which use the “|” symbol in the opstr.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="mf">1.41</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opstr</span> <span class="o">=</span> <span class="s2">&quot;zz&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">op_list</span><span class="o">=</span><span class="p">[[</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ME</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">inplace_Op</span><span class="p">(</span><span class="n">op_list</span><span class="p">,</span><span class="n">dtype</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.int_to_state">
<code class="sig-name descname">int_to_state</code><span class="sig-paren">(</span><em class="sig-param">state</em>, <em class="sig-param">bracket_notation=True</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.int_to_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds string representation of a state defined in integer representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">int</span></dt><dd><p>Defines the Fock state in integer representation in underlying lattice <cite>basis</cite>.</p>
</dd>
<dt><strong>bracket_notation</strong><span class="classifier">bool, optional</span></dt><dd><p>Toggles whether to return the state in <a href="#id2"><span class="problematic" id="id3">|</span></a>str&gt; notation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>str</strong></dt><dd><p>String corresponding to the Fock <cite>state</cite> in the lattice basis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is the einverse of <cite>state_to_int</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># pick state from basis set</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_str</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">int_to_state</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s_str</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.make">
<code class="sig-name descname">make</code><span class="sig-paren">(</span><em class="sig-param">Ns_block_est=None</em>, <em class="sig-param">N_p=None</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.make" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the entire basis by calling the basis constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Ns_block_est: int, optional</strong></dt><dd><p>Overwrites the internal estimate of the size of the reduced Hilbert space for the given symmetries. This can be used to help conserve memory if the exact size of the H-space is known ahead of time.</p>
</dd>
<dt><strong>N_p: int, optional</strong></dt><dd><p>number of bits to use in the prefix label used to generate blocks for searching positions of representatives.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>int</strong></dt><dd><p>Total number of states in the (symmetry-reduced) Hilbert space.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The memory stored in the basis grows exponentially as exactly <span class="math notranslate nohighlight">\(2^{N_p+1}\)</span>. The default behavior is to use <cite>N_p</cite> such that 
the size of the stored information for the representative bounds is approximately as large as the basis. This is not as effective
for basis which small particle numbers as the blocks have very uneven sizes. To not use the blocks just set N_p=0.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="p">,</span> <span class="n">Nup</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="o">=</span><span class="n">spin_basis_general</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">Nup</span><span class="o">=</span><span class="n">Nup</span><span class="p">,</span><span class="n">make_basis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="o">.</span><span class="n">make</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.make_basis_blocks">
<code class="sig-name descname">make_basis_blocks</code><span class="sig-paren">(</span><em class="sig-param">N_p=None</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.make_basis_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates/modifies the bounds for representatives based on prefix tages.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N_p: int, optional</strong></dt><dd><p>number of bits to use in the prefix label used to generate blocks for searching positions of representatives.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The memory stored in the basis grows exponentially as exactly <span class="math notranslate nohighlight">\(2^{N_p+1}\)</span>. The default behavior is to use <cite>N_p</cite> such that 
the size of the stored information for the representative bounds is approximately as large as the basis. This is not as effective
for basis which small particle numbers as the blocks have very uneven sizes. To not use the blocks just set N_p=0.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="p">,</span> <span class="n">Nup</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="o">=</span><span class="n">spin_basis_general</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">Nup</span><span class="o">=</span><span class="n">Nup</span><span class="p">,</span><span class="n">make_basis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="o">.</span><span class="n">make</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.normalization">
<code class="sig-name descname">normalization</code><span class="sig-paren">(</span><em class="sig-param">states</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.normalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes normalization of <cite>basis</cite> states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>states</strong><span class="classifier">array_like(int)</span></dt><dd><p>Fock-basis (z-basis) states to find the normalizations of. States are stored in integer representations.</p>
</dd>
<dt><strong>out</strong><span class="classifier">numpy.ndarray(unsigned int), optional</span></dt><dd><p>variable to store the normalizations of the states in. Must be a <cite>numpy.ndarray</cite> of datatype <cite>unsigned int</cite> (e.g. <cite>numpy.uint16</cite>), and same shape as <cite>states</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>array_like(int)</strong></dt><dd><p>normalizations of <cite>states</cite> for the given (symmetry-reduced) <cite>basis</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Returns zero, if the state is not part of the symmetry-reduced basis.</p></li>
<li><p>The normalizations can be used to compute matrix elements in the symmetry-reduced basis.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="o">=</span><span class="n">spin_basis_general</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">Nup</span><span class="o">=</span><span class="n">Nup</span><span class="p">,</span><span class="n">make_basis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="mi">17</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">norm_s</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">normalization</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">norm_s</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.operators">
<em class="property">property </em><code class="sig-name descname">operators</code><a class="headerlink" href="#quspin.basis.boson_basis_general.operators" title="Permalink to this definition">¶</a></dt>
<dd><p>set: set of available operator strings.</p>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.partial_trace">
<code class="sig-name descname">partial_trace</code><span class="sig-paren">(</span><em class="sig-param">state</em>, <em class="sig-param">sub_sys_A=None</em>, <em class="sig-param">subsys_ordering=True</em>, <em class="sig-param">return_rdm='A'</em>, <em class="sig-param">enforce_pure=False</em>, <em class="sig-param">sparse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.partial_trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates reduced density matrix, through a partial trace of a quantum state in a lattice <cite>basis</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier">obj</span></dt><dd><p>State of the quantum system. Can be either one of:</p>
<blockquote>
<div><ul class="simple">
<li><p>numpy.ndarray [shape (Ns,)]: pure state (default).</p></li>
<li><p>numpy.ndarray [shape (Ns,Ns)]: density matrix (DM).</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>sub_sys_A</strong><span class="classifier">tuple/list, optional</span></dt><dd><p>Defines the sites contained in subsystem A [by python convention the first site of the chain is labelled j=0].
Default is <cite>tuple(range(N//2))</cite> with <cite>N</cite> the number of lattice sites.</p>
</dd>
<dt><strong>return_rdm</strong><span class="classifier">str, optional</span></dt><dd><p>Toggles returning the reduced DM. Can be tierh one of:</p>
<blockquote>
<div><ul class="simple">
<li><p>“A”: returns reduced DM of subsystem A.</p></li>
<li><p>“B”: returns reduced DM of subsystem B.</p></li>
<li><p>“both”: returns reduced DM of both A and B subsystems.</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>subsys_ordering</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to reorder the sites in <cite>sub_sys_A</cite> in ascending order. Default is <cite>True</cite>.</p>
</dd>
<dt><strong>enforce_pure</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to assume <cite>state</cite> is a colelction of pure states or a mixed density matrix, if
it is a square array. Default is <cite>False</cite>.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to return a sparse DM. Default is <cite>False</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>numpy.ndarray</strong></dt><dd><p>Density matrix associated with <cite>state</cite>. Depends on optional arguments.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function can also be applied to trace out operators/observables defined by the input <cite>state</cite>, in which case one has 
to additionally normalize the final output by the Hilbert space dimension of the traced-out space. 
However, if an operator is defined in a symmetry-reduced basis, there is a <span class="red">caveat</span>. In such a case, one has to:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>use the <cite>basis.get_proj()</cite> function to lift the operator to the full basis;</p></li>
<li><p>apply <cite>basis.partial_trace()</cite>;</p></li>
<li><p>repeat this procedure for all symmetry sectors, and sum up the resulting reduced operators [this is becauce one has to add in the information about how the operator acts on the full Hilbert space].</p></li>
</ol>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">partial_trace</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">sub_sys_A</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">),</span><span class="n">return_rdm</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="n">enforce_pure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">subsys_ordering</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.project_from">
<code class="sig-name descname">project_from</code><span class="sig-paren">(</span><em class="sig-param">v0</em>, <em class="sig-param">sparse=True</em>, <em class="sig-param">pcon=False</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.project_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms state from symmetry-reduced basis to full (symmetry-free) basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v0</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Contains in its columns the states in the symmetry-reduced basis.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not the output should be in sparse format. Default is <cite>True</cite>.</p>
</dd>
<dt><strong>pcon</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to return the output in the particle number (magnetisation) conserving basis 
(useful in bosonic/single particle systems). Default is <cite>pcon=False</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>numpy.ndarray</strong></dt><dd><p>Array containing the state <cite>v0</cite> in the full basis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>particularly useful when a given operation cannot be carried out in the symmetry-reduced basis in a straightforward manner.</p></li>
<li><p>supports parallelisation to multiple states listed in the columns.</p></li>
<li><p>inverse function to <cite>project_to</cite>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v_full</span> <span class="o">=</span> <span class="n">project_from</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">v_full</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.project_to">
<code class="sig-name descname">project_to</code><span class="sig-paren">(</span><em class="sig-param">v0</em>, <em class="sig-param">sparse=True</em>, <em class="sig-param">pcon=False</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.project_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms state from full (symmetry-free) basis to symmetry-reduced basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v0</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Contains in its columns the states in the full (symmetry-free) basis.</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not the output should be in sparse format. Default is <cite>True</cite>.</p>
</dd>
<dt><strong>pcon</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not to return the output in the particle number (magnetisation) conserving basis 
(useful in bosonic/single particle systems). Default is <cite>pcon=False</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>numpy.ndarray</strong></dt><dd><p>Array containing the state <cite>v0</cite> in the symmetry-reduced basis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>particularly useful when a given operation cannot be carried out in the full basis.</p></li>
<li><p>supports parallelisation to multiple states listed in the columns.</p></li>
<li><p>inverse function to <cite>project_from</cite>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v_symm</span> <span class="o">=</span> <span class="n">project_to</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">v_symm</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.representative">
<code class="sig-name descname">representative</code><span class="sig-paren">(</span><em class="sig-param">states</em>, <em class="sig-param">out=None</em>, <em class="sig-param">return_g=False</em>, <em class="sig-param">return_sign=False</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.representative" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps states to their representatives under the <cite>basis</cite> symmetries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>states</strong><span class="classifier">array_like(int)</span></dt><dd><p>Fock-basis (z-basis) states to find the representatives of. States are stored in integer representations.</p>
</dd>
<dt><strong>out</strong><span class="classifier">numpy.ndarray(int), optional</span></dt><dd><p>variable to store the representative states in. Must be a <cite>numpy.ndarray</cite> of same datatype as <cite>basis</cite>, and same shape as <cite>states</cite>.</p>
</dd>
<dt><strong>return_g</strong><span class="classifier">bool, optional</span></dt><dd><p>if set to <cite>True</cite>, the function also returns the integer <cite>g</cite> corresponding to the number of times each basis symmetry needs to be applied to a given state to obtain its representative.</p>
</dd>
<dt><strong>return_sign</strong><span class="classifier">bool, optional</span></dt><dd><p>if set to <cite>True</cite>, the function returns the <cite>sign</cite> of the representative relative to the original state (nontrivial only for fermionic bases).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tuple</strong></dt><dd><p>( representatives, g_array, sign_array )
* array_like(int): <cite>representatives</cite>: Representatives under <cite>basis</cite> symmetries, corresponding to <cite>states</cite>.
* array_like(int): <cite>g_array</cite> of size (number of states, number of symmetries). Requires <cite>return_g=True</cite>. Contains integers corresponding to the number of times each basis symmetry needs to be applied to a given state to obtain its representative.
* array_like(int): <cite>sign_array</cite> of size (number of states,). Requires <cite>return_sign=True</cite>. Contains <cite>sign</cite> of the representative relative to the original state (nontrivial only for fermionic bases).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="o">=</span><span class="n">spin_basis_general</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">Nup</span><span class="o">=</span><span class="n">Nup</span><span class="p">,</span><span class="n">make_basis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="mi">17</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">representative</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.sps">
<em class="property">property </em><code class="sig-name descname">sps</code><a class="headerlink" href="#quspin.basis.boson_basis_general.sps" title="Permalink to this definition">¶</a></dt>
<dd><p>int: number of states per site (i.e. the on-site Hilbert space dimension).</p>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.state_to_int">
<code class="sig-name descname">state_to_int</code><span class="sig-paren">(</span><em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.boson_basis_general.state_to_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds integer representation of a state defined in string format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">str</span></dt><dd><p>Defines the Fock state with number of particles (spins) per site in underlying lattice <cite>basis</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>int</strong></dt><dd><p>Integer corresponding to the Fock <cite>state</cite> in the lattice basis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is the einverse of <cite>int_to_state</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s_str</span> <span class="o">=</span> <span class="s2">&quot;111000&quot;</span> <span class="c1"># pick state from basis set</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">state_to_int</span><span class="p">(</span><span class="n">s_str</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.boson_basis_general.states">
<em class="property">property </em><code class="sig-name descname">states</code><a class="headerlink" href="#quspin.basis.boson_basis_general.states" title="Permalink to this definition">¶</a></dt>
<dd><p>numpy.ndarray(int): basis states stored in their integer representation.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="quspin.basis.spin_basis_general.html"
                        title="previous chapter">quspin.basis.spin_basis_general</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="quspin.basis.spinless_fermion_basis_general.html"
                        title="next chapter">quspin.basis.spinless_fermion_basis_general</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../sources/generated/quspin.basis.boson_basis_general.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="quspin.basis.spinless_fermion_basis_general.html" title="quspin.basis.spinless_fermion_basis_general"
             >next</a> |</li>
        <li class="right" >
          <a href="quspin.basis.spin_basis_general.html" title="quspin.basis.spin_basis_general"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">QuSpin 0.3.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../basis.html" >Basis module (<code class="xref py py-mod docutils literal notranslate"><span class="pre">quspin.basis</span></code>)</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Phillip Weinberg and Marin Bukov.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.0.
    </div>
  </body>
</html>