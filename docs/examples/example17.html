
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-110543543-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <title>Optical Bloch equations: Lindblad dynamics using the fast (omp-parallelized) matvec function &#8212; QuSpin 0.3.3 documentation</title>
    <link rel="stylesheet" href="../static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../static/documentation_options.js"></script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">QuSpin 0.3.3 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="optical-bloch-equations-lindblad-dynamics-using-the-fast-omp-parallelized-matvec-function">
<span id="example17-label"></span><h1>Optical Bloch equations: Lindblad dynamics using the fast (omp-parallelized) <cite>matvec</cite> function<a class="headerlink" href="#optical-bloch-equations-lindblad-dynamics-using-the-fast-omp-parallelized-matvec-function" title="Permalink to this headline">¶</a></h1>
<p>This example uses the omp-parallelized <cite>tools.misc.matvec()</cite> function to define a Lindblad equation and solve the ODE using the <cite>tools.evolution.evolve()</cite> function.</p>
<p>Consider the the two-level system:</p>
<div class="math notranslate nohighlight">
\[\begin{split}H &amp;= \delta\sigma^z + \Omega_0\sigma^x, \\
L &amp;= \sigma^+.\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(H\)</span> is the Hamiltonian of the two-level system, and <span class="math notranslate nohighlight">\(L\)</span> is the Lindblad (or jump) operator. The Lindblad equation is a non-unitary extension of the Liouville-von Neumann equation for the density matrix <span class="math notranslate nohighlight">\(\rho(t)\)</span>:</p>
<div class="math notranslate nohighlight">
\[\partial_t\rho(t) = -i[H,\rho(t)] + 2\gamma\left(L\rho(t)L^\dagger - \frac{1}{2}\{L^\dagger L,\rho(t) \} \right),\]</div>
<p>where <span class="math notranslate nohighlight">\([\cdot,\cdot]\)</span> is the commutator, and <span class="math notranslate nohighlight">\(\{\cdot,\cdot\}\)</span> is the anti-commutator. The system of equations for this specific problem is also known as the optical Bloch equations.</p>
<p>Below, we provide three ways to define the function for the Lindblad ODE. The first version is very intuitive, but rather slow. The second version uses the <cite>hamiltonian.dot()</cite> and <cite>hamiltonian.rdot()</cite> functions and is a bit more sophisticated and a bit faster. The third version uses the <cite>matvec()</cite> function and is faster than the previous two (but may not be memory efficient for large systems).</p>
<p>Note that this way of simulating the Lindblad equation has severe limitations for many-body systems. An alternative, parallelizable way to effectively simulate a subset of Lindblad dynamics using unitary evolution is described in
<a class="reference external" href="https://arxiv.org/pdf/1608.01317.pdf">arXiv:1608.01317</a>.</p>
</div>
<div class="section" id="script">
<h1>Script<a class="headerlink" href="#script" title="Permalink to this headline">¶</a></h1>
<p><a class="reference download internal" download="" href="../downloads/10ed18c171d2e943303a53799bf3c742/example17.py"><code class="xref download docutils literal notranslate"><span class="pre">download</span> <span class="pre">script</span></code></a></p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>
<span class="c1">#</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span><span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;KMP_DUPLICATE_LIB_OK&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;True&#39;</span> <span class="c1"># uncomment this line if omp error occurs on OSX for python 3</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;OMP_NUM_THREADS&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;1&#39;</span> <span class="c1"># set number of OpenMP threads to run in parallel</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;MKL_NUM_THREADS&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;1&#39;</span> <span class="c1"># set number of MKL threads to run in parallel</span>
<span class="c1">#</span>
<span class="n">quspin_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span><span class="s2">&quot;../../&quot;</span><span class="p">)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">quspin_path</span><span class="p">)</span>
<span class="c1">###########################################################################</span>
<span class="c1">#                            example 17                                   #</span>
<span class="c1">#  In this script we demonstrate how to apply the matvec function         #</span>
<span class="c1">#  to define the Lundblad equation for a two-leel system, and solve it    #</span>
<span class="c1">#  using the evolve funcion.                                              #</span>
<span class="c1">###########################################################################</span>
<span class="kn">from</span> <span class="nn">quspin.operators</span> <span class="kn">import</span> <span class="n">hamiltonian</span><span class="p">,</span> <span class="n">commutator</span><span class="p">,</span> <span class="n">anti_commutator</span>
<span class="kn">from</span> <span class="nn">quspin.basis</span> <span class="kn">import</span> <span class="n">spin_basis_1d</span> <span class="c1"># Hilbert space spin basis_1d</span>
<span class="kn">from</span> <span class="nn">quspin.tools.evolution</span> <span class="kn">import</span> <span class="n">evolve</span>
<span class="kn">from</span> <span class="nn">quspin.tools.misc</span> <span class="kn">import</span> <span class="n">get_matvec_function</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">iteritems</span> <span class="c1"># loop over elements of dictionary</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span> <span class="c1"># plotting library</span>
<span class="c1">#</span>
<span class="c1">###### model parameters</span>
<span class="c1">#</span>
<span class="n">L</span><span class="o">=</span><span class="mi">1</span> <span class="c1"># one qubit</span>
<span class="n">delta</span><span class="o">=</span><span class="mf">1.0</span> <span class="c1"># detuning</span>
<span class="n">Omega_0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># bare Rabi frequency</span>
<span class="n">Omega_Rabi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Omega_0</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">delta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Rabi frequency</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># decay rate</span>
<span class="c1">#</span>
<span class="c1">##### create Hamiltonian to evolve unitarily</span>
<span class="c1"># basis</span>
<span class="n">basis</span><span class="o">=</span><span class="n">spin_basis_1d</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">pauli</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># uses convention &quot;+&quot; = [[0,1],[0,0]]</span>
<span class="c1"># site-coupling lists</span>
<span class="n">hx_list</span><span class="o">=</span><span class="p">[[</span><span class="n">Omega_0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">)]</span>
<span class="n">hz_list</span><span class="o">=</span><span class="p">[[</span><span class="n">delta</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">)]</span>
<span class="c1"># static opstr list </span>
<span class="n">static_H</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">hx_list</span><span class="p">],[</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="n">hz_list</span><span class="p">]]</span>
<span class="c1"># hamiltonian</span>
<span class="n">H</span><span class="o">=</span><span class="n">hamiltonian</span><span class="p">(</span><span class="n">static_H</span><span class="p">,[],</span><span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Hamiltonian:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>
<span class="c1">#</span>
<span class="c1">##### create Lindbladian</span>
<span class="c1"># site-coupling lists</span>
<span class="n">L_list</span><span class="o">=</span><span class="p">[[</span><span class="mf">1.0j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">)]</span>
<span class="c1"># static opstr list </span>
<span class="n">static_L</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;+&#39;</span><span class="p">,</span><span class="n">L_list</span><span class="p">]]</span>
<span class="c1"># Lindblad operator</span>
<span class="n">L</span><span class="o">=</span><span class="n">hamiltonian</span><span class="p">(</span><span class="n">static_L</span><span class="p">,[],</span><span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span><span class="n">check_herm</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Lindblad operator:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">L</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>
<span class="c1"># pre-compute operators for efficiency</span>
<span class="n">L_dagger</span><span class="o">=</span><span class="n">L</span><span class="o">.</span><span class="n">getH</span><span class="p">()</span>
<span class="n">L_daggerL</span><span class="o">=</span><span class="n">L_dagger</span><span class="o">*</span><span class="n">L</span>
<span class="c1">#</span>
<span class="c1">#### determine the corresponding matvec routines ####</span>
<span class="c1">#</span>
<span class="n">matvec</span><span class="o">=</span><span class="n">get_matvec_function</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">static</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">##### define Lindblad equation in diagonal form</span>
<span class="c1">#</span>
<span class="c1"># slow, straightforward function</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">Lindblad_EOM_v1</span><span class="p">(</span><span class="n">time</span><span class="p">,</span><span class="n">rho</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	This function solves the complex-valued time-dependent GPE:</span>
<span class="sd">	$$ \dot\rho(t) = -i[H,\rho(t)] + 2\gamma\left( L\rho L^\dagger - \frac{1}{2}\{L^\dagger L, \rho \} \right) $$</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c1"># solve static part of Lindblad equation</span>
	<span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">))</span>
	<span class="n">rho_dot</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1j</span><span class="o">*</span><span class="n">commutator</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">static</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">L_dagger</span><span class="p">)</span><span class="o">.</span><span class="n">static</span> <span class="o">-</span> <span class="n">gamma</span><span class="o">*</span><span class="n">anti_commutator</span><span class="p">(</span><span class="n">L_daggerL</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">static</span> 
	<span class="c1"># solve dynamic part of Lindblad equation (no time-dependence in Lindbladian for this example)</span>
	<span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">Hd</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">dynamic</span><span class="p">):</span>
		<span class="n">rho_dot</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1j</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">time</span><span class="p">)</span><span class="o">*</span><span class="n">commutator</span><span class="p">(</span><span class="n">Hd</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">rho_dot</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="c1">#</span>
<span class="c1"># intermediate, straightforward function using dot and rdot</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">Lindblad_EOM_v2</span><span class="p">(</span><span class="n">time</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">rho_out</span><span class="p">,</span><span class="n">rho_aux</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	This function solves the complex-valued time-dependent GPE:</span>
<span class="sd">	$$ \dot\rho(t) = -i[H,\rho(t)] + 2\gamma\left( L\rho L^\dagger - \frac{1}{2}\{L^\dagger L, \rho \} \right) $$</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">))</span> <span class="c1"># reshape vector from ODE solver input</span>
	<span class="c1">### Hamiltonian part</span>
	<span class="c1"># commutator term (unitary)</span>
	<span class="c1"># rho_out = H.static.dot(rho))</span>
	<span class="n">H</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">rho</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">rho_out</span>  <span class="p">,</span><span class="n">a</span><span class="o">=+</span><span class="mf">1.0</span><span class="p">,</span><span class="n">overwrite_out</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
	<span class="c1"># rho_out -= (H.static.T.dot(rho.T)).T // RHS~rho.dot(H) </span>
	<span class="n">H</span><span class="o">.</span><span class="n">rdot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">rho_out</span><span class="p">,</span><span class="n">a</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span><span class="n">overwrite_out</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
	<span class="c1"># multiply by -i</span>
	<span class="n">rho_out</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0j</span>
	<span class="c1">#</span>
	<span class="c1">### Lindbladian part (static only)</span>
	<span class="c1"># 1st Lindblad term (nonunitary)</span>
	<span class="c1"># rho_aux = 2\gamma*L.dot(rho)</span>
	<span class="n">L</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rho</span>             <span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">rho_aux</span>  <span class="p">,</span><span class="n">a</span><span class="o">=+</span><span class="mf">2.0</span><span class="o">*</span><span class="n">gamma</span><span class="p">,</span><span class="n">overwrite_out</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
	<span class="c1"># rho_out += (L.static.T.conj().dot(rho_aux.T)).T // RHS~rho_aux.dot(L_dagger) </span>
	<span class="n">L</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">rdot</span><span class="p">(</span><span class="n">rho_aux</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">rho_out</span><span class="p">,</span><span class="n">a</span><span class="o">=+</span><span class="mf">1.0</span><span class="p">,</span><span class="n">overwrite_out</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># L.H = L^\dagger</span>
	<span class="c1"># anticommutator (2nd Lindblad) term (nonunitary)</span>
	<span class="c1"># rho_out += gamma*L_daggerL._static.dot(rho)</span>
	<span class="n">L_daggerL</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rho</span>  <span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">rho_out</span>  <span class="p">,</span><span class="n">a</span><span class="o">=-</span><span class="n">gamma</span><span class="p">,</span><span class="n">overwrite_out</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
	<span class="c1"># # rho_out += gamma*(L_daggerL._static.T.dot(rho.T)).T // RHS~rho.dot(L_daggerL) </span>
	<span class="n">L_daggerL</span><span class="o">.</span><span class="n">rdot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">rho_out</span><span class="p">,</span><span class="n">a</span><span class="o">=-</span><span class="n">gamma</span><span class="p">,</span><span class="n">overwrite_out</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
	
	<span class="k">return</span> <span class="n">rho_out</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="c1"># ODE solver accepts vectors only</span>
<span class="c1">#</span>
<span class="c1"># fast function using matvec (not as memory efficient)</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">Lindblad_EOM_v3</span><span class="p">(</span><span class="n">time</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">rho_out</span><span class="p">,</span><span class="n">rho_aux</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	This function solves the complex-valued time-dependent GPE:</span>
<span class="sd">	$$ \dot\rho(t) = -i[H,\rho(t)] + 2\gamma\left( L\rho L^\dagger - \frac{1}{2}\{L^\dagger L, \rho \} \right) $$</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">))</span> <span class="c1"># reshape vector from ODE solver input</span>
	<span class="c1">### Hamiltonian part</span>
	<span class="c1"># commutator term (unitary</span>
	<span class="c1"># rho_out = H.static.dot(rho))</span>
	<span class="n">matvec</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">static</span>  <span class="p">,</span><span class="n">rho</span>  <span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">rho_out</span>  <span class="p">,</span><span class="n">a</span><span class="o">=+</span><span class="mf">1.0</span><span class="p">,</span><span class="n">overwrite_out</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
	<span class="c1"># rho_out -= (H.static.T.dot(rho.T)).T // RHS~rho.dot(H) </span>
	<span class="n">matvec</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">static</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">rho</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">rho_out</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">a</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span><span class="n">overwrite_out</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
	<span class="c1"># </span>
	<span class="k">for</span> <span class="n">func</span><span class="p">,</span><span class="n">Hd</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">_dynamic</span><span class="p">):</span>
		<span class="n">ft</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
		<span class="c1"># rho_out += ft*Hd.dot(rho)</span>
		<span class="n">matvec</span><span class="p">(</span><span class="n">Hd</span>  <span class="p">,</span><span class="n">rho</span>  <span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">rho_out</span>  <span class="p">,</span><span class="n">a</span><span class="o">=+</span><span class="n">ft</span><span class="p">,</span><span class="n">overwrite_out</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
		<span class="c1"># rho_out -= ft*(Hd.T.dot(rho.T)).T </span>
		<span class="n">matvec</span><span class="p">(</span><span class="n">Hd</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">rho</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">rho_out</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">a</span><span class="o">=-</span><span class="n">ft</span><span class="p">,</span><span class="n">overwrite_out</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
	<span class="c1"># multiply by -i</span>
	<span class="n">rho_out</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0j</span>
	<span class="c1">#</span>
	<span class="c1">### Lindbladian part (static only)</span>
	<span class="c1"># 1st Lindblad term (nonunitary)</span>
	<span class="c1"># rho_aux = 2\gamma*L.dot(rho)</span>
	<span class="n">matvec</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">static</span>  <span class="p">,</span><span class="n">rho</span>             <span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">rho_aux</span>  <span class="p">,</span><span class="n">a</span><span class="o">=+</span><span class="mf">2.0</span><span class="o">*</span><span class="n">gamma</span><span class="p">,</span><span class="n">overwrite_out</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
	<span class="c1"># rho_out += (L.static.T.conj().dot(rho_aux.T)).T // RHS~rho_aux.dot(L_dagger) </span>
	<span class="n">matvec</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">static</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">rho_aux</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">rho_out</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">a</span><span class="o">=+</span><span class="mf">1.0</span><span class="p">,</span><span class="n">overwrite_out</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
	<span class="c1"># anticommutator (2nd Lindblad) term (nonunitary)</span>
	<span class="c1"># rho_out += gamma*L_daggerL.static.dot(rho)</span>
	<span class="n">matvec</span><span class="p">(</span><span class="n">L_daggerL</span><span class="o">.</span><span class="n">static</span>  <span class="p">,</span><span class="n">rho</span>  <span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">rho_out</span>  <span class="p">,</span><span class="n">a</span><span class="o">=-</span><span class="n">gamma</span><span class="p">,</span><span class="n">overwrite_out</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
	<span class="c1"># # rho_out += gamma*(L_daggerL.static.T.dot(rho.T)).T // RHS~rho.dot(L_daggerL) </span>
	<span class="n">matvec</span><span class="p">(</span><span class="n">L_daggerL</span><span class="o">.</span><span class="n">static</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">rho</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">rho_out</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">a</span><span class="o">=-</span><span class="n">gamma</span><span class="p">,</span><span class="n">overwrite_out</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
	
	<span class="k">return</span> <span class="n">rho_out</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="c1"># ODE solver accepts vectors only</span>
<span class="c1">#</span>
<span class="c1"># define auxiliary arguments</span>
<span class="n">EOM_args</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">),</span>    <span class="c1"># auxiliary variable rho_out</span>
		  <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">),</span>  <span class="p">)</span> <span class="c1"># auxiliary variable rho_aux</span>
<span class="c1">#</span>
<span class="c1">##### time-evolve state according to Lindlad equation</span>
<span class="c1"># define real time vector</span>
<span class="n">t_max</span><span class="o">=</span><span class="mf">6.0</span>
<span class="n">time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="n">t_max</span><span class="p">,</span><span class="mi">101</span><span class="p">)</span>
<span class="c1"># define initial state</span>
<span class="n">rho0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5j</span><span class="p">],[</span><span class="o">-</span><span class="mf">0.5j</span><span class="p">,</span><span class="mf">0.5</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="c1"># slow solution, uses Lindblad_EOM_v1</span>
<span class="c1">#rho_t = evolve(rho0,time[0],time,Lindblad_EOM_v1,iterate=True,atol=1E-12,rtol=1E-12)</span>
<span class="c1"># intermediate function, uses Lindblad_EOM_v2</span>
<span class="c1">#rho_t = evolve(rho0,time[0],time,Lindblad_EOM_v2,f_params=EOM_args,iterate=True,atol=1E-12,rtol=1E-12) </span>
<span class="c1"># fast solution (but 3 times as memory intensive), uses Lindblad_EOM_v3</span>
<span class="n">rho_t</span> <span class="o">=</span> <span class="n">evolve</span><span class="p">(</span><span class="n">rho0</span><span class="p">,</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">time</span><span class="p">,</span><span class="n">Lindblad_EOM_v3</span><span class="p">,</span><span class="n">f_params</span><span class="o">=</span><span class="n">EOM_args</span><span class="p">,</span><span class="n">iterate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">atol</span><span class="o">=</span><span class="mf">1E-12</span><span class="p">,</span><span class="n">rtol</span><span class="o">=</span><span class="mf">1E-12</span><span class="p">)</span> 
<span class="c1">#</span>
<span class="c1"># compute state evolution</span>
<span class="n">population_down</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">rho_flattened</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rho_t</span><span class="p">):</span>
	<span class="n">rho</span><span class="o">=</span><span class="n">rho_flattened</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">)</span>
	<span class="n">population_down</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">rho_flattened</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">print</span><span class="p">(</span><span class="s2">&quot;time={0:.2f}, population of down state = {1:0.8f}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">population_down</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">)</span>
<span class="c1">#</span>
<span class="c1">##### plot population dynamics of down state</span>
<span class="c1">#</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Omega_Rabi</span><span class="o">*</span><span class="n">time</span><span class="p">,</span> <span class="n">population_down</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;$</span><span class="se">\\</span><span class="s1">Omega_R t$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;$</span><span class="se">\\</span><span class="s1">rho_{</span><span class="se">\\</span><span class="s1">downarrow</span><span class="se">\\</span><span class="s1">downarrow}$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;example17.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Optical Bloch equations: Lindblad dynamics using the fast (omp-parallelized) <cite>matvec</cite> function</a></li>
<li><a class="reference internal" href="#script">Script</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../sources/examples/example17.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">QuSpin 0.3.3 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Phillip Weinberg and Marin Bukov.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>